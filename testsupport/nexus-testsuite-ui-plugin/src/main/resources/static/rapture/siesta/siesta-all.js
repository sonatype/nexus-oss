/*

Siesta 2.0.5
Copyright(c) 2009-2013 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/products/siesta/license

*/
;!function () {;
var Joose = {}

// configuration hash

Joose.C             = typeof JOOSE_CFG != 'undefined' ? JOOSE_CFG : {}

Joose.is_IE         = '\v' == 'v'
Joose.is_NodeJS     = Boolean(typeof process != 'undefined' && process.pid)


Joose.top           = Joose.is_NodeJS && global || this

Joose.stub          = function () {
    return function () { throw new Error("Modules can not be instantiated") }
}


Joose.VERSION       = ({ /*PKGVERSION*/VERSION : '3.50.1' }).VERSION


if (typeof module != 'undefined') module.exports = Joose
/*if (!Joose.is_NodeJS) */
this.Joose = Joose


// Static helpers for Arrays
Joose.A = {

    each : function (array, func, scope) {
        scope = scope || this
        
        for (var i = 0, len = array.length; i < len; i++) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    eachR : function (array, func, scope) {
        scope = scope || this

        for (var i = array.length - 1; i >= 0; i--) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    exists : function (array, value) {
        for (var i = 0, len = array.length; i < len; i++) if (array[i] == value) return true
            
        return false
    },
    
    
    map : function (array, func, scope) {
        scope = scope || this
        
        var res = []
        
        for (var i = 0, len = array.length; i < len; i++) 
            res.push( func.call(scope, array[i], i) )
            
        return res
    },
    

    grep : function (array, func) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (func(t)) a.push(t)
        })
        
        return a
    },
    
    
    remove : function (array, removeEle) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (t !== removeEle) a.push(t)
        })
        
        return a
    }
    
}

// Static helpers for Strings
Joose.S = {
    
    saneSplit : function (str, delimeter) {
        var res = (str || '').split(delimeter)
        
        if (res.length == 1 && !res[0]) res.shift()
        
        return res
    },
    

    uppercaseFirst : function (string) { 
        return string.substr(0, 1).toUpperCase() + string.substr(1, string.length - 1)
    },
    
    
    strToClass : function (name, top) {
        var current = top || Joose.top
        
        Joose.A.each(name.split('.'), function (segment) {
            if (current) 
                current = current[ segment ]
            else
                return false
        })
        
        return current
    }
}

var baseFunc    = function () {}

var enumProps   = [ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ]

var manualEnum  = true

for (var i in { toString : 1 }) manualEnum = false


// Static helpers for objects
Joose.O = {

    each : function (object, func, scope) {
        scope = scope || this
        
        for (var i in object) 
            if (func.call(scope, object[i], i) === false) return false
        
        if (manualEnum) 
            return Joose.A.each(enumProps, function (el) {
                
                if (object.hasOwnProperty(el)) return func.call(scope, object[el], el)
            })
    },
    
    
    eachOwn : function (object, func, scope) {
        scope = scope || this
        
        return Joose.O.each(object, function (value, name) {
            if (object.hasOwnProperty(name)) return func.call(scope, value, name)
        }, scope)
    },
    
    
    copy : function (source, target) {
        target = target || {}
        
        Joose.O.each(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    copyOwn : function (source, target) {
        target = target || {}
        
        Joose.O.eachOwn(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    getMutableCopy : function (object) {
        baseFunc.prototype = object
        
        return new baseFunc()
    },
    
    
    extend : function (target, source) {
        return Joose.O.copy(source, target)
    },
    
    
    isEmpty : function (object) {
        for (var i in object) if (object.hasOwnProperty(i)) return false
        
        return true
    },
    
    
    isInstance: function (obj) {
        return obj && obj.meta && obj.constructor == obj.meta.c
    },
    
    
    isClass : function (obj) {
        return obj && obj.meta && obj.meta.c == obj
    },
    
    
    wantArray : function (obj) {
        if (obj instanceof Array) return obj
        
        return [ obj ]
    },
    
    
    // this was a bug in WebKit, which gives typeof / / == 'function'
    // should be monitored and removed at some point in the future
    isFunction : function (obj) {
        return typeof obj == 'function' && obj.constructor != / /.constructor
    }
}


//initializers

Joose.I = {
    Array       : function () { return [] },
    Object      : function () { return {} },
    Function    : function () { return arguments.callee },
    Now         : function () { return new Date() }
};
Joose.Proto = Joose.stub()

Joose.Proto.Empty = Joose.stub()
    
Joose.Proto.Empty.meta = {};
;(function () {

    Joose.Proto.Object = Joose.stub()
    
    
    var SUPER = function () {
        var self = SUPER.caller
        
        if (self == SUPERARG) self = self.caller
        
        if (!self.SUPER) throw "Invalid call to SUPER"
        
        return self.SUPER[self.methodName].apply(this, arguments)
    }
    
    
    var SUPERARG = function () {
        return this.SUPER.apply(this, arguments[0])
    }
    
    
    
    Joose.Proto.Object.prototype = {
        
        SUPERARG : SUPERARG,
        SUPER : SUPER,
        
        INNER : function () {
            throw "Invalid call to INNER"
        },                
        
        
        BUILD : function (config) {
            return arguments.length == 1 && typeof config == 'object' && config || {}
        },
        
        
        initialize: function () {
        },
        
        
        toString: function () {
            return "a " + this.meta.name
        }
        
    }
        
    Joose.Proto.Object.meta = {
        constructor     : Joose.Proto.Object,
        
        methods         : Joose.O.copy(Joose.Proto.Object.prototype),
        attributes      : {}
    }
    
    Joose.Proto.Object.prototype.meta = Joose.Proto.Object.meta

})();
;(function () {

    Joose.Proto.Class = function () {
        return this.initialize(this.BUILD.apply(this, arguments)) || this
    }
    
    var bootstrap = {
        
        VERSION             : null,
        AUTHORITY           : null,
        
        constructor         : Joose.Proto.Class,
        superClass          : null,
        
        name                : null,
        
        attributes          : null,
        methods             : null,
        
        meta                : null,
        c                   : null,
        
        defaultSuperClass   : Joose.Proto.Object,
        
        
        BUILD : function (name, extend) {
            this.name = name
            
            return { __extend__ : extend || {} }
        },
        
        
        initialize: function (props) {
            var extend      = props.__extend__
            
            this.VERSION    = extend.VERSION
            this.AUTHORITY  = extend.AUTHORITY
            
            delete extend.VERSION
            delete extend.AUTHORITY
            
            this.c = this.extractConstructor(extend)
            
            this.adaptConstructor(this.c)
            
            if (extend.constructorOnly) {
                delete extend.constructorOnly
                return
            }
            
            this.construct(extend)
        },
        
        
        construct : function (extend) {
            if (!this.prepareProps(extend)) return
            
            var superClass = this.superClass = this.extractSuperClass(extend)
            
            this.processSuperClass(superClass)
            
            this.adaptPrototype(this.c.prototype)
            
            this.finalize(extend)
        },
        
        
        finalize : function (extend) {
            this.processStem(extend)
            
            this.extend(extend)
        },
        
        
        //if the extension returns false from this method it should re-enter 'construct'
        prepareProps : function (extend) {
            return true
        },
        
        
        extractConstructor : function (extend) {
            var res = extend.hasOwnProperty('constructor') ? extend.constructor : this.defaultConstructor()
            
            delete extend.constructor
            
            return res
        },
        
        
        extractSuperClass : function (extend) {
            if (extend.hasOwnProperty('isa') && !extend.isa) throw new Error("Attempt to inherit from undefined superclass [" + this.name + "]")
            
            var res = extend.isa || this.defaultSuperClass
            
            delete extend.isa
            
            return res
        },
        
        
        processStem : function () {
            var superMeta       = this.superClass.meta
            
            this.methods        = Joose.O.getMutableCopy(superMeta.methods || {})
            this.attributes     = Joose.O.getMutableCopy(superMeta.attributes || {})
        },
        
        
        initInstance : function (instance, props) {
            Joose.O.copyOwn(props, instance)
        },
        
        
        defaultConstructor: function () {
            return function (arg) {
                var BUILD = this.BUILD
                
                var args = BUILD && BUILD.apply(this, arguments) || arg || {}
                
                var thisMeta    = this.meta
                
                thisMeta.initInstance(this, args)
                
                return thisMeta.hasMethod('initialize') && this.initialize(args) || this
            }
        },
        
        
        processSuperClass: function (superClass) {
            var superProto      = superClass.prototype
            
            //non-Joose superclasses
            if (!superClass.meta) {
                
                var extend = Joose.O.copy(superProto)
                
                extend.isa = Joose.Proto.Empty
                // clear potential value in the `extend.constructor` to prevent it from being modified
                delete extend.constructor
                
                var meta = new this.defaultSuperClass.meta.constructor(null, extend)
                
                superClass.meta = superProto.meta = meta
                
                meta.c = superClass
            }
            
            this.c.prototype    = Joose.O.getMutableCopy(superProto)
            this.c.superClass   = superProto
        },
        
        
        adaptConstructor: function (c) {
            c.meta = this
            
            if (!c.hasOwnProperty('toString')) c.toString = function () { return this.meta.name }
        },
    
        
        adaptPrototype: function (proto) {
            //this will fix weird semantic of native "constructor" property to more intuitive (idea borrowed from Ext)
            proto.constructor   = this.c
            proto.meta          = this
        },
        
        
        addMethod: function (name, func) {
            func.SUPER = this.superClass.prototype
            
            //chrome don't allow to redefine the "name" property
            func.methodName = name
            
            this.methods[name] = func
            this.c.prototype[name] = func
        },
        
        
        addAttribute: function (name, init) {
            this.attributes[name] = init
            this.c.prototype[name] = init
        },
        
        
        removeMethod : function (name) {
            delete this.methods[name]
            delete this.c.prototype[name]
        },
    
        
        removeAttribute: function (name) {
            delete this.attributes[name]
            delete this.c.prototype[name]
        },
        
        
        hasMethod: function (name) { 
            return Boolean(this.methods[name])
        },
        
        
        hasAttribute: function (name) { 
            return this.attributes[name] !== undefined
        },
        
    
        hasOwnMethod: function (name) { 
            return this.hasMethod(name) && this.methods.hasOwnProperty(name)
        },
        
        
        hasOwnAttribute: function (name) { 
            return this.hasAttribute(name) && this.attributes.hasOwnProperty(name)
        },
        
        
        extend : function (props) {
            Joose.O.eachOwn(props, function (value, name) {
                if (name != 'meta' && name != 'constructor') 
                    if (Joose.O.isFunction(value) && !value.meta) 
                        this.addMethod(name, value) 
                    else 
                        this.addAttribute(name, value)
            }, this)
        },
        
        
        subClassOf : function (classObject, extend) {
            return this.subClass(extend, null, classObject)
        },
    
    
        subClass : function (extend, name, classObject) {
            extend      = extend        || {}
            extend.isa  = classObject   || this.c
            
            return new this.constructor(name, extend).c
        },
        
        
        instantiate : function () {
            var f = function () {}
            
            f.prototype = this.c.prototype
            
            var obj = new f()
            
            return this.c.apply(obj, arguments) || obj
        }
    }
    
    //micro bootstraping
    
    Joose.Proto.Class.prototype = Joose.O.getMutableCopy(Joose.Proto.Object.prototype)
    
    Joose.O.extend(Joose.Proto.Class.prototype, bootstrap)
    
    Joose.Proto.Class.prototype.meta = new Joose.Proto.Class('Joose.Proto.Class', bootstrap)
    
    
    
    Joose.Proto.Class.meta.addMethod('isa', function (someClass) {
        var f = function () {}
        
        f.prototype = this.c.prototype
        
        return new f() instanceof someClass
    })
})();
Joose.Managed = Joose.stub()

Joose.Managed.Property = new Joose.Proto.Class('Joose.Managed.Property', {
    
    name            : null,
    
    init            : null,
    value           : null,
    
    definedIn       : null,
    
    
    initialize : function (props) {
        Joose.Managed.Property.superClass.initialize.call(this, props)
        
        this.computeValue()
    },
    
    
    computeValue : function () {
        this.value = this.init
    },    
    
    
    //targetClass is still open at this stage
    preApply : function (targetClass) {
    },
    

    //targetClass is already open at this stage
    postUnApply : function (targetClass) {
    },
    
    
    apply : function (target) {
        target[this.name] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target[this.name] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from[this.name]
    },
    
    
    cloneProps : function () {
        return {
            name        : this.name, 
            init        : this.init,
            definedIn   : this.definedIn
        }
    },

    
    clone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    }
    
    
}).c;
Joose.Managed.Property.ConflictMarker = new Joose.Proto.Class('Joose.Managed.Property.ConflictMarker', {
    
    isa : Joose.Managed.Property,

    apply : function (target) {
        throw new Error("Attempt to apply ConflictMarker [" + this.name + "] to [" + target + "]")
    }
    
}).c;
Joose.Managed.Property.Requirement = new Joose.Proto.Class('Joose.Managed.Property.Requirement', {
    
    isa : Joose.Managed.Property,

    
    apply : function (target) {
        if (!target.meta.hasMethod(this.name)) 
            throw new Error("Requirement [" + this.name + "], defined in [" + this.definedIn.definedIn.name + "] is not satisfied for class [" + target + "]")
    },
    
    
    unapply : function (from) {
    }
    
}).c;
Joose.Managed.Property.Attribute = new Joose.Proto.Class('Joose.Managed.Property.Attribute', {
    
    isa : Joose.Managed.Property,
    
    slot                : null,
    
    
    initialize : function () {
        Joose.Managed.Property.Attribute.superClass.initialize.apply(this, arguments)
        
        this.slot = this.name
    },
    
    
    apply : function (target) {
        target.prototype[ this.slot ] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target.prototype[ this.slot ] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from.prototype[this.slot]
    },
    
    
    clearValue : function (instance) {
        delete instance[ this.slot ]
    },
    
    
    hasValue : function (instance) {
        return instance.hasOwnProperty(this.slot)
    },
        
        
    getRawValueFrom : function (instance) {
        return instance[ this.slot ]
    },
    
    
    setRawValueTo : function (instance, value) {
        instance[ this.slot ] = value
        
        return this
    }
    
}).c;
Joose.Managed.Property.MethodModifier = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier', {
    
    isa : Joose.Managed.Property,

    
    prepareWrapper : function () {
        throw "Abstract method [prepareWrapper] of " + this + " was called"
    },
    
    
    apply : function (target) {
        var name            = this.name
        var targetProto     = target.prototype
        var isOwn           = targetProto.hasOwnProperty(name)
        var original        = targetProto[name]
        var superProto      = target.meta.superClass.prototype
        
        
        var originalCall = isOwn ? original : function () { 
            return superProto[name].apply(this, arguments) 
        }
        
        var methodWrapper = this.prepareWrapper({
            name            : name,
            modifier        : this.value, 
            
            isOwn           : isOwn,
            originalCall    : originalCall, 
            
            superProto      : superProto,
            
            target          : target
        })
        
        if (isOwn) methodWrapper.__ORIGINAL__ = original
        
        methodWrapper.__CONTAIN__   = this.value
        methodWrapper.__METHOD__    = this
        this.value.displayName      = this.getDisplayName(target)
        methodWrapper.displayName   = 'internal wrapper' 
        
        targetProto[name] = methodWrapper
    },
    
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    },
    
    
    isAppliedTo : function (target) {
        var targetCont = target.prototype[this.name]
        
        return targetCont && targetCont.__CONTAIN__ == this.value
    },
    
    
    unapply : function (from) {
        var name = this.name
        var fromProto = from.prototype
        var original = fromProto[name].__ORIGINAL__
        
        if (!this.isAppliedTo(from)) throw "Unapply of method [" + name + "] from class [" + from + "] failed"
        
        //if modifier was applied to own method - restore it
        if (original) 
            fromProto[name] = original
        //otherwise - just delete it, to reveal the inherited method 
        else
            delete fromProto[name]
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Override = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Override', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        var superProto      = params.superProto
        var superMetaConst  = superProto.meta.constructor
        
        //call to Joose.Proto level, require some additional processing
        var isCallToProto = (superMetaConst == Joose.Proto.Class || superMetaConst == Joose.Proto.Object) && !(params.isOwn && originalCall.IS_OVERRIDE) 
        
        var original = originalCall
        
        if (isCallToProto) original = function () {
            var beforeSUPER = this.SUPER
            
            this.SUPER  = superProto.SUPER
            
            var res = originalCall.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }

        var override = function () {
            
            var beforeSUPER = this.SUPER
            
            this.SUPER  = original
            
            var res = modifier.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }
        
        override.IS_OVERRIDE = true
        
        return override
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[override ' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.Put = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Put', {
    
    isa : Joose.Managed.Property.MethodModifier.Override,


    prepareWrapper : function (params) {
        
        if (params.isOwn) throw "Method [" + params.name + "] is applying over something [" + params.originalCall + "] in class [" + params.target + "]"
        
        return Joose.Managed.Property.MethodModifier.Put.superClass.prepareWrapper.call(this, params)
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.After = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.After', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            var res = originalCall.apply(this, arguments)
            modifier.apply(this, arguments)
            return res
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[after ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Before = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Before', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            modifier.apply(this, arguments)
            return originalCall.apply(this, arguments)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[before ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Around = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Around', {
    
    isa : Joose.Managed.Property.MethodModifier,

    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        var me
        
        var bound = function () {
            return originalCall.apply(me, arguments)
        }
            
        return function () {
            me = this
            
            var boundArr = [ bound ]
            boundArr.push.apply(boundArr, arguments)
            
            return modifier.apply(this, boundArr)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[around ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Augment = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Augment', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var AUGMENT = function () {
            
            //populate callstack to the most deep non-augment method
            var callstack = []
            
            var self = AUGMENT
            
            do {
                callstack.push(self.IS_AUGMENT ? self.__CONTAIN__ : self)
                
                self = self.IS_AUGMENT && (self.__ORIGINAL__ || self.SUPER[self.methodName])
            } while (self)
            
            
            //save previous INNER
            var beforeINNER = this.INNER
            
            //create new INNER
            this.INNER = function () {
                var innerCall = callstack.pop()
                
                return innerCall ? innerCall.apply(this, arguments) : undefined
            }
            
            //augment modifier results in hypotetical INNER call of the same method in subclass 
            var res = this.INNER.apply(this, arguments)
            
            //restore previous INNER chain
            this.INNER = beforeINNER
            
            return res
        }
        
        AUGMENT.methodName  = params.name
        AUGMENT.SUPER       = params.superProto
        AUGMENT.IS_AUGMENT  = true
        
        return AUGMENT
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[augment ' + this.name + ']'
    }
    
}).c;
Joose.Managed.PropertySet = new Joose.Proto.Class('Joose.Managed.PropertySet', {
    
    isa                       : Joose.Managed.Property,

    properties                : null,
    
    propertyMetaClass         : Joose.Managed.Property,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.superClass.initialize.call(this, props)
        
        //XXX this guards the meta roles :)
        this.properties = props.properties || {}
    },
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta || this.propertyMetaClass
        delete props.meta
        
        props.definedIn     = this
        props.name          = name
        
        return this.properties[name] = new metaClass(props)
    },
    
    
    addPropertyObject : function (object) {
        return this.properties[object.name] = object
    },
    
    
    removeProperty : function (name) {
        var prop = this.properties[name]
        
        delete this.properties[name]
        
        return prop
    },
    
    
    haveProperty : function (name) {
        return this.properties[name] != null
    },
    

    haveOwnProperty : function (name) {
        return this.haveProperty(name) && this.properties.hasOwnProperty(name)
    },
    
    
    getProperty : function (name) {
        return this.properties[name]
    },
    
    
    //includes inherited properties (probably you wants 'eachOwn', which process only "own" (including consumed from Roles) properties) 
    each : function (func, scope) {
        Joose.O.each(this.properties, func, scope || this)
    },
    
    
    eachOwn : function (func, scope) {
        Joose.O.eachOwn(this.properties, func, scope || this)
    },
    
    
    //synonym for each
    eachAll : function (func, scope) {
        this.each(func, scope)
    },
    
    
    cloneProps : function () {
        var props = Joose.Managed.PropertySet.superClass.cloneProps.call(this)
        
        props.propertyMetaClass     = this.propertyMetaClass
        
        return props
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        clone.properties = Joose.O.copyOwn(this.properties)
        
        return clone
    },
    
    
    cleanClone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    },
    
    
    alias : function (what) {
        var props = this.properties
        
        Joose.O.each(what, function (aliasName, originalName) {
            var original = props[originalName]
            
            if (original) this.addPropertyObject(original.clone(aliasName))
        }, this)
    },
    
    
    exclude : function (what) {
        var props = this.properties
        
        Joose.A.each(what, function (name) {
            delete props[name]
        })
    },
    
    
    beforeConsumedBy : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.eachOwn(function (property, name) {
            var targetProperty = targetProps[name]
            
            if (targetProperty instanceof Joose.Managed.Property.ConflictMarker) return
            
            if (!targetProps.hasOwnProperty(name) || targetProperty == null) {
                target.addPropertyObject(property)
                return
            }
            
            if (targetProperty == property) return
            
            target.removeProperty(name)
            target.addProperty(name, {
                meta : Joose.Managed.Property.ConflictMarker
            })
        }, this)
    },
    
    
    composeTo : function (target) {
        this.eachOwn(function (property, name) {
            if (!target.haveOwnProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeFrom : function () {
        if (!arguments.length) return
        
        var flattening = this.cleanClone()
        
        Joose.A.each(arguments, function (arg) {
            var isDescriptor    = !(arg instanceof Joose.Managed.PropertySet)
            var propSet         = isDescriptor ? arg.propertySet : arg
            
            propSet.beforeConsumedBy(this, flattening)
            
            if (isDescriptor) {
                if (arg.alias || arg.exclude)   propSet = propSet.clone()
                if (arg.alias)                  propSet.alias(arg.alias)
                if (arg.exclude)                propSet.exclude(arg.exclude)
            }
            
            propSet.flattenTo(flattening)
        }, this)
        
        flattening.composeTo(this)
    },
    
    
    preApply : function (target) {
        this.eachOwn(function (property) {
            property.preApply(target)
        })
    },
    
    
    apply : function (target) {
        this.eachOwn(function (property) {
            property.apply(target)
        })
    },
    
    
    unapply : function (from) {
        this.eachOwn(function (property) {
            property.unapply(from)
        })
    },
    
    
    postUnApply : function (target) {
        this.eachOwn(function (property) {
            property.postUnApply(target)
        })
    }
    
}).c
;
var __ID__ = 1


Joose.Managed.PropertySet.Mutable = new Joose.Proto.Class('Joose.Managed.PropertySet.Mutable', {
    
    isa                 : Joose.Managed.PropertySet,

    ID                  : null,
    
    derivatives         : null,
    
    opened              : null,
    
    composedFrom        : null,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.Mutable.superClass.initialize.call(this, props)
        
        //initially opened
        this.opened             = 1
        this.derivatives        = {}
        this.ID                 = __ID__++
        this.composedFrom       = []
    },
    
    
    addComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            this.composedFrom.push(arg)
            
            var propSet = arg instanceof Joose.Managed.PropertySet ? arg : arg.propertySet
                
            propSet.derivatives[this.ID] = this
        }, this)
    },
    
    
    removeComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            
            var i = 0
            
            while (i < this.composedFrom.length) {
                var propSet = this.composedFrom[i]
                propSet = propSet instanceof Joose.Managed.PropertySet ? propSet : propSet.propertySet
                
                if (arg == propSet) {
                    delete propSet.derivatives[this.ID]
                    this.composedFrom.splice(i, 1)
                } else i++
            }
            
        }, this)
    },
    
    
    ensureOpen : function () {
        if (!this.opened) throw "Mutation of closed property set: [" + this.name + "]"
    },
    
    
    addProperty : function (name, props) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addProperty.call(this, name, props)
    },
    

    addPropertyObject : function (object) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addPropertyObject.call(this, object)
    },
    
    
    removeProperty : function (name) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.removeProperty.call(this, name)
    },
    
    
    composeFrom : function () {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.composeFrom.apply(this, this.composedFrom)
    },
    
    
    open : function () {
        this.opened++
        
        if (this.opened == 1) {
        
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.open()
            })
            
            this.deCompose()
        }
    },
    
    
    close : function () {
        if (!this.opened) throw "Unmatched 'close' operation on property set: [" + this.name + "]"
        
        if (this.opened == 1) {
            this.reCompose()
            
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.close()
            })
        }
        this.opened--
    },
    
    
    reCompose : function () {
        this.composeFrom()
    },
    
    
    deCompose : function () {
        this.eachOwn(function (property, name) {
            if (property.definedIn != this) this.removeProperty(name)
        }, this)
    }
    
}).c;
Joose.Managed.StemElement = function () { throw "Modules may not be instantiated." }

Joose.Managed.StemElement.Attributes = new Joose.Proto.Class('Joose.Managed.StemElement.Attributes', {
    
    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Attribute
    
}).c
;
Joose.Managed.StemElement.Methods = new Joose.Proto.Class('Joose.Managed.StemElement.Methods', {
    
    isa : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass : Joose.Managed.Property.MethodModifier.Put,

    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.Requirements = new Joose.Proto.Class('Joose.Managed.StemElement.Requirements', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Requirement,
    
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        this.each(function (property, name) {
            if (!target.haveProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },
    
    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.MethodModifiers = new Joose.Proto.Class('Joose.Managed.StemElement.MethodModifiers', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : null,
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta
        delete props.meta
        
        props.definedIn         = this
        props.name              = name
        
        var modifier            = new metaClass(props)
        var properties          = this.properties
        
        if (!properties[name]) properties[ name ] = []
        
        properties[name].push(modifier)
        
        return modifier
    },
    

    addPropertyObject : function (object) {
        var name            = object.name
        var properties      = this.properties
        
        if (!properties[name]) properties[name] = []
        
        properties[name].push(object)
        
        return object
    },
    
    
    //remove only the last modifier
    removeProperty : function (name) {
        if (!this.haveProperty(name)) return undefined
        
        var properties      = this.properties
        var modifier        = properties[ name ].pop()
        
        //if all modifiers were removed - clearing the properties
        if (!properties[name].length) Joose.Managed.StemElement.MethodModifiers.superClass.removeProperty.call(this, name)
        
        return modifier
    },
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (modifiersArr, name) {
            var targetModifiersArr = targetProps[name]
            
            if (targetModifiersArr == null) targetModifiersArr = targetProps[name] = []
            
            Joose.A.each(modifiersArr, function (modifier) {
                if (!Joose.A.exists(targetModifiersArr, modifier)) targetModifiersArr.push(modifier)
            })
            
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },

    
    deCompose : function () {
        this.each(function (modifiersArr, name) {
            var i = 0
            
            while (i < modifiersArr.length) 
                if (modifiersArr[i].definedIn != this) 
                    modifiersArr.splice(i, 1)
                else 
                    i++
        })
    },
    
    
    preApply : function (target) {
    },

    
    postUnApply : function (target) {
    },
    
    
    apply : function (target) {
        this.each(function (modifiersArr, name) {
            Joose.A.each(modifiersArr, function (modifier) {
                modifier.apply(target)
            })
        })
    },
    
    
    unapply : function (from) {
        this.each(function (modifiersArr, name) {
            for (var i = modifiersArr.length - 1; i >=0 ; i--) modifiersArr[i].unapply(from)
        })
    }
    
    
    
}).c;
Joose.Managed.PropertySet.Composition = new Joose.Proto.Class('Joose.Managed.PropertySet.Composition', {
    
    isa                         : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass           : Joose.Managed.PropertySet.Mutable,
    
    processOrder                : null,

    
    each : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.each(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
    },
    
    
    eachR : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.eachR(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
        
        
//        var props           = this.properties
//        var processOrder    = this.processOrder
//        
//        for(var i = processOrder.length - 1; i >= 0; i--) 
//            func.call(scope || this, props[ processOrder[i] ], processOrder[i])
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        this.each(function (property) {
            clone.addPropertyObject(property.clone())
        })
        
        return clone
    },
    
    
    alias : function (what) {
        this.each(function (property) {
            property.alias(what)
        })
    },
    
    
    exclude : function (what) {
        this.each(function (property) {
            property.exclude(what)
        })
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.flattenTo(subTarget)
        })
    },
    
    
    composeTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.composeTo(subTarget)
        })
    },
    
    
    
    deCompose : function () {
        this.eachR(function (property) {
            property.open()
        })
        
        Joose.Managed.PropertySet.Composition.superClass.deCompose.call(this)
    },
    
    
    reCompose : function () {
        Joose.Managed.PropertySet.Composition.superClass.reCompose.call(this)
        
        this.each(function (property) {
            property.close()
        })
    },
    
    
    unapply : function (from) {
        this.eachR(function (property) {
            property.unapply(from)
        })
    }
    
}).c
;
Joose.Managed.Stem = new Joose.Proto.Class('Joose.Managed.Stem', {
    
    isa                  : Joose.Managed.PropertySet.Composition,
    
    targetMeta           : null,
    
    attributesMC         : Joose.Managed.StemElement.Attributes,
    methodsMC            : Joose.Managed.StemElement.Methods,
    requirementsMC       : Joose.Managed.StemElement.Requirements,
    methodsModifiersMC   : Joose.Managed.StemElement.MethodModifiers,
    
    processOrder         : [ 'attributes', 'methods', 'requirements', 'methodsModifiers' ],
    
    
    initialize : function (props) {
        Joose.Managed.Stem.superClass.initialize.call(this, props)
        
        var targetMeta = this.targetMeta
        
        this.addProperty('attributes', {
            meta : this.attributesMC,
            
            //it can be no 'targetMeta' in clones
            properties : targetMeta ? targetMeta.attributes : {}
        })
        
        
        this.addProperty('methods', {
            meta : this.methodsMC,
            
            properties : targetMeta ? targetMeta.methods : {}
        })
        
        
        this.addProperty('requirements', {
            meta : this.requirementsMC
        })
        
        
        this.addProperty('methodsModifiers', {
            meta : this.methodsModifiersMC
        })
    },
    
    
    reCompose : function () {
        var c       = this.targetMeta.c
        
        this.preApply(c)
        
        Joose.Managed.Stem.superClass.reCompose.call(this)
        
        this.apply(c)
    },
    
    
    deCompose : function () {
        var c       = this.targetMeta.c
        
        this.unapply(c)
        
        Joose.Managed.Stem.superClass.deCompose.call(this)
        
        this.postUnApply(c)
    }
    
    
}).c
;
Joose.Managed.Builder = new Joose.Proto.Class('Joose.Managed.Builder', {
    
    targetMeta          : null,
    
    
    _buildStart : function (targetMeta, props) {
        targetMeta.stem.open()
        
        Joose.A.each([ 'trait', 'traits', 'removeTrait', 'removeTraits', 'does', 'doesnot', 'doesnt' ], function (builder) {
            if (props[builder]) {
                this[builder](targetMeta, props[builder])
                delete props[builder]
            }
        }, this)
    },
    
    
    _extend : function (props) {
        if (Joose.O.isEmpty(props)) return
        
        var targetMeta = this.targetMeta
        
        this._buildStart(targetMeta, props)
        
        Joose.O.eachOwn(props, function (value, name) {
            var handler = this[name]
            
            if (!handler) throw new Error("Unknown builder [" + name + "] was used during extending of [" + targetMeta.c + "]")
            
            handler.call(this, targetMeta, value)
        }, this)
        
        this._buildComplete(targetMeta, props)
    },
    

    _buildComplete : function (targetMeta, props) {
        targetMeta.stem.close()
    },
    
    
    methods : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addMethod(name, value)
        })
    },
    

    removeMethods : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethod(name)
        })
    },
    
    
    have : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addAttribute(name, value)
        })
    },
    
    
    havenot : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeAttribute(name)
        })
    },
    

    havent : function (targetMeta, info) {
        this.havenot(targetMeta, info)
    },
    
    
    after : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.After)
        })
    },
    
    
    before : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Before)
        })
    },
    
    
    override : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Override)
        })
    },
    
    
    around : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Around)
        })
    },
    
    
    augment : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Augment)
        })
    },
    
    
    removeModifier : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethodModifier(name)
        })
    },
    
    
    does : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.addRole(desc)
        })
    },
    

    doesnot : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.removeRole(desc)
        })
    },
    
    
    doesnt : function (targetMeta, info) {
        this.doesnot(targetMeta, info)
    },
    
    
    trait : function () {
        this.traits.apply(this, arguments)
    },
    
    
    traits : function (targetMeta, info) {
        if (targetMeta.firstPass) return
        
        if (!targetMeta.meta.isDetached) throw "Can't apply trait to not detached class"
        
        targetMeta.meta.extend({
            does : info
        })
    },
    
    
    removeTrait : function () {
        this.removeTraits.apply(this, arguments)
    },
     
    
    removeTraits : function (targetMeta, info) {
        if (!targetMeta.meta.isDetached) throw "Can't remove trait from not detached class"
        
        targetMeta.meta.extend({
            doesnot : info
        })
    },
    
    name : function (targetMeta, name) {
        targetMeta.name     = name
    }
    
}).c;
Joose.Managed.Class = new Joose.Proto.Class('Joose.Managed.Class', {
    
    isa                         : Joose.Proto.Class,
    
    stem                        : null,
    stemClass                   : Joose.Managed.Stem,
    stemClassCreated            : false,
    
    builder                     : null,
    builderClass                : Joose.Managed.Builder,
    builderClassCreated         : false,
    
    isDetached                  : false,
    firstPass                   : true,
    
    // a special instance, which, when passed as 1st argument to constructor, signifies that constructor should
    // skips traits processing for this instance
    skipTraitsAnchor            : {},
    
    
    //build for metaclasses - collects traits from roles
    BUILD : function () {
        var sup = Joose.Managed.Class.superClass.BUILD.apply(this, arguments)
        
        var props   = sup.__extend__
        
        var traits = Joose.O.wantArray(props.trait || props.traits || [])
        delete props.trait
        delete props.traits
        
        Joose.A.each(Joose.O.wantArray(props.does || []), function (arg) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            if (role.meta.meta.isDetached) traits.push(role.meta.constructor)
        })
        
        if (traits.length) props.traits = traits 
        
        return sup
    },
    
    
    initInstance : function (instance, props) {
        Joose.O.each(this.attributes, function (attribute, name) {
            
            if (attribute instanceof Joose.Managed.Attribute) 
                attribute.initFromConfig(instance, props)
            else 
                if (props.hasOwnProperty(name)) instance[name] = props[name]
        })
    },
    
    
    // we are using the same constructor for usual and meta- classes
    defaultConstructor: function () {
        return function (skipTraitsAnchor, params) {
            
            var thisMeta    = this.meta
            var skipTraits  = skipTraitsAnchor == thisMeta.skipTraitsAnchor
            
            var BUILD       = this.BUILD
            
            var props       = BUILD && BUILD.apply(this, skipTraits ? params : arguments) || (skipTraits ? params[0] : skipTraitsAnchor) || {}
            
            
            // either looking for traits in __extend__ (meta-class) or in usual props (usual class)
            var extend  = props.__extend__ || props
            
            var traits = extend.trait || extend.traits
            
            if (traits || extend.detached) {
                delete extend.trait
                delete extend.traits
                delete extend.detached
                
                if (!skipTraits) {
                    var classWithTrait  = thisMeta.subClass({ does : traits || [] }, thisMeta.name)
                    var meta            = classWithTrait.meta
                    meta.isDetached     = true
                    
                    return meta.instantiate(thisMeta.skipTraitsAnchor, arguments)
                }
            }
            
            thisMeta.initInstance(this, props)
            
            return thisMeta.hasMethod('initialize') && this.initialize(props) || this
        }
    },
    
    
    finalize: function (extend) {
        Joose.Managed.Class.superClass.finalize.call(this, extend)
        
        this.stem.close()
        
        this.afterMutate()
    },
    
    
    processStem : function () {
        Joose.Managed.Class.superClass.processStem.call(this)
        
        this.builder    = new this.builderClass({ targetMeta : this })
        this.stem       = new this.stemClass({ name : this.name, targetMeta : this })
        
        var builderClass = this.getClassInAttribute('builderClass')
        
        if (builderClass) {
            this.builderClassCreated = true
            this.addAttribute('builderClass', this.subClassOf(builderClass))
        }
        
        
        var stemClass = this.getClassInAttribute('stemClass')
        
        if (stemClass) {
            this.stemClassCreated = true
            this.addAttribute('stemClass', this.subClassOf(stemClass))
        }
    },
    
    
    extend : function (props) {
        if (props.builder) {
            this.getBuilderTarget().meta.extend(props.builder)
            delete props.builder
        }
        
        if (props.stem) {
            this.getStemTarget().meta.extend(props.stem)
            delete props.stem
        }
        
        this.builder._extend(props)
        
        this.firstPass = false
        
        if (!this.stem.opened) this.afterMutate()
    },
    
    
    getBuilderTarget : function () {
        var builderClass = this.getClassInAttribute('builderClass')
        if (!builderClass) throw "Attempt to extend a builder on non-meta class"
        
        return builderClass
    },
    

    getStemTarget : function () {
        var stemClass = this.getClassInAttribute('stemClass')
        if (!stemClass) throw "Attempt to extend a stem on non-meta class"
        
        return stemClass
    },
    
    
    getClassInAttribute : function (attributeName) {
        var attrClass = this.getAttribute(attributeName)
        if (attrClass instanceof Joose.Managed.Property.Attribute) attrClass = attrClass.value
        
        return attrClass
    },
    
    
    addMethodModifier: function (name, func, type) {
        var props = {}
        
        props.init = func
        props.meta = type
        
        return this.stem.properties.methodsModifiers.addProperty(name, props)
    },
    
    
    removeMethodModifier: function (name) {
        return this.stem.properties.methodsModifiers.removeProperty(name)
    },
    
    
    addMethod: function (name, func, props) {
        props = props || {}
        props.init = func
        
        return this.stem.properties.methods.addProperty(name, props)
    },
    
    
    addAttribute: function (name, init, props) {
        props = props || {}
        props.init = init
        
        return this.stem.properties.attributes.addProperty(name, props)
    },
    
    
    removeMethod : function (name) {
        return this.stem.properties.methods.removeProperty(name)
    },

    
    removeAttribute: function (name) {
        return this.stem.properties.attributes.removeProperty(name)
    },
    
    
    hasMethod: function (name) {
        return this.stem.properties.methods.haveProperty(name)
    },
    
    
    hasAttribute: function (name) { 
        return this.stem.properties.attributes.haveProperty(name)
    },
    
    
    hasMethodModifiersFor : function (name) {
        return this.stem.properties.methodsModifiers.haveProperty(name)
    },
    
    
    hasOwnMethod: function (name) {
        return this.stem.properties.methods.haveOwnProperty(name)
    },
    
    
    hasOwnAttribute: function (name) { 
        return this.stem.properties.attributes.haveOwnProperty(name)
    },
    

    getMethod : function (name) {
        return this.stem.properties.methods.getProperty(name)
    },
    
    
    getAttribute : function (name) {
        return this.stem.properties.attributes.getProperty(name)
    },
    
    
    eachRole : function (roles, func, scope) {
        Joose.A.each(roles, function (arg, index) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            func.call(scope || this, arg, role, index)
        }, this)
    },
    
    
    addRole : function () {
        
        this.eachRole(arguments, function (arg, role) {
            
            this.beforeRoleAdd(role)
            
            var desc = arg
            
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference should be stored
            //into 'propertySet' field
            if (role != arg) {
                desc.propertySet = role.meta.stem
                delete desc.role
            } else
                desc = desc.meta.stem
            
            this.stem.addComposeInfo(desc)
            
        }, this)
    },
    
    
    beforeRoleAdd : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            does : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            does : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.traits(this, roleMeta.constructor)
    },
    
    
    beforeRoleRemove : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            doesnt : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            doesnt : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.removeTraits(this, roleMeta.constructor)
    },
    
    
    removeRole : function () {
        this.eachRole(arguments, function (arg, role) {
            this.beforeRoleRemove(role)
            
            this.stem.removeComposeInfo(role.meta.stem)
        }, this)
    },
    
    
    getRoles : function () {
        
        return Joose.A.map(this.stem.composedFrom, function (composeDesc) {
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference is stored
            //into 'propertySet' field
            if (!(composeDesc instanceof Joose.Managed.PropertySet)) return composeDesc.propertySet
            
            return composeDesc.targetMeta.c
        })
    },
    
    
    does : function (role) {
        var myRoles = this.getRoles()
        
        for (var i = 0; i < myRoles.length; i++) if (role == myRoles[i]) return true
        for (var i = 0; i < myRoles.length; i++) if (myRoles[i].meta.does(role)) return true
        
        var superMeta = this.superClass.meta
        
        // considering the case of inheriting from non-Joose classes
        if (this.superClass != Joose.Proto.Empty && superMeta && superMeta.meta && superMeta.meta.hasMethod('does')) return superMeta.does(role)
        
        return false
    },
    
    
    getMethods : function () {
        return this.stem.properties.methods
    },
    
    
    getAttributes : function () {
        return this.stem.properties.attributes
    },
    
    
    afterMutate : function () {
    },
    
    
    getCurrentMethod : function () {
        for (var wrapper = arguments.callee.caller, count = 0; wrapper && count < 5; wrapper = wrapper.caller, count++)
            if (wrapper.__METHOD__) return wrapper.__METHOD__
        
        return null
    }
    
    
}).c;
Joose.Managed.Role = new Joose.Managed.Class('Joose.Managed.Role', {
    
    isa                         : Joose.Managed.Class,
    
    have : {
        defaultSuperClass       : Joose.Proto.Empty,
        
        builderRole             : null,
        stemRole                : null
    },
    
    
    methods : {
        
        defaultConstructor : function () {
            return function () {
                throw new Error("Roles cant be instantiated")
            }
        },
        

        processSuperClass : function () {
            if (this.superClass != this.defaultSuperClass) throw new Error("Roles can't inherit from anything")
        },
        
        
        getBuilderTarget : function () {
            if (!this.builderRole) {
                this.builderRole = new this.constructor().c
                this.builderClassCreated = true
            }
            
            return this.builderRole
        },
        
    
        getStemTarget : function () {
            if (!this.stemRole) {
                this.stemRole = new this.constructor().c
                this.stemClassCreated = true
            }
            
            return this.stemRole
        },
        
    
        addRequirement : function (methodName) {
            this.stem.properties.requirements.addProperty(methodName, {})
        }
        
    },
    

    stem : {
        methods : {
            
            apply : function () {
            },
            
            
            unapply : function () {
            }
        }
    },
    
    
    builder : {
        methods : {
            requires : function (targetClassMeta, info) {
                Joose.A.each(Joose.O.wantArray(info), function (methodName) {
                    targetClassMeta.addRequirement(methodName)
                }, this)
            }
        }
    }
    
}).c;
Joose.Managed.Attribute = new Joose.Managed.Class('Joose.Managed.Attribute', {
    
    isa : Joose.Managed.Property.Attribute,
    
    have : {
        is              : null,
        
        builder         : null,
        
        isPrivate       : false,
        
        role            : null,
        
        publicName      : null,
        setterName      : null,
        getterName      : null,
        
        //indicates the logical readableness/writeableness of the attribute
        readable        : false,
        writeable       : false,
        
        //indicates the physical presense of the accessor (may be absent for "combined" accessors for example)
        hasGetter       : false,
        hasSetter       : false,
        
        required        : false,
        
        canInlineSetRaw : true,
        canInlineGetRaw : true
    },
    
    
    after : {
        initialize : function () {
            var name = this.name
            
            this.publicName = name.replace(/^_+/, '')
            
            this.slot = this.isPrivate ? '$' + name : name
            
            this.setterName = this.setterName || this.getSetterName()
            this.getterName = this.getterName || this.getGetterName()
            
            this.readable  = this.hasGetter = /^r/i.test(this.is)
            this.writeable = this.hasSetter = /^.w/i.test(this.is)
        }
    },
    
    
    override : {
        
        computeValue : function () {
            var init    = this.init
            
            if (Joose.O.isClass(init) || !Joose.O.isFunction(init)) this.SUPER()
        },
        
        
        preApply : function (targetClass) {
            targetClass.meta.extend({
                methods : this.getAccessorsFor(targetClass)
            })
        },
        
        
        postUnApply : function (from) {
            from.meta.extend({
                removeMethods : this.getAccessorsFrom(from)
            })
        }
        
    },
    
    
    methods : {
        
        getAccessorsFor : function (targetClass) {
            var targetMeta = targetClass.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var methods = {}
            
            if (this.hasSetter && !targetMeta.hasMethod(setterName)) {
                methods[setterName] = this.getSetter()
                methods[setterName].ACCESSOR_FROM = this
            }
            
            if (this.hasGetter && !targetMeta.hasMethod(getterName)) {
                methods[getterName] = this.getGetter()
                methods[getterName].ACCESSOR_FROM = this
            }
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var targetMeta = from.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var setter = this.hasSetter && targetMeta.getMethod(setterName)
            var getter = this.hasGetter && targetMeta.getMethod(getterName)
            
            var removeMethods = []
            
            if (setter && setter.value.ACCESSOR_FROM == this) removeMethods.push(setterName)
            if (getter && getter.value.ACCESSOR_FROM == this) removeMethods.push(getterName)
            
            return removeMethods
        },
        
        
        getGetterName : function () {
            return 'get' + Joose.S.uppercaseFirst(this.publicName)
        },


        getSetterName : function () {
            return 'set' + Joose.S.uppercaseFirst(this.publicName)
        },
        
        
        getSetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineSetRaw)
                return function (value) {
                    this[ slot ] = value
                    
                    return this
                }
            else
                return function () {
                    return me.setRawValueTo.apply(this, arguments)
                }
        },
        
        
        getGetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineGetRaw)
                return function (value) {
                    return this[ slot ]
                }
            else
                return function () {
                    return me.getRawValueFrom.apply(this, arguments)
                }
        },
        
        
        getValueFrom : function (instance) {
            var getterName      = this.getterName
            
            if (this.readable && instance.meta.hasMethod(getterName)) return instance[ getterName ]()
            
            return this.getRawValueFrom(instance)
        },
        
        
        setValueTo : function (instance, value) {
            var setterName      = this.setterName
            
            if (this.writeable && instance.meta.hasMethod(setterName)) 
                instance[ setterName ](value)
            else
                this.setRawValueTo(instance, value)
        },
        
        
        initFromConfig : function (instance, config) {
            var name            = this.name
            
            var value, isSet = false
            
            if (config.hasOwnProperty(name)) {
                value = config[name]
                isSet = true
            } else {
                var init    = this.init
                
                // simple function (not class) has been used as "init" value
                if (Joose.O.isFunction(init) && !Joose.O.isClass(init)) {
                    
                    value = init.call(instance, config, name)
                    
                    isSet = true
                    
                } else if (this.builder) {
                    
                    value = instance[ this.builder.replace(/^this\./, '') ](config, name)
                    isSet = true
                }
            }
            
            if (isSet)
                this.setRawValueTo(instance, value)
            else 
                if (this.required) throw new Error("Required attribute [" + name + "] is missed during initialization of " + instance)
        }
    }

}).c
;
Joose.Managed.Attribute.Builder = new Joose.Managed.Role('Joose.Managed.Attribute.Builder', {
    
    
    have : {
        defaultAttributeClass : Joose.Managed.Attribute
    },
    
    builder : {
        
        methods : {
            
            has : function (targetClassMeta, info) {
                Joose.O.eachOwn(info, function (props, name) {
                    if (typeof props != 'object' || props == null || props.constructor == / /.constructor) props = { init : props }
                    
                    props.meta = props.meta || targetClassMeta.defaultAttributeClass
                    
                    if (/^__/.test(name)) {
                        name = name.replace(/^_+/, '')
                        
                        props.isPrivate = true
                    }
                    
                    targetClassMeta.addAttribute(name, props.init, props)
                }, this)
            },
            
            
            hasnot : function (targetClassMeta, info) {
                this.havenot(targetClassMeta, info)
            },
            
            
            hasnt : function (targetClassMeta, info) {
                this.hasnot(targetClassMeta, info)
            }
        }
            
    }
    
}).c
;
Joose.Managed.My = new Joose.Managed.Role('Joose.Managed.My', {
    
    have : {
        myClass                         : null,
        
        needToReAlias                   : false
    },
    
    
    methods : {
        createMy : function (extend) {
            var thisMeta        = this.meta
            var isRole          = this instanceof Joose.Managed.Role
            
            var myExtend        = extend.my || {}
            delete extend.my
            
            // Symbiont will generally have the same meta class as its hoster, excepting the cases, when the superclass also have the symbiont. 
            // In such cases, the meta class for symbiont will be inherited (unless explicitly specified)
            var superClassMy    = this.superClass.meta.myClass
            
            if (!isRole && !myExtend.isa && superClassMy) myExtend.isa = superClassMy
            

            if (!myExtend.meta && !myExtend.isa) myExtend.meta = this.constructor
            
            myExtend.name       = this.name + '.my'
            
            var createdClass    = this.myClass = Class(myExtend)
            
            var c               = this.c
            
            c.prototype.my      = c.my = isRole ? createdClass : new createdClass({ HOST : c })
            
            this.needToReAlias = true
        },
        
        
        aliasStaticMethods : function () {
            this.needToReAlias = false
            
            var c           = this.c
            var myProto     = this.myClass.prototype
            
            Joose.O.eachOwn(c, function (property, name) {
                if (property.IS_ALIAS) delete c[ name ] 
            })
            
            this.myClass.meta.stem.properties.methods.each(function (method, name) {
                
                if (!c[ name ])
                    (c[ name ] = function () {
                        return myProto[ name ].apply(c.my, arguments)
                    }).IS_ALIAS = true
            })
        }
    },
    
    
    override : {
        
        extend : function (props) {
            var myClass = this.myClass
            
            if (!myClass && this.superClass.meta.myClass) this.createMy(props)
            
            if (props.my) {
                if (!myClass) 
                    this.createMy(props)
                else {
                    this.needToReAlias = true
                    
                    myClass.meta.extend(props.my)
                    delete props.my
                }
            }
            
            this.SUPER(props)
            
            if (this.needToReAlias && !(this instanceof Joose.Managed.Role)) this.aliasStaticMethods()
        }  
    },
    
    
    before : {
        
        addRole : function () {
            var myStem
            
            Joose.A.each(arguments, function (arg) {
                
                if (!arg) throw new Error("Attempt to consume an undefined Role into [" + this.name + "]")
                
                //instanceof Class to allow treat classes as roles
                var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
                
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    
                    if (!this.myClass) {
                        this.createMy({
                            my : {
                                does : role.meta.myClass
                            }
                        })
                        return
                    }
                    
                    myStem = this.myClass.meta.stem
                    if (!myStem.opened) myStem.open()
                    
                    myStem.addComposeInfo(role.my.meta.stem)
                }
            }, this)
            
            if (myStem) {
                myStem.close()
                
                this.needToReAlias = true
            }
        },
        
        
        removeRole : function () {
            if (!this.myClass) return
            
            var myStem = this.myClass.meta.stem
            myStem.open()
            
            Joose.A.each(arguments, function (role) {
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    myStem.removeComposeInfo(role.my.meta.stem)
                    
                    this.needToReAlias = true
                }
            }, this)
            
            myStem.close()
        }
        
    }
    
}).c;
Joose.Namespace = Joose.stub()

Joose.Namespace.Able = new Joose.Managed.Role('Joose.Namespace.Able', {

    have : {
        bodyFunc                : null
    },
    
    
    before : {
        extend : function (extend) {
            if (extend.body) {
                this.bodyFunc = extend.body
                delete extend.body
            }
        }
    },
    
    
    after: {
        
        afterMutate : function () {
            var bodyFunc = this.bodyFunc
            delete this.bodyFunc
            
            if (bodyFunc) Joose.Namespace.Manager.my.executeIn(this.c, bodyFunc)
        }
    }
    
}).c;
Joose.Managed.Bootstrap = new Joose.Managed.Role('Joose.Managed.Bootstrap', {
    
    does   : [ Joose.Namespace.Able, Joose.Managed.My, Joose.Managed.Attribute.Builder ]
    
}).c
;
Joose.Meta = Joose.stub()


Joose.Meta.Object = new Joose.Proto.Class('Joose.Meta.Object', {
    
    isa             : Joose.Proto.Object
    
}).c


;
Joose.Meta.Class = new Joose.Managed.Class('Joose.Meta.Class', {
    
    isa                         : Joose.Managed.Class,
    
    does                        : Joose.Managed.Bootstrap,
    
    have : {
        defaultSuperClass       : Joose.Meta.Object
    }
    
}).c

;
Joose.Meta.Role = new Joose.Meta.Class('Joose.Meta.Role', {
    
    isa                         : Joose.Managed.Role,
    
    does                        : Joose.Managed.Bootstrap
    
}).c;
Joose.Namespace.Keeper = new Joose.Meta.Class('Joose.Namespace.Keeper', {
    
    isa         : Joose.Meta.Class,
    
    have        : {
        externalConstructor             : null
    },
    
    
    methods: {
        
        defaultConstructor: function () {
            
            return function () {
                //constructors should assume that meta is attached to 'arguments.callee' (not to 'this') 
                var thisMeta = arguments.callee.meta
                
                if (thisMeta instanceof Joose.Namespace.Keeper) throw new Error("Module [" + thisMeta.c + "] may not be instantiated. Forgot to 'use' the class with the same name?")
                
                var externalConstructor = thisMeta.externalConstructor
                
                if (typeof externalConstructor == 'function') {
                    
                    externalConstructor.meta = thisMeta
                    
                    return externalConstructor.apply(this, arguments)
                }
                
                throw "NamespaceKeeper of [" + thisMeta.name + "] was planted incorrectly."
            }
        },
        
        
        //withClass should be not constructed yet on this stage (see Joose.Proto.Class.construct)
        //it should be on the 'constructorOnly' life stage (should already have constructor)
        plant: function (withClass) {
            var keeper = this.c
            
            keeper.meta = withClass.meta
            
            keeper.meta.c = keeper
            keeper.meta.externalConstructor = withClass
        }
    }
    
}).c


;
Joose.Namespace.Manager = new Joose.Managed.Class('Joose.Namespace.Manager', {
    
    have : {
        current     : null
    },
    
    
    methods : {
        
        initialize : function () {
            this.current    = [ Joose.top ]
        },
        
        
        getCurrent: function () {
            return this.current[0]
        },
        
        
        executeIn : function (ns, func) {
            var current = this.current
            
            current.unshift(ns)
            var res = func.call(ns, ns)
            current.shift()
            
            return res
        },
        
        
        earlyCreate : function (name, metaClass, props) {
            props.constructorOnly = true
            
            return new metaClass(name, props).c
        },
        
        
        //this function establishing the full "namespace chain" (including the last element)
        create : function (nsName, metaClass, extend) {
            
            //if no name provided, then we creating an anonymous class, so just skip all the namespace manipulations
            if (!nsName) return new metaClass(nsName, extend).c
            
            var me = this
            
            if (/^\./.test(nsName)) return this.executeIn(Joose.top, function () {
                return me.create(nsName.replace(/^\./, ''), metaClass, extend)
            })
            
            var props   = extend || {}
            
            var parts   = Joose.S.saneSplit(nsName, '.')
            var object  = this.getCurrent()
            var soFar   = object == Joose.top ? [] : Joose.S.saneSplit(object.meta.name, '.')
            
            for (var i = 0; i < parts.length; i++) {
                var part        = parts[i]
                var isLast      = i == parts.length - 1
                
                if (part == "meta" || part == "my" || !part) throw "Module name [" + nsName + "] may not include a part called 'meta' or 'my' or empty part."
                
                var cur =   object[part]
                
                soFar.push(part)
                
                var soFarName       = soFar.join(".")
                var needFinalize    = false
                var nsKeeper
                
                // if the namespace segment is empty
                if (typeof cur == "undefined") {
                    if (isLast) {
                        // perform "early create" which just fills the namespace segment with right constructor
                        // this allows us to have a right constructor in the namespace segment when the `body` will be called
                        nsKeeper        = this.earlyCreate(soFarName, metaClass, props)
                        needFinalize    = true
                    } else
                        nsKeeper        = new Joose.Namespace.Keeper(soFarName).c
                    
                    object[part] = nsKeeper
                    
                    cur = nsKeeper
                    
                } else if (isLast && cur && cur.meta) {
                    
                    var currentMeta = cur.meta
                    
                    if (metaClass == Joose.Namespace.Keeper)
                        //`Module` over something case - extend the original
                        currentMeta.extend(props)
                    else {
                        
                        if (currentMeta instanceof Joose.Namespace.Keeper) {
                            
                            currentMeta.plant(this.earlyCreate(soFarName, metaClass, props))
                            
                            needFinalize = true
                        } else
                            throw new Error("Double declaration of [" + soFarName + "]")
                    }
                    
                } else 
                    if (isLast && !(cur && cur.meta && cur.meta.meta)) throw "Trying to setup module " + soFarName + " failed. There is already something: " + cur

                // hook to allow embedd resource into meta
                if (isLast) this.prepareMeta(cur.meta)
                    
                if (needFinalize) cur.meta.construct(props)
                    
                object = cur
            }
            
            return object
        },
        
        
        prepareMeta : function () {
        },
        
        
        prepareProperties : function (name, props, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                props   = name
                name    = null
            }
            
            var meta
            
            if (props && props.meta) {
                meta = props.meta
                delete props.meta
            }
            
            if (!meta)
                if (props && typeof props.isa == 'function' && props.isa.meta)
                    meta = props.isa.meta.constructor
                else
                    meta = defaultMeta
            
            return callback.call(this, name, meta, props)
        },
        
        
        getDefaultHelperFor : function (metaClass) {
            var me = this
            
            return function (name, props) {
                return me.prepareProperties(name, props, metaClass, function (name, meta, props) {
                    return me.create(name, meta, props)
                })
            }
        },
        
        
        register : function (helperName, metaClass, func) {
            var me = this
            
            if (this.meta.hasMethod(helperName)) {
                
                var helper = function () {
                    return me[ helperName ].apply(me, arguments)
                }
                
                if (!Joose.top[ helperName ])   Joose.top[ helperName ]         = helper
                if (!Joose[ helperName ])       Joose[ helperName ]             = helper
                
                if (Joose.is_NodeJS && typeof exports != 'undefined')            exports[ helperName ]    = helper
                
            } else {
                var methods = {}
                
                methods[ helperName ] = func || this.getDefaultHelperFor(metaClass)
                
                this.meta.extend({
                    methods : methods
                })
                
                this.register(helperName)
            }
        },
        
        
        Module : function (name, props) {
            return this.prepareProperties(name, props, Joose.Namespace.Keeper, function (name, meta, props) {
                if (typeof props == 'function') props = { body : props }    
                
                return this.create(name, meta, props)
            })
        }
    }
    
}).c

Joose.Namespace.Manager.my = new Joose.Namespace.Manager()

Joose.Namespace.Manager.my.register('Class', Joose.Meta.Class)
Joose.Namespace.Manager.my.register('Role', Joose.Meta.Role)
Joose.Namespace.Manager.my.register('Module')


// for the rest of the package
var Class       = Joose.Class
var Role        = Joose.Role
;
Role('Joose.Attribute.Delegate', {
    
    have : {
        handles : null
    },
    
    
    override : {
        
        eachDelegate : function (handles, func, scope) {
            if (typeof handles == 'string') return func.call(scope, handles, handles)
            
            if (handles instanceof Array)
                return Joose.A.each(handles, function (delegateTo) {
                    
                    func.call(scope, delegateTo, delegateTo)
                })
                
            if (handles === Object(handles))
                Joose.O.eachOwn(handles, function (delegateTo, handleAs) {
                    
                    func.call(scope, handleAs, delegateTo)
                })
        },
        
        
        getAccessorsFor : function (targetClass) {
            var targetMeta  = targetClass.meta
            var methods     = this.SUPER(targetClass)
            
            var me      = this
            
            this.eachDelegate(this.handles, function (handleAs, delegateTo) {
                
                if (!targetMeta.hasMethod(handleAs)) {
                    var handler = methods[ handleAs ] = function () {
                        var attrValue = me.getValueFrom(this)
                        
                        return attrValue[ delegateTo ].apply(attrValue, arguments)
                    }
                    
                    handler.ACCESSOR_FROM = me
                }
            })
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var methods = this.SUPER(from)
            
            var me          = this
            var targetMeta  = from.meta
            
            this.eachDelegate(this.handles, function (handleAs) {
                
                var handler = targetMeta.getMethod(handleAs)
                
                if (handler && handler.value.ACCESSOR_FROM == me) methods.push(handleAs)
            })
            
            return methods
        }
    }
})

;
Role('Joose.Attribute.Trigger', {
    
    have : {
        trigger        : null
    }, 

    
    after : {
        initialize : function() {
            if (this.trigger) {
                if (!this.writeable) throw new Error("Can't use `trigger` for read-only attributes")
                
                this.hasSetter = true
            }
        }
    },
    
    
    override : {
        
        getSetter : function() {
            var original    = this.SUPER()
            var trigger     = this.trigger
            
            if (!trigger) return original
            
            var me      = this
            var init    = Joose.O.isFunction(me.init) ? null : me.init
            
            return function () {
                var oldValue    = me.hasValue(this) ? me.getValueFrom(this) : init
                
                var res         = original.apply(this, arguments)
                
                trigger.call(this, me.getValueFrom(this), oldValue)
                
                return res
            }
        }
    }
})    

;
Role('Joose.Attribute.Lazy', {
    
    
    have : {
        lazy        : null
    }, 
    
    
    before : {
        computeValue : function () {
            if (typeof this.init == 'function' && this.lazy) {
                this.lazy = this.init    
                delete this.init    
            }
        }
    },
    
    
    after : {
        initialize : function () {
            if (this.lazy) this.readable = this.hasGetter = true
        }
    },
    
    
    override : {
        
        getGetter : function () {
            var original    = this.SUPER()
            var lazy        = this.lazy
            
            if (!lazy) return original
            
            var me      = this    
            
            return function () {
                if (!me.hasValue(this)) {
                    var initializer = typeof lazy == 'function' ? lazy : this[ lazy.replace(/^this\./, '') ]
                    
                    me.setValueTo(this, initializer.apply(this, arguments))
                }
                
                return original.call(this)    
            }
        }
    }
})

;
Role('Joose.Attribute.Accessor.Combined', {
    
    
    have : {
        isCombined        : false
    }, 
    
    
    after : {
        initialize : function() {
            this.isCombined = this.isCombined || /..c/i.test(this.is)
            
            if (this.isCombined) {
                this.slot = '$$' + this.name
                
                this.hasGetter = true
                this.hasSetter = false
                
                this.setterName = this.getterName = this.publicName
            }
        }
    },
    
    
    override : {
        
        getGetter : function() {
            var getter    = this.SUPER()
            
            if (!this.isCombined) return getter
            
            var setter    = this.getSetter()
            
            var me = this
            
            return function () {
                
                if (!arguments.length) {
                    if (me.readable) return getter.call(this)
                    throw new Error("Call to getter of unreadable attribute: [" + me.name + "]")
                }
                
                if (me.writeable) return setter.apply(this, arguments)
                
                throw new Error("Call to setter of read-only attribute: [" + me.name + "]")    
            }
        }
    }
    
})

;
Joose.Managed.Attribute.meta.extend({
    does : [ Joose.Attribute.Delegate, Joose.Attribute.Trigger, Joose.Attribute.Lazy, Joose.Attribute.Accessor.Combined ]
})            

;
Role('Joose.Meta.Singleton', {
    
    has : {
        forceInstance           : Joose.I.Object,
        instance                : null
    },
    
    
    
    override : {
        
        defaultConstructor : function () {
            var meta        = this
            var previous    = this.SUPER()
            
            this.adaptConstructor(previous)
            
            return function (forceInstance, params) {
                if (forceInstance == meta.forceInstance) return previous.apply(this, params) || this
                
                var instance = meta.instance
                
                if (instance) {
                    if (meta.hasMethod('configure')) instance.configure.apply(instance, arguments)
                } else
                    meta.instance = new meta.c(meta.forceInstance, arguments)
                    
                return meta.instance
            }
        }        
    }
    

})


Joose.Namespace.Manager.my.register('Singleton', Class({
    isa     : Joose.Meta.Class,
    meta    : Joose.Meta.Class,
    
    does    : Joose.Meta.Singleton
}))
;
;
}();;
;
Class('Scope.Provider', {
    
    /*PKGVERSION*/VERSION : 0.12,
    
    has     : {
        scope               : null,
        
        seedingCode         : null,
        seedingScript       : null,
        
        preload             : {
            is      : 'ro',
            init    : Joose.I.Array
        },
        
        cleanupCallback         : null,
        beforeCleanupCallback   : null
    },
    
        
    methods : {
        
        isCSS : function (url) {
            return /\.css(\?.*)?$/i.test(url)
        },
        
        
        isAlreadySetUp : function () {
            return Boolean(this.scope)
        },
        
        
        addPreload : function (preloadDesc) {
            if (this.isAlreadySetUp()) throw new Error("Can't use `addPreload` - scope is already setup. Use `runCode/runScript` instead")
            
            if (typeof preloadDesc == 'string')
                
                if (this.isCSS(preloadDesc)) 
                    preloadDesc = {
                        type        : 'css',
                        url         : preloadDesc
                    }
                else
                    preloadDesc = {
                        type        : 'js',
                        url         : preloadDesc
                    }
            else
            
                if (preloadDesc.text) 
                    preloadDesc = {
                        type        : 'js',
                        content     : preloadDesc.text
                    }
                    
            if (!preloadDesc.type) throw new Error("Preload descriptor must have the `type` property")
                
            this.preload.push(preloadDesc)
        },
        
        
        addOnErrorHandler : function (handler, callback) {
            throw "Abstract method `addOnErrorHandler` of Scope.Provider called"
        },
        
        
        create : function () {
            throw "Abstract method `create` of Scope.Provider called"
        },
        
        
        setup : function (callback) {
            throw "Abstract method `setup` of Scope.Provider called"
        },
        
        
        cleanup : function (callback) {
            throw "Abstract method `cleanup` of Scope.Provider called"
        },
        
        
        runCode : function (text, callback) {
            throw "Abstract method `runCode` of Scope.Provider called"
        },
        
        
        runScript : function (url, callback) {
            throw "Abstract method `runScript` of Scope.Provider called"
        }
    }
})


Scope.Provider.__ONLOAD__   = {}
Scope.Provider.__ONERROR__  = {};
Role('Scope.Provider.Role.WithDOM', {
    
    requires    : [ 'getDocument', 'create', 'getPreload', 'isAlreadySetUp' ],
    
    has : {
        useStrictMode   : true,
        sourceURL       : null,
        
        minViewportSize : null,
        
        parentWindow    : function () { return window },
        scopeId         : function () { return Math.round(Math.random() * 1e10) },
        
        //                init function
        attachToOnError : function () {
            
            // returns the value of the attribute
            return function (window, scopeId, handler, preventDefault) {
                
                var prevHandler         = window.onerror
                if (prevHandler && prevHandler.__SP_MANAGED__) return
                
                window.onerror = function (message, url, lineNumber) {
                    // prevent recursive calls if other authors politely did not overwrite the handler and will call it
                    if (handler.__CALLING__) return
                    
                    handler.__CALLING__ = true
                    
                    prevHandler && prevHandler.apply(this, arguments)
                
                    handler.apply(this, arguments)
                    
                    handler.__CALLING__ = false
                    
                    // in FF/IE need to return `true` to prevent default action
                    if (preventDefault !== false) return window.WebKitPoint ? false : true 
                }
                
                window.onerror.__SP_MANAGED__ = true
            } 
        },
        
        // this is a "cached" onerror handler - a handler which was provided before the scope
        // has started the creation process - should be installed ASAP in the creation process
        // to allow catching of the exceptions in the scope with `sourceURL` 
        cachedOnError   : null
    },
    
    
    override : {
        
        cleanup : function () {
            this.scope.onerror  = null
            
            this.SUPERARG(arguments)
            
            this.scope          = null
        }
    },
    
    
    methods : {
        
        cleanupHanlders : function () {
            var scopeProvider   = this.parentWindow.Scope.Provider
            
            delete scopeProvider.__ONLOAD__[ this.scopeId ]
            delete scopeProvider.__ONERROR__[ this.scopeId ]
        },
        
        
        getHead : function () {
            return this.getDocument().getElementsByTagName('head')[ 0 ]
        },
        
        
        installOnErrorHandler : function (handler) {
            if (!this.isAlreadySetUp()) throw "Scope should be already set up"
            
            this.attachToOnError(this.scope, this.scopeId, handler)
        },
        
        
        addOnErrorHandler : function (handler, preventDefault) {
            handler.__SP_MANAGED__  = true
            
            if (this.cachedOnError && this.cachedOnError != handler) throw "Can only install one on error handler" 
            this.cachedOnError      = handler
            
            var scopeId     = this.scopeId
            
            this.parentWindow.Scope.Provider.__ONERROR__[ scopeId ] = handler
            
            var attachToOnError = ';(' + this.attachToOnError.toString() + ')(window, ' + scopeId + ', (window.opener || window.parent).Scope.Provider.__ONERROR__[ ' + scopeId + ' ], ' + preventDefault + ');'
            
            if (this.isAlreadySetUp()) 
                this.runCode(attachToOnError)
            else {
                // this is a fallback - run the "attachToOnError" from inside of scope
                this.getPreload().unshift({
                    type        : 'js',
                    content     : attachToOnError,
                    unordered   : true
                })
            }
        },
        
        
        addSeedingToPreload : function () {
            var preload             = this.getPreload()
                
            if (this.seedingCode) preload.unshift({
                type        : 'js',
                content     : this.seedingCode
            })
            
            if (this.seedingScript) preload.push({
                type        : 'js',
                url         : this.seedingScript
            })
        },
        
        
        setup : function (callback) {
            var isIE                = 'v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)
//            var isOpera             = Object.prototype.toString.call(this.parentWindow.opera) == '[object Opera]'
            var hasInlineScript     = false
            
            Joose.A.each(this.getPreload(), function (preloadDesc) {
                // IE will execute the inline scripts ASAP, this might be not what we want (inline script might be need executed only after some url script)
                // its however ok in some cases (like adding `onerror` handler
                // such inline scripts should be marked with `unordered` - true
                if (preloadDesc.type == 'js' && preloadDesc.content && !preloadDesc.unordered) {
                    hasInlineScript = true
                    
                    return false
                } 
            })
            
            if (this.sourceURL || isIE && hasInlineScript) {
                this.addSeedingToPreload()
                
                this.setupIncrementally(callback)
                
            } else {
                // for sane browsers just add the seeding code and seeding script to preloads
                if (!isIE) this.addSeedingToPreload()
                
                // seeding scripts are included only for sane browsers (not IE)
                this.setupWithDocWrite(callback, isIE)
            }
        },
        
        
        setupWithDocWrite : function (callback, needToSeed) {
            var html        = []
            var me          = this
            
            Joose.A.each(this.getPreload(), function (preloadDesc) {
                
                if (preloadDesc.type == 'js') 
                    html.push(me.getScriptTagString(preloadDesc.url, preloadDesc.content))
                    
                else if (preloadDesc.type == 'css') 
                    html.push(me.getLinkTagString(preloadDesc.url, preloadDesc.content))
                
                else throw "Incorrect preload descriptor " + preloadDesc
            })
            
            // no need to wait for DOM ready - we'll overwrite it anyway
            this.create()
            
            var scopeId              = this.scopeId
            
            this.parentWindow.Scope.Provider.__ONLOAD__[ scopeId ]    = function () {

                var cont = function () { callback && callback(me) }
                
                // sane browsers - seeding code and script has been already added
                if (!needToSeed) { cont(); return }
                
                // our beloved IE - manually seeding the scope
                
                if (me.seedingCode) me.runCode(me.seedingCode)
                
                if (me.seedingScript) 
                    me.runScript(me.seedingScript, cont)
                else
                    cont()
            }
            
            var doc             = this.getDocument()
            
            doc.open()
            
            doc.write([
                this.useStrictMode ? '<!DOCTYPE html>' : '',
                '<html style="width: 100%; height: 100%; margin : 0; padding : 0;">',
                    '<head>',
                        html.join(''),
                    '</head>',
    
                    '<body style="margin : 0; padding : 0; width: 100%; height: 100%" onload="(window.opener || window.parent).Scope.Provider.__ONLOAD__[' + scopeId + ']()">',
                    '</body>',
                '</html>'
            ].join(''))
            
            doc.close()
            
            // Chrome (Webkit?) will clear the `onerror` after "doc.open()/.close()" so need to re-install it
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },
        
        
        setupIncrementally : function (callback) {
            var me      = this
            
            // here the "onerror" should be included early in the "preloads" 
            this.create(function () {
                
                var loadScripts     = function (preloads, callback) {
                    
                    var cont = function () { loadScripts(preloads, callback) }
                    
                    if (!preloads.length) 
                        callback && callback()
                    else {
                        var preloadDesc     = preloads.shift()
                        
                        if (preloadDesc.url) 
                            me.runScript(preloadDesc.url, cont)
                        else 
                            if (preloadDesc.type == 'js')
                                me.runCode(preloadDesc.content, cont)
                            else {
                                me.addStyleTag(preloadDesc.content)
                                
                                cont()
                            }
                    }
                }
                
                loadScripts(me.getPreload().slice(), callback)
            })
        },        
        
        
        getScriptTagString : function (url, text) {
            var res = '<script type="text/javascript"'
            
            if (url) 
                res     += ' src="' + url + '"></script>'
            else
                res     += '>' + text.replace(/<\/script>/gi, '\\x3C/script>') + '</script>'
                
            return res
        },
        
        
        getLinkTagString : function (url, text) {
            if (url) return '<link href="' + url + '" rel="stylesheet" type="text/css" />'
            
            if (text) return '<style>' + text + '</style>'
        },
        
        

        loadCSS : function (url, callback) {
            var doc         = this.getDocument()
            var link        = doc.createElement('link')
            
            link.type       = 'text/css'
            link.rel        = 'stylesheet'
            link.href       = url
        
            this.getHead().appendChild(link)
            
            var hasContinued    = false
            
            var cont            = function () {
                // just in case some crazy JS engine calls `onerror` even after node removal
                if (hasContinued) return
                hasContinued    = true
                clearTimeout(forcedTimeout)
                
                if (callback) callback()
                
                doc.body.removeChild(img)
            }
            
            var forcedTimeout   = setTimeout(cont, 3000)
        
            var img             = doc.createElement('img')
            
            img.onerror         = cont
        
            doc.body.appendChild(img)
            
            img.src             = url
        },
        
        
        runCode : function (text, callback) {
            this.getHead().appendChild(this.createScriptTag(text))
            
            callback && callback()
        },
        
        
        runScript : function (url, callback) {
            if (this.isCSS(url))
                this.loadCSS(url, callback)
            else
                this.getHead().appendChild(this.createScriptTag(null, url, callback))
        },
        
        
        createScriptTag : function (text, url, callback) {
            var node = this.getDocument().createElement("script")
            
            node.setAttribute("type", "text/javascript")
            
            if (url) node.setAttribute("src", url)
            
            if (text) node.text = text
            
            if (callback) node.onload = node.onreadystatechange = function() {
                if (!node.readyState || node.readyState == "loaded" || node.readyState == "complete" || node.readyState == 4 && node.status == 200) {
                    node.onload = node.onreadystatechange = null
                    
                    //surely for IE6..
                    if ('v' == '\v') 
                        setTimeout(callback, 0)
                    else
                        callback()
                }
            }
            
            return node
        },
        
        
        addStyleTag : function (text) {
            var document    = this.getDocument()
            var node        = document.createElement('style')
            
            node.setAttribute("type", "text/css")
            
            var head = document.getElementsByTagName('head')[0]
            head.appendChild(node)
            
            if (node.styleSheet) {   // IE
                node.styleSheet.cssText = text
            } else {                // the world
                node.appendChild(document.createTextNode(text))
            }
        }        
    }
})


/**

Name
====

Scope.Provider.Role.WithDOM - role for scope provider, which uses `script` tag for running the code.


SYNOPSIS
========

        Class('Scope.Provider.IFrame', {
            
            isa     : Scope.Provider,
            
            does    : Scope.Provider.Role.WithDOM,
            
            ...
        })

DESCRIPTION
===========

`Scope.Provider.Role.WithDOM` requires the implementation of the `getDocument` method, which should return the
document into which the `script` tags will be created.

In return, this role provides the implementation of `runCode` and `runScript`.




GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

For general Joose questions you can also visit [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) 
on irc.freenode.org or the forum at: <http://joose.it/forum>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.IFrame', {
    
    isa     : Scope.Provider,
    
    does    : Scope.Provider.Role.WithDOM,
    
    
    have : {
        iframe          : null,
        cls             : null,
        
        performWrap     : false,
        wrapCls         : null,
        wrapper         : null,
        
        parentEl        : null,
        
        cleanupDelay    : 1000
    },
    

    methods : {
        
        getDocument : function () {
            return this.iframe.contentWindow.document
        },
        
        
        create : function (onLoadCallback) {
            var me                  = this
            var doc                 = this.parentWindow.document
            var iframe              = this.iframe = doc.createElement('iframe')
            
            var minViewportSize     = this.minViewportSize
            
            iframe.className        = this.cls || ''
            iframe.style.width      = (minViewportSize && minViewportSize.width || 1024) + 'px'
            iframe.style.height     = (minViewportSize && minViewportSize.height || 768) + 'px'
            iframe.setAttribute('frameborder', 0)

            var ignoreOnLoad        = false    
            
            var callback = function () {
                if (ignoreOnLoad) return
                
                if (iframe.detachEvent) 
                    iframe.detachEvent('onload', callback)
                else
                    iframe.onload = null
                
                onLoadCallback && onLoadCallback(me)
            }
            
            if (iframe.attachEvent) 
                iframe.attachEvent('onload', callback)
            else
                iframe.onload   = callback
            
            iframe.src = this.sourceURL || 'about:blank'
            
            if (this.performWrap) {
                var wrapper         = this.wrapper  = this.wrapper || doc.createElement('div')
                
                wrapper.className   = this.wrapCls || ''
                
                wrapper.appendChild(iframe)
            } 
            
            ;(this.parentEl || doc.body).appendChild(wrapper || iframe)
            
            var scope   = this.scope = iframe.contentWindow
            var doc     = this.getDocument()
            
            // dances with tambourine around the IE, somehow fixes the cross-domain limits
            if ('v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)) {
                // only ignore the 1st call to callback when there is a `sourceURL` config
                // which will later be assigned to `iframe.src` and will trigger a new iframe loading
                if (this.sourceURL) ignoreOnLoad = true
                
                doc.open()
                doc.write('')
                doc.close()
                
                ignoreOnLoad = false
                
                iframe.onreadystatechange = function () {
                    if (iframe.readyState == 'complete') iframe.onreadystatechange = null
                    
                    // trying to add the "early" onerror handler on each "readyState" change
                    // for some mystical reasons can't use `me.installOnErrorHandler` need to inline the call
                    if (me.cachedOnError) me.attachToOnError(scope, me.scopeId, me.cachedOnError)
                }
                
                if (this.sourceURL) iframe.src = this.sourceURL
            }
            
            // trying to add the "early" onerror handler - installing it in this stage will only work in FF 
            // (other browsers will clear on varios stages)
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },
        
        
        cleanup : function () {
            var wrapper     = this.wrapper || this.iframe
            var iframe      = this.iframe
            var me          = this
            
            wrapper.style.display    = 'none'
            
            var onUnloadChecker = function () {
                if (!window.onunload) window.onunload = function () { return 'something' }
            }
            
            // add the `onunload` handler if there's no any - attempting to prevent browser from caching the iframe
            // trying to create the handler from inside of the scope
            this.runCode(';(' + onUnloadChecker.toString() + ')();')

            this.iframe     = null
            this.scope      = null
            this.wrapper    = null

            // wait for 1000ms to allow time for possible `setTimeout` in the scope of iframe
            setTimeout(function () {
                
                if (me.beforeCleanupCallback) me.beforeCleanupCallback()
                
                // chaging the page, triggering `onunload` and hopefully preventing browser from caching the content of iframe
                iframe.src      = 'javascript:false'
                
                // wait again before removing iframe from the DOM, as recommended by some online sources
                setTimeout(function () {
                    ;(me.parentEl || me.parentWindow.document.body).removeChild(wrapper)
                    
                    wrapper     = null
                    iframe      = null
                    
                    me.parentEl = null
                    
                    me.cleanupHanlders()
                    
                    if (me.cleanupCallback) me.cleanupCallback()
                    
                }, me.cleanupDelay)
            }, me.cleanupDelay)
        }
    }
})

/**

Name
====

Scope.Provider.IFrame - scope provider, which uses the iframe.


SYNOPSIS
========

        var provider = new Scope.Provider.IFrame()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.IFrame` is an implementation of the scope provider, which uses the iframe, 
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.Window', {
    
    isa     : Scope.Provider,

    does    : Scope.Provider.Role.WithDOM,
    
    
    has     : {
        popupWindow     : null
    },
    

    methods : {
        
        create : function (onLoadCallback) {
            var popup   = this.scope = this.popupWindow = this.parentWindow.open(this.sourceURL || 'about:blank', '_blank', "width=800,height=600")
            
            if (!popup) {
                alert('Please enable popups for the host with this test suite running: ' + this.parentWindow.location.host)
                throw 'Please enable popups for the host with this test suite running: ' + this.parentWindow.location.host
            }
            
            var isIE = 'v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)
            
            // dances with tambourine around the IE
            if (isIE && !this.sourceURL) {
                var doc = this.getDocument()
                
                doc.open()
                doc.write('')
                doc.close()
            }
            
            // trying to add the "early" onerror handler - will probably only work in FF
            if (this.cachedOnError) this.installOnErrorHandler(this.cachedOnError)
            
            /*!
             * contentloaded.js
             *
             * Author: Diego Perini (diego.perini at gmail.com)
             * Summary: cross-browser wrapper for DOMContentLoaded
             * Updated: 20101020
             * License: MIT
             * Version: 1.2
             *
             * URL:
             * http://javascript.nwbox.com/ContentLoaded/
             * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
             *
             */
            
            // @win window reference
            // @fn function reference
            var contentLoaded = function (win, fn) {
            
                var done = false, top = true,
            
                doc = win.document, root = doc.documentElement,
            
                add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
                rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
                pre = doc.addEventListener ? '' : 'on',
            
                init = function(e) {
                    if (e.type == 'readystatechange' && doc.readyState != 'complete') return;
                    
                    (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);
                    
                    if (!done && (done = true)) fn.call(win, e.type || e);
                },
            
                poll = function() {
                    try { root.doScroll('left'); } catch(e) { setTimeout(poll, 50); return; }
                    
                    init('poll');
                };
            
                if (doc.readyState == 'complete') 
                    fn.call(win, 'lazy');
                else {
                    if (doc.createEventObject && root.doScroll) {
                        try { top = !win.frameElement; } catch(e) { }
                        if (top) poll();
                    }
                    doc[add](pre + 'DOMContentLoaded', init, false);
                    doc[add](pre + 'readystatechange', init, false);
                    win[add](pre + 'load', init, false);
                }
            }
            
            contentLoaded(popup, onLoadCallback || function () {})
        },
        
        
        getDocument : function () {
            return this.popupWindow.document
        },
        
        
        cleanup : function () {
            if (this.beforeCleanupCallback) this.beforeCleanupCallback()
            
            this.popupWindow.close()
            
            this.popupWindow = null
            
            this.cleanupHanlders()
            
            if (this.cleanupCallback) this.cleanupCallback()
        }
    }
})

/**

Name
====

Scope.Provider.Window - scope provider, which uses the popup browser window.


SYNOPSIS
========

        var provider = new Scope.Provider.Window()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.Window` is an implementation of the scope provider, which uses the popup browser window, 
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.NodeJS', {
    
    isa     : Scope.Provider,

    
    has     : {
        sourceURL       : null
    },
    

    methods : {
        
        compile : function (module, content, filename) {
            var Module    = require('module')
            var path      = require('path')
            
            var self      = module;
            // remove shebang
            content       = content.replace(/^\#\!.*/, '');
        
            var modRequire     = function (path) {
                return self.require(path);
            }
        
            modRequire.resolve = function(request) {
                return Module._resolveFilename(request, self)[1];
            };
        
            Object.defineProperty(modRequire, 'paths', { get: function() {
                throw new Error('modRequire.paths is removed. Use ' +
                            'node_modules folders, or the NODE_PATH '+
                            'environment variable instead.');
            }});
        
            modRequire.main = process.mainModule;
        
            // Enable support to add extra extension types
            modRequire.extensions = Module._extensions;
            modRequire.registerExtension = function() {
                throw new Error('modRequire.registerExtension() removed. Use ' +
                            'modRequire.extensions instead.');
            };
        
            modRequire.cache = Module._cache;
        
            var dirname = path.dirname(filename);
        
            // create wrapper function
            var wrapper = Module.wrap(content);
            
            var compiledWrapper = require('vm').runInContext(wrapper, this.scope, filename);
            
            return compiledWrapper.apply(self.exports, [self.exports, modRequire, self, filename, dirname]);
        },        
        
        
        addOnErrorHandler : function (handler, callback) {
        },

        
        create : function (callback) {
            var vm          = require('vm')
            var sandbox     = {}

            Joose.O.extend(sandbox, {
//                __PROVIDER__    : true,
                
                process         : process,
                
                global          : sandbox,
                root            : root,
                
                setTimeout      : setTimeout,
                clearTimeout    : clearTimeout,
                setInterval     : setInterval,
                clearInterval   : clearInterval
//                ,
//                
//                __filename      : __filename,
//                __dirname       : __dirname,
//                module          : module
            })
            
            var scope       = this.scope    = vm.createContext(sandbox)
            
            callback && callback()
        },
        
        
        setup : function (callback) {
            this.create()
            
            var me      = this
            
            if (this.seedingCode) require('vm').runInContext(this.seedingCode, this.scope)
            
            Joose.A.each(this.getPreload(), function (preloadDesc) {
                
                if (preloadDesc.type == 'js')
                    if (preloadDesc.url)
                        me.runScript(preloadDesc.url)
                    else
                        me.runCode(preloadDesc.content)
            })
            
            if (this.seedingScript) {
                var Module          = require('module')
                var path            = require('path')
                
                var module          = new Module('./' + this.sourceURL, require.main)
                
                var filename        = module.filename = path.join(path.dirname(require.main.filename), this.sourceURL)
                
                var content         = require('fs').readFileSync(filename, 'utf8')
                // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
                // because the buffer-to-string conversion in `fs.readFileSync()`
                // translates it to FEFF, the UTF-16 BOM.
                if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1)
  
                this.compile(module, content, filename)
            }
            
            callback && callback()
        },
        
        
        runCode : function (text, callback) {
            var res = require('vm').runInContext(text, this.scope)
            
            callback && callback(res)
            
            return res
        },
        
        
        runScript : function (url, callback) {
            var content = require('fs').readFileSync(url, 'utf8')
            
            var res = require('vm').runInContext(content, this.scope, url)
            
            callback && callback(res)
            
            return res
        },
        
        
        cleanup : function () {
            if (this.beforeCleanupCallback) this.beforeCleanupCallback()
            if (this.cleanupCallback) this.cleanupCallback()
        }
    }
})


/**

Name
====

Scope.Provider.NodeJS - scope provider, which uses the `Script.runInNewContext` call of the NodeJS.


SYNOPSIS
========

        var provider = new Scope.Provider.NodeJS()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.NodeJS` is an implementation of the scope provider, 
which uses the `Script.runInNewContext` call of the NodeJS platform.


ISA
===

[Scope.Provider](../Provider.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
;
Class('JooseX.Observable.Event', {
    
    has : {
        name        : { required : true },
        args        : { required : true },
        
        source      : { required : true },
        
        splat       : null,
        current     : null,
        
        bubbling    : true
    },
    
        
    methods : {
        
        stopPropagation : function () {
            this.bubbling = false
        }
    }
})


;
Class('JooseX.Observable.Listener', {

    has : {
        channel     : { required : true },
        eventName   : { required : true },
        
        func        : { required : true },
        scope       : null,
        
        single          : false,
        
        buffer          : null,
        bufferMax       : null,
        
        bufferStartedAt : null,
        bufferTimeout   : null,
        
        delayTimeout    : null,
        
        delay           : null
    },
    
        
    methods : {
        
        activate : function (event, args) {
            var me      = this
            
            if (me.buffer != null) {
                
                if (me.bufferMax != null)
                    if (!me.bufferStartedAt) 
                        me.bufferStartedAt = new Date()
                    else
                        if (new Date - me.bufferStartedAt > me.bufferMax) return
                
                        
                if (me.bufferTimeout) clearTimeout(me.bufferTimeout)
                
                me.bufferTimeout = setTimeout(function () {
                    
                    delete me.bufferStartedAt
                    delete me.bufferTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.buffer)
                
                return
            }
            
            if (me.delay != null) {
                
                me.delayTimeout = setTimeout(function () {
                    
                    delete me.delayTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.delay)
                
                return
            }
            
            return me.doActivate(event, args)
        },
        
        
        doActivate : function (event, args) {
            if (this.single) this.remove()
            
            return this.func.apply(this.scope || event.source, [ event ].concat(args) ) !== false
        },
        
        
        cancel  : function () {
            if (this.buffer) {
                clearTimeout(this.bufferTimeout)
                
                delete this.bufferTimeout
                delete this.bufferStartedAt
            }
            
            if (this.delay) clearTimeout(this.delayTimeout)
        },
        
        
        remove : function () {
            this.channel.removeListener(this)
        }
    }
})


;
Class('JooseX.Observable.Channel', {
    
    has : {
        channels    : Joose.I.Object,
        
        listeners   : Joose.I.Object
    },
    
        
    methods : {
        
        // (!) segments array will be destroyed in this method
        getListenersFor : function (segments, name, activators) {
            var listeners = this.listeners
            
            if (listeners[ '**' ]) {
                
                var splat       = segments.concat(name)
                
                Joose.A.each(listeners[ '**' ], function (listener) {
                    activators.push({
                        listener    : listener,
                        splat       : splat
                    })
                })
            }
            
            if (segments.length) {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) next.getListenersFor(segments, name, activators)
            } else {
                
                if (listeners[ '*' ])
                    Joose.A.each(listeners[ '*' ], function (listener) {
                        
                        activators.push({
                            listener    : listener,
                            splat       : name
                        })
                    })
                
                if (listeners[ name ])  
                    Joose.A.each(listeners[ name ], function (listener) {
                        
                        activators.push({
                            listener    : listener
                        })
                    })
            }
        },
        
        
        hasListenerFor : function (segments, name) {
            var listeners = this.listeners
            
            if (listeners[ '**' ] && listeners[ '**' ].length) return true
            
            if (segments.length)  {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) return next.hasListenerFor(segments, name)
                
            } else {
                
                if (listeners[ '*' ] && listeners[ '*' ].length) return true
                
                if (listeners[ name ] && listeners[ name ].length) return true  
            }
            
            return false
        },
        
        
        addListener : function (listener) {
            var eventName   = listener.eventName
            var listeners   = this.listeners
            
            listeners[ eventName ] = listeners[ eventName ] || []
            
            listeners[ eventName ].push(listener)
        },
        
        
        removeListener : function (listenerToRemove) {
            var eventListeners      = this.listeners[ listenerToRemove.eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener == listenerToRemove) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        removeListenerByHandler : function (eventName, func, scope) {
            var eventListeners      = this.listeners[ eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener.func == func && listener.scope == scope) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        getSingleChannel : function (name, doNotCreate) {
            var channels    = this.channels
            
            if (channels[ name ]) return channels[ name ]
            
            if (doNotCreate) return null
            
            return channels[ name ] = new JooseX.Observable.Channel()
        },
        
        
        // (!) segments array will be destroyed in this method
        getChannel : function (segments, doNotCreate) {
            if (!segments.length) return this
            
            var next    = this.getSingleChannel(segments.shift(), doNotCreate)
            
            if (doNotCreate && !next) return null
            
            return next.getChannel(segments, doNotCreate)
        }
    }
})


;
Role('JooseX.Observable', {
    
    /*PKGVERSION*/VERSION : 0.04,
    
//    use : [ 
//        'JooseX.Observable.Channel',    
//        'JooseX.Observable.Listener', 
//        'JooseX.Observable.Event'    
//    ],
    
    
//    trait   : 'JooseX.Observable.Meta',
    
    
    has : {
        rootChannel             : {
            is          : 'rw',
            init        : function () { return new JooseX.Observable.Channel() }
        },
        
        suspendCounter          : 0
    },
    
        
    methods : {
        
        getBubbleTarget : function () {
        },
        
        
        parseEventPath : function (path) {
            var channels    = path.split('/')
            var eventName   = channels.pop()
            
            if (channels.length && !channels[ 0 ]) channels.shift()
            
            return {
                channels        : channels,
                eventName       : eventName
            }
        },
        
        
        on : function (path, func, scope, options) {
            if (!func) throw "Not valid listener function provided when subsribing on event: " + path
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels)
            
            var listener    = new JooseX.Observable.Listener(Joose.O.extend(options || {}, {
                channel     : channel,
                eventName   : parsed.eventName,
                
                func        : func,
                scope       : scope
            }))
            
            channel.addListener(listener)
            
            return listener
        },
        
        
        un : function (path, func, scope) {
            
            if (path instanceof JooseX.Observable.Listener) {
                
                path.remove()
                
                return
            }
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels, true)
            
            if (channel) channel.removeListenerByHandler(parsed.eventName, func, scope)
        },
        
        
        emit : function () {
            return this.fireEvent.apply(this, arguments)
        },
        
        
        fireEvent : function (path) {
            if (this.suspendCounter) return
            
            var args        = Array.prototype.slice.call(arguments, 1)

            var event       = new JooseX.Observable.Event({
                name        : path,
                args        : args,
                
                source      : this
            }) 
            
            return this.propagateEvent(event, path, args)
        },
        
        
        propagateEvent : function (event, path, args) {
            if (this.suspendCounter) return
            
            var parsed      = this.parseEventPath(path)
            var eventName   = parsed.eventName
            
            if (!eventName == '*' || eventName == '**') throw new Error("Can't fire an empty event or event with `*`, `**` names ")
            
            var activators  = []
            
            this.getRootChannel().getListenersFor(parsed.channels, eventName, activators)
            
            var res             = true
            
            event.current       = this
            
            if (activators.length) Joose.A.each(activators, function (activator) {
                event.splat = activator.splat
                
                res = activator.listener.activate(event, args) !== false && res
            })
            
            if (event.bubbling) {
                
                var further = this.getBubbleTarget()
                
                if (further) res = further.propagateEvent(event, path, args) !== false && res
            } 
                
            return res
        },
        
        
        hasListenerFor : function (path) {
            var parsed      = this.parseEventPath(path)
            
            return this.getRootChannel().hasListenerFor(parsed.channels, parsed.eventName)
        },
        
        
        purgeListeners  : function () {
            this.rootChannel = new JooseX.Observable.Channel()
        },
        
        
        suspendEvents : function () {
            this.suspendCounter++
        },
        
        
        resumeEvents : function () {
            this.suspendCounter--
            
            if (this.suspendCounter < 0) this.suspendCounter = 0
        }
    }
});
;
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
;
!function () {
    
    var REF      = 1    

    Class('Data.Visitor2', {
        
        has : {
            seenPlaceholder : {
                init        : {}
            },
            
            outOfDepthPlaceholder : {
                init        : {}
            },
            
            seen            : Joose.I.Object,
            
            maxDepth        : null
        },
            
        methods : {
            
            getClassNameFor : function (object) {
                if (Joose.O.isInstance(object))      return object.meta.name
                
                return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
            },
            
            
            getRefAdr : function () {
                return REF++
            },
            
            
            assignRefAdrTo : function (object) {
                if (!object.__REFADR__) 
                    if (Object.defineProperty)
                        Object.defineProperty(object, '__REFADR__', { value : REF++ })
                    else
                        object.__REFADR__ = REF++
                
                return object.__REFADR__
            },
                
                
            isSeen : function (object) {
                return object.__REFADR__ && this.seen.hasOwnProperty(object.__REFADR__)
            },
            
            
            markSeenAs : function (object, result) {
                return this.seen[ object.__REFADR__ ] = result
            },
            
            
            hasSeenResultFor : function (object) {
                var ref = object.__REFADR__
                
                return this.seen.hasOwnProperty(ref) && this.seen[ ref ] != this.seenPlaceholder
            },
            
            
            visit : function (value, depth) {
                // will be false for NaN values
                if (depth > this.maxDepth)
                    return this.visitOutOfDepthValue(value, depth + 1)
                else
                    if (Object(value) === value)
                        if (this.isSeen(value)) 
                            return this.visitSeen(value, depth + 1)
                        else                        
                            return this.visitNotSeen(value, depth + 1)
                    else
                        return this.visitValue(value, depth + 1)
            },
            
            
            visitOutOfDepthValue : function (value, depth) {
                return this.outOfDepthPlaceholder
            },
            
            
            visitValue : function (value, depth) {
                return value
            },
            
            
            visitSeen : function (value, depth) {
                return this.seen[ value.__REFADR__ ]
            },
            
            
            getInitialSeenMarker : function (object, depth) {
                return this.seenPlaceholder
            },
            
            
            visitNotSeen : function (object, depth) {
                this.assignRefAdrTo(object)
                
                this.markSeenAs(object, this.getInitialSeenMarker(object, depth))
    
                
                if (Joose.O.isInstance(object)) return this.markSeenAs(object, this.visitJooseInstance(object, depth))
                
                
                var methodName = 'visit' + this.getClassNameFor(object)
                
                if (!this.meta.hasMethod(methodName)) methodName = 'visitObject' 
                
                return this.markSeenAs(object, this[ methodName ](object, depth))
            },
            
            
            visitArray  : function (array, depth) {
                Joose.A.each(array, function (value, index) {
                    
                    this.visitArrayEntry(value, index, array, depth)
                    
                }, this)
                
                return array
            },
            
            
            visitArrayEntry  : function (entry, index, array, depth) {
                return this.visit(entry, depth)
            },
            
            
            visitObject : function (object, depth) {
                
                Joose.O.eachOwn(object, function (value, key) {
                    
                    if (key != '__REFADR__') {
                        this.visitObjectKey(key, value, object, depth)
                        this.visitObjectValue(value, key, object, depth)
                    }
                    
                }, this)
                
                return object
            },
            
            
            visitJooseInstance : function (value, depth) {
                return this.visitObject(value, depth)
            },
            
            
            visitObjectKey : function (key, value, object, depth) {
                return this.visitValue(key, depth)
            },
            
            
            visitObjectValue : function (value, key, object, depth) {
                return this.visit(value, depth)
            }
        },
        
        
        my : {
            
            has : {
                HOST        : null
            },
            
            
            methods : {
                
                visit : function (value, maxDepth) {
                    var visitor     = new this.HOST({
                        maxDepth        : maxDepth || Infinity
                    })
                    
                    return visitor.visit(value, 0)
                }
            }
        }
    })    
    
}()


;
;
;
Class('Siesta.Util.Serializer', {
    
    isa : Data.Visitor2,
    
    has     : {
        result                  : Joose.I.Array,
        manualEnum              : function () {
            for (var i in { toString : 1 }) return false
            
            return true
        }
    },
    
    
    methods : {
        
        assignRefAdrTo : function (object) {
            try {
                return this.SUPER(object)
            } catch (e) {
                if (!object.__REFADR__) object.__REFADR__ = this.getRefAdr()
            }
            
            return object.__REFADR__
        },
        
        
        write : function (str) {
            this.result.push(str)
        },
        
        
        visitOutOfDepthValue : function (value, depth) {
            this.write('...')
        },
        
        
        visitValue : function (value) {
            if (value == null)
                // `null` and `undefined`
                this.write(value + '')
            else
                this.write(typeof value == 'string' ? '"' + value.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"' : value + '')
        },
        
        
        visitObjectKey : function (key, value, object) {
            this.write('"' + key + '": ')
        },
        
        
        getClassNameFor : function (object) {
            if (object.nodeType != null && object.nodeName != null && object.tagName) return 'DOMElement'
            
            // trying to detect and not dive into global window
            if (object.document != null && object.location != null && object.location.href != null) return 'Window'
            
            return this.SUPER(object)
        },
        
        
        visitSeen : function (value, depth) {
            this.write('[Circular]')
        },
        
        
        visitRegExp : function (value, depth) {
            this.write(value + '')
        },
        
        
        visitFunction : function (value, depth) {
            this.write('function ' + (value.name || '') + '() { ... }')
        },
        
        
        visitDate : function (value, depth) {
            this.write('"' + value + '"')
        },
        

        // safer alternative to parent's implementation of `visitObject` - some host objects has no "hasOwnProperty" method
        visitObject : function (object, depth) {
            for (var key in object) {
                if (key != '__REFADR__' && (!object.hasOwnProperty || object.hasOwnProperty(key))) {
                    var value   = object[ key ]
                    
                    this.visitObjectKey(key, value, object, depth)
                    this.visitObjectValue(value, key, object, depth)
                }
            }

            var me  = this
            
            if (this.manualEnum) 
                Joose.A.each([ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ], function (key) {
                    if (object.hasOwnProperty && object.hasOwnProperty(key)) {
                        var value   = object[ key ]
                        
                        me.visitObjectKey(key, value, object, depth)
                        me.visitObjectValue(value, key, object, depth)
                    }
                })
            
            return object
        },
        
        
        visitJooseInstance : function (value, depth) {
            if (value.meta.hasMethod('toString')) {
                this.write(value.toString())
                
                return value
            }
            
            return this.SUPERARG(arguments)
        },
        
        
        visitDOMElement : function (object, depth) {
            var output  = '&lt;' + object.tagName
            
            if (object.id) output += ' id="' + object.id + '"'
            if (object.className) output += ' class="' + object.className + '"'
            
            this.write(output + '&gt;')
        },
        
        
        visitDOMStringMap : function () {
            this.write('[DOMStringMap]')
        },
        
        
        // the Object.prototype.toString.call(window) for FF
        visitWindow : function () {
            this.write('[window]')
        },
        
        
        // window.location type in FF
        visitLocation : function () {
            this.write('[window.location]')
        }
    },
    
    
    before : {
        visitObject : function () {
            this.write('{')
        },
        
        
        visitArray : function () {
            this.write('[')
        }
    },
    
    
    after : {
        visitObject : function () {
            var result = this.result
            
            if (result[ result.length - 1 ] == ', ') result.pop()
            
            this.write('}')
        },
        
        
        visitArray : function () {
            var result = this.result
            
            if (result[ result.length - 1 ] == ', ') result.pop()
            
            this.write(']')
        },
        
        
        visitObjectValue : function () {
            this.write(', ')
        },
        
        
        visitArrayEntry : function () {
            this.write(', ')
        }
    },
    
    
    my : {
        
        has : {
            HOST        : null
        },
        
        
        methods : {
            
            stringify : function (value, maxDepth) {
                var visitor     = new this.HOST({
                    maxDepth        : maxDepth || 4
                })
                
                visitor.visit(value, 0)
                
                return visitor.result.join('')
            }
        }
    }
})
;
Role('Siesta.Util.Role.CanFormatStrings', {
    
    methods : {
        
        formatString: function (string, data) {
            var match
            var variables           = []
            var isRaw               = []
            var regexp              = /\{(\!)?((?:\w|-|_)+?)\}/g
            
            while (match = regexp.exec(string)) {
                isRaw.push(match[ 1 ])
                variables.push(match[ 2 ])
            }
            
            var result              = string
            
            Joose.A.each(variables, function (variable, index) {
                var varIsRaw        = isRaw[ index ]
                
                result              = result.replace(
                    new RegExp('\\{' + (varIsRaw ? '!' : '') + variable + '\\}', 'g'), 
                    data.hasOwnProperty(variable) ? 
                        varIsRaw ? data[ variable ] + '' : Siesta.Util.Serializer.stringify(data[ variable ]) 
                    : 
                        ''
                )
            })
            
            return result
        }
    }
})
;
Class('Siesta.Util.Queue', {
    
    has     : {
        // array of Objects, each containing arbitrary data about queue step. Possibly keys:
        // `processor` - an individual processor function for this step
        // can also be provided for whole queue
        // will receive the: (stepData, index, queue)
        // `isAsync` - when provided, the `next` function will be also embedded,
        // which should be called manually
        // `interval` - the delay after step (except for asynchronous)
        steps                   : Joose.I.Array,

        interval                : 100,
        callbackDelay           : 0,
        // setTimeout
        deferer                 : { required : true },
        // clearTimeout - only required when "abort" is planned / possible
        deferClearer            : null,
        
        processor               : null,
        processorScope          : null,
        
        currentTimeout          : null,
        callback                : null,
        scope                   : null,
        isAborted               : false,
        
        observeTest             : null,

        currentDelayStepId      : null
    },
    
    
    methods : {
        
        // step is an object with
        // { 
        //      processor : func, 
        //      processorScope : obj,
        //      next : func (in case of async step, will be populated by queue)
        // }
        
        addStep : function (stepData) {
            this.addSyncStep(stepData)
        },
        
        
        addSyncStep : function (stepData) {
            this.steps.push(stepData)
        },
        
        
        addAsyncStep : function (stepData) {
            stepData.isAsync = true
            
            this.steps.push(stepData)
        },

        addDelayStep : function (delayMs) {
            var origSetTimeout = this.deferer;
            var me = this;

            this.addAsyncStep({
                processor : function(data) {
                    me.currentDelayStepId = origSetTimeout(data.next, delayMs || 500);
                }
            });
        },
        
        
        run : function (callback, scope) {
            this.callback   = callback
            this.scope      = scope
            
            // abort the queue, if the provided test instance has finalized (probably because of exception)
            this.observeTest && this.observeTest.on('testfinalize', function () { this.abort(true) }, this, { single : true })
            
            this.doSteps(this.steps.slice(), callback, scope)
        },
        
        
        abort : function (ignoreCallback) {
            this.isAborted      = true
            
            var deferClearer    = this.deferClearer
            
            if (!deferClearer) throw "Need `deferClearer` to be able to `abort` the queue"

            deferClearer(this.currentDelayStepId);
            deferClearer(this.currentTimeout)
            
            if (!ignoreCallback) this.callback.call(this.scope || this)
        },
        
        
        doSteps : function (steps, callback, scope) {
            this.currentTimeout = null
            
            var me          = this
            var deferer     = this.deferer
            var step        = steps.shift()
            
            if (this.isAborted) return
            
            if (step) {
                var processor       = step.processor || this.processor
                var processorScope  = step.processorScope || this.processorScope
                
                var index           = this.steps.length - steps.length - 1
                
                if (!processor) throw new Error("No process function found for step: " + index)
                
                if (step.isAsync) {
                    var next = step.next = function () {
                        me.doSteps(steps, callback, scope)
                    }
                    
                    // processor should call `next` to continue
                    processor.call(processorScope || me, step, index, this, next)
                } else {
                    
                    processor.call(processorScope || me, step, index, this)
                    
                    if (this.isAborted) return
                    
                    var interval = step.interval || me.interval
                    
                    if (interval) 
                        this.currentTimeout = deferer(function () {
                            me.doSteps(steps, callback, scope)    
                        }, interval)
                    else
                        me.doSteps(steps, callback, scope)
                }
                
                
            } else {
                if (callback)
                    if (this.callbackDelay)
                        deferer(function () {
                            if (!me.isAborted) callback.call(scope || this)
                        }, this.callbackDelay)
                    else
                        callback.call(scope || this)
            }
        }
    }
})
;
Class('Siesta.Util.XMLNode', {
    
    has     : {
        children        : Joose.I.Array,
        
        tag             : { required : true },
        attributes      : Joose.I.Object,
        
        textContent     : null,
        
        escapeTable     : {
            
            init    : {
                '&'     : '&amp;', 
                '<'     : '&lt;', 
                '>'     : '&gt;', 
                '"'     : '&quot;'
            }
        }
        
    },
    
    
    methods : {
        
        escapeXml : function (s) {
            var me = this
            
            return typeof s != 'string' ? s : s.replace(/[&<>"]/g, function (match) {
                return me.escapeTable[ match ]
            })
        },
        
        
        toString : function () {
            var me                  = this
            var childrenContent     = []
            
            Joose.A.each(this.children, function (child) {
                childrenContent.push(child.toString())
            })
            
            var attributesContent       = []
            
            Joose.O.each(this.attributes, function (value, name) {
                attributesContent.push(name + '="' + me.escapeXml(value) + '"')
            })
            
            // to have predictable order of attributes in tests
            attributesContent.sort()
            
            attributesContent.unshift(this.tag)
            
            
            return '<' + attributesContent.join(' ') + '>' + (this.textContent != null ? this.escapeXml(this.textContent) : '') + childrenContent.join('') + '</' + this.tag + '>' 
        },
        
        
        appendChild : function (child) {
            if (child instanceof Siesta.Util.XMLNode)
                child.parent    = this
            else
                child           = new Siesta.Util.XMLNode(Joose.O.extend(child, { parent : this }))
                
            this.children.push(child)
            
            return child
        },
        
        
        setAttribute : function (name, value) {
            this.attributes[ name ] = value
        }
    }
})
;
Class('Siesta.Util.Rect', {
    
    has     : {
        left            : null,
        top             : null,
        width           : null,
        height          : null,
        
        right           : null,
        bottom          : null
    },
    
    
    methods : {
        
        initialize : function () {
            var left        = this.left
            var width       = this.width
            var right       = this.right
            
            if (right == null && left != null && width != null) this.right = left + width - 1
            
            if (width == null && left != null && right != null) this.width = right - left + 1
            
            var top         = this.top
            var height      = this.height
            var bottom      = this.bottom
            
            if (bottom == null && top != null && height != null) this.bottom = top + height - 1
            
            if (height == null && top != null && bottom != null) this.height = bottom - top + 1
        },
        
        
        isEmpty : function () {
            return this.left == null
        },
        
        
        intersect : function (rect) {
            if (
                rect.isEmpty() || this.isEmpty()
                    ||
                rect.left > this.right || rect.right < this.left
                    ||
                rect.top > this.bottom || rect.bottom < this.top
            ) return this.my.getEmpty()
            
            return new this.constructor({
                left        : Math.max(this.left, rect.left),
                right       : Math.min(this.right, rect.right),
                top         : Math.max(this.top, rect.top),
                bottom      : Math.min(this.bottom, rect.bottom)
            })
        },
        
        
        contains : function (left, top) {
            return this.left <= left && left <= this.right 
                    && 
                this.top <= top && top <= this.bottom
        },
        
        
        cropLeftRight : function (rect) {
            return this.intersect(new this.constructor({
                left        : rect.left,
                right       : rect.right,
                top         : this.top,
                bottom      : this.bottom
            }))
        },
        
        
        cropTopBottom : function (rect) {
            return this.intersect(new this.constructor({
                left        : this.left,
                right       : this.right,
                top         : rect.top,
                bottom      : rect.bottom
            }))
        },
        
        
        equalsTo : function (rect) {
            return this.left == rect.left && this.right == rect.right && this.top == rect.top && this.bottom == rect.bottom
        }
    },
    
    
    // static methods/props
    my : {
        has : {
            HOST        : null
        }, 
        
        methods : {
            
            getEmpty : function () {
                return new this.HOST()
            }
        }
    }
})
;
Class('Siesta.Content.Resource', {
    
    has : {
        url             : null,
        
        content         : null
    },
    
    
    methods : {
        
        asHTML : function () {
            throw "Abstract method called"
        },
        
        
        asDescriptor : function () {
            throw "Abstract method called"
        },
        
        
        // todo should check same-origin 
        canCache : function () {
        }
        
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Resource.CSS', {
    
    isa     : Siesta.Content.Resource,
    
    has     : {
    },
    
    
    methods : {
        
        asHTML : function () {
        },
        
        
        asDescriptor : function () {
            var res = {
                type        : 'css'
            }
            
            if (this.url)       res.url         = this.url
            if (this.content)   res.content     = this.content
            
            return res
        }
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Resource.JavaScript', {
    
    isa     : Siesta.Content.Resource,
    
    has     : {
        instrument          : false
    },
    
    
    methods : {
        
        asHTML : function () {
        },
        
        
        asDescriptor : function () {
            var res = {
                type        : 'js'
            }
            
            if (this.url)       res.url         = this.url
            if (this.content)   res.content     = this.content
            
            return res
        }
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Preset', {
    
    has : {
        preload                 : Joose.I.Array,
        
        resources               : Joose.I.Array
    },
    
    
    methods : {
        
        initialize : function () {
            var me              = this
            
            Joose.A.each(this.preload, function (preloadDesc) {
                
                me.addResource(preloadDesc)
            })
        },
        
        
        isCSS : function (url) {
            return /\.css(\?.*)?$/i.test(url)
        },
        
        
        getResourceFromDescriptor : function (desc) {
            var constructor, config
            
            var CSS
            
            if (typeof desc == 'string') {
                constructor     = this.isCSS(desc) ? Siesta.Content.Resource.CSS : Siesta.Content.Resource.JavaScript
                
                config          = { url     : desc }
            } else if (desc.text) {
                constructor     = Siesta.Content.Resource.JavaScript
                config          = { content : desc.text }
                
            } else {
                if (!desc.url && !desc.content) throw "Incorrect preload descriptor:" + desc
                
                constructor     = desc.type && desc.type == 'css' || this.isCSS(desc.url) ? Siesta.Content.Resource.CSS : Siesta.Content.Resource.JavaScript
                
                config          = {}
                
                if (desc.url)           config.url          = desc.url
                if (desc.content)       config.content      = desc.content
                if (desc.instrument)    config.instrument   = desc.instrument
            }
            
            return new constructor(config)
        },
        
        
        addResource : function (desc) {
            var resource    = (desc instanceof Siesta.Content.Resource) && desc || this.getResourceFromDescriptor(desc)
            
            this.resources.push(resource)
            
            return resource
        },
        
        
        eachResource : function (func, scope) {
            return Joose.A.each(this.resources, func, scope || this)
        },
        
        
        // deprecated - seems preset doesn't need to know about scope providers
        prepareScope : function (scopeProvider, contentManager) {
            
            this.eachResource(function (resource) {
                
                if (contentManager.hasContentOf(resource))
                    scopeProvider.addPreload({
                        type        : (resource instanceof Siesta.Content.Resource.CSS) ? 'css' : 'js', 
                        content     : contentManager.getContentOf(resource)
                    })
                else 
                    scopeProvider.addPreload(resource.asDescriptor())
            })
        }
    }
        
})

;
Class('Siesta.Content.Manager', {
    
    has : {
        disabled        : false,
        
        presets         : {
            required    : true
        },
        
        urls            : Joose.I.Object,
        
        maxLoads        : 5,
        
        harness         : null
    },
    
    
    methods : {
        
        cache : function (callback, errback, ignoreErrors) {
            if (this.disabled) {
                callback && callback()
                
                return
            }
            
            var urls    = this.urls
            var me      = this
            
            Joose.A.each(this.presets, function (preset) {
                preset.eachResource(function (resource) {
                    if (resource.url) urls[ resource.url ] = null
                })
            })
            
            var loadCount   = 0
            var errorCount  = 0
            
            var urlsArray   = []
            
            Joose.O.each(urls, function (value, url) {
                // if some content has been already provided - skip it from caching
                if (!me.hasContentOf(url)) urlsArray.push(url) 
            })
            
            var total       = urlsArray.length
            
            if (total) {
                
                var loadSingle = function () {
                    if (!urlsArray.length) return
                    
                    var url     = urlsArray.shift()
                    
                    me.load(url, function (content) {
                        if (errorCount) return
                        
                        urls[ url ] = content
                        
                        if (++loadCount == total) 
                            callback && callback()
                        else
                            loadSingle()
                    
                    }, ignoreErrors ? function () {
                        
                        if (++loadCount == total) 
                            callback && callback()
                        else
                            loadSingle()
                        
                    } : function () {
                        errorCount++
                        
                        errback && errback(url)
                    })
                }
                
                // running only `maxLoads` "loading threads" at the same time
                for (var i = 0; i < this.maxLoads; i++) loadSingle()
                
            } else
                callback && callback()
        },
        
        
        load : function (url, callback, errback) {
            throw "abstract method `load` called"
        },
        
        
        addContent : function (url, content) {
            this.urls[ url ]    = content
        },
        
        
        hasContentOf : function (url) {
            if (url instanceof Siesta.Content.Resource) url = url.url
            
            return typeof this.urls[ url ] == 'string'
        },
        
        
        getContentOf : function (url) {
            if (url instanceof Siesta.Content.Resource) url = url.url
            
            return this.urls[ url ]
        }
    }
})

;
;
Class('Siesta', {
    /*PKGVERSION*/VERSION : '2.0.5',

    // "my" should been named "static"
    my : {
        
        has : {
            config          : null,
            activeHarness   : null
        },
        
        methods : {
        
            getConfigForTestScript : function (text) {
                try {
                    eval(text)
                    
                    return this.config
                } catch (e) {
                    return null
                }
            },
            
            
            StartTest : function (arg1, arg2) {
                if (typeof arg1 == 'object') 
                    this.config = arg1
                else if (typeof arg2 == 'object')
                    this.config = arg2
                else
                    this.config = null
            }
        }
    }
})

// fake StartTest function to extract test configs
if (typeof StartTest == 'undefined') StartTest = Siesta.StartTest
if (typeof startTest == 'undefined') startTest = Siesta.StartTest
if (typeof describe == 'undefined') describe = Siesta.StartTest;
;(function () {
    
var ID = 0

Class('Siesta.Result', {
    
    has : {
        description     : null,
        
        children        : Joose.I.Array,
        
        length          : 0,
        
        id              : function () {
            return ++ID
        },
        
        parent          : null
    },
    
    
    methods : {
        
        itemAt : function (i) {
            return this.children[ i ]
        },
        
        
        push        : function (result) {
            this.children.push(result)
            
            result.parent   = this
            
            this.length     = this.children.length
        },
        
        
        each : function (func, scope) {
            var children        = this.children
            
            if (func.call(scope || this, this) === false) return false
            
            for (var i = 0; i < children.length; i++)
                if (children[ i ].each(func, scope) === false) return false
        },
        
        
        eachChild : function (func, scope) {
            var children        = this.children
            
            for (var i = 0; i < children.length; i++)
                if (func.call(scope, children[ i ]) === false) return false
        },
        
        
        toString : function () {
            return this.description
        },
        
        
        toJSON : function () {
            return {
                type        : this.meta.name,
                description : this.description
            }
        },
        
        
        findChildById : function (id) {
            var child
            
            this.each(function (node) {
                if (node.id == id) { child = node; return false } 
            })
            
            return child
        }
    },
    
    // used for self-testing when we need different ids for outer context and context being tested
    my : {
        methods     : {
            seedID : function (value) {
                ID          = value
            }
        }
    }
        
})


})();
Class('Siesta.Result.Diagnostic', {
    
    isa : Siesta.Result,
    
    has : {
        isWarning           : false
    },

    methods : {
        
        toString : function () {
            return '# ' + this.description
        },
        
        
        toJSON : function () {
            var info        = {
                type            : this.meta.name,
                description     : this.description
            }
            
            if (this.isWarning) info.isWarning = true
            
            return info
        }
    }    
});

;
Class('Siesta.Result.Summary', {
    
    isa         : Siesta.Result,
    
    has         : {
        isFailed            : false
    },
    
    methods : {
        
        // summary should belong only to the top level Siesta.Result.SubTest instance
        getTest : function () {
            return this.parent.test
        },
        
        
        toString : function () {
            
        }
    }    
});

;
Class('Siesta.Result.Assertion', {
    
    isa : Siesta.Result,
    

    has : {
        name        : null,
        
        passed      : null,
        
        annotation  : null,
        
        index       : null,
        // stored as string
        sourceLine  : null,
        
        isSkipped   : false,
        isTodo      : false,
        
        isException     : false,
        exceptionType   : null,
        
        isWaitFor   : false,
        completed   : false     // for waitFor assertions
    },
    
    
    methods : {
        
        isPassed : function (raw) {
            if (raw) return this.passed
            
            if (this.isTodo) return true
            
            if (this.isWaitFor && !this.completed) return true
            
            return this.passed
        },
        
        
        toString : function () {
            var text = (this.isTodo ? 'TODO: ' : '') + (this.passed ? 'ok ' : 'fail ') + this.index + ' - ' + this.description
            
            if (this.annotation) text += '\n' + this.annotation
            
            return text
        },
        
        
        toJSON : function () {
            var me      = this
            
            var info    = {
                type            : this.meta.name,
                passed          : this.passed,
                description     : this.description || 'No description'
            }
            
            // copy if true
            Joose.A.each([ 'isTodo', 'annotation', 'isWaitFor', 'isException', 'sourceLine', 'name' ], function (name) {
                if (me[ name ]) info[ name ] = me[ name ]
            })
            
            if (this.isException)   {
                info.exceptionType  = this.exceptionType
            }
            
            return info
        }
    }
})

;
Class('Siesta.Result.SubTest', {
    
    isa : Siesta.Result,
    

    has : {
        // reference to a test it belongs to
        // SubTests result instances will be set as `results` for sub tests instances
        test            : null
    },
    
    
    methods : {
        
        isWorking : function () {
            return !this.test.isFinished()
        },
        
        
        toJSON : function () {
            var test            = this.test
            
            // a flag that test instance does not belongs to the current context
            // this only happens during self-testing
            // if this is the case, in IE, calling any method from the test context will throw exception
            // "can't execute script from freed context", so we avoid calling any methods on the test in such case
            // accessing properties is ok though
            var isCrossContext  = !(test instanceof Object)
            
            var report      = {
                type            : this.meta.name,
                name            : test.name,
                
                startDate       : test.startDate,
                endDate         : test.endDate || (new Date() - 0),
                
                passed          : isCrossContext ? null : test.isPassed()
            }
            
            if (!test.parent)   report.url          = test.url
            if (test.specType)  report.bddSpecType  = test.specType
            
            var isFailed    = false
            var assertions  = []
            
            Joose.A.each(this.children, function (result) {
                if ((result instanceof Siesta.Result.Assertion) || (result instanceof Siesta.Result.Diagnostic) || (result instanceof Siesta.Result.SubTest)) {
                    var assertion   = result.toJSON()
                    
                    if (!assertion.passed && !assertion.isTodo) isFailed = true
                    
                    assertions.push(assertion)
                }
            })
            
            report.assertions       = assertions
            
            // see a comment above
            if (isCrossContext) {
                report.passed       = !(isFailed || test.failed || !test.endDate)
            }
            
            return report
        }
        
    }
})

;
/**
@class Siesta.Test.Function

This is a mixin, with helper methods for testing functionality relating to DOM elements. This mixin is consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Function', {
    
    methods : {
         /**
         * This assertion passes if the function is called at least one time during the test life span.
         * 
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} desc The description of the assertion.
         */
        isCalled : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 1, desc, true);
        },

        /**
         * This assertion passes if the function is called exactly one time during the test life span.
         *
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} desc The description of the assertion.
         */
        isCalledOnce : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 1, desc, false);
        },

        /**
         * This assertion passes if the function is called exactly (n) times during the test life span.
         * 
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {Number} n The expected number of calls
         * @param {String} desc The description of the assertion.
         */
        isCalledNTimes : function(fn, obj, n, desc, isGreaterEqual) {
            var me      = this,
                prop    = typeof fn === "string" ? fn : me.getPropertyName(obj, fn);
                
            desc        = desc ? (desc + ' ') : '';

            this.on('beforetestfinalizeearly', function () {
                if (counter === n || (isGreaterEqual && counter > n)) {
                    me.pass(desc || (prop + ' method was called exactly ' + n + ' times'));
                } else {

                    me.fail(desc || prop, {
                        assertionName       : 'isCalledNTimes ' + prop,
                        got                 : counter, 
                        need                : n ,
                        needDesc            : ("Need " + (isGreaterEqual ? 'at least ' : 'exactly '))
                    });
                }
            });

            var counter = 0;
            fn = obj[prop];
            obj[prop] = function () { counter++; return fn.apply(this, arguments); };
        },

        /**
         * This assertion passes if the function is not called during the test life span.
         * 
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {Number} n The expected number of calls
         * @param {String} desc The description of the assertion.
         */
        isntCalled : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 0, desc);
        },

        getPropertyName : function(host, obj) {
            for (var o in host) {
                if (host[o] === obj) return o;
            }
        },

        /**
         * This assertion passes when the supplied class method is called exactly (n) times during the test life span.
         * Under "class method" here we mean the function in the prototype. Note, that this assertion counts calls to the method in *any* class instance.
         * 
         * The `className` parameter can be supplied as a class constructor function or as a string, representing the class
         * name. In the latter case the `class` will be eval'ed to get a reference to the class constructor.
         * 
         * For example:

    StartTest(function (t) {
    
        function machine(type, version) {
            this.machineInfo = {
                type        : type,
                version     : version
            };
        };
        
        machine.prototype.update = function (type, version) {
            this.setVersion(type);
            this.setType(version);
        };
        
        machine.prototype.setVersion = function (data) {
            this.machineInfo.version = data;
        };
        
        machine.prototype.setType = function (data) {
            this.machineInfo.type = data;
        };
        
        t.methodIsCalled("setVersion", machine, "Checking if method 'setVersion' has been called");
        t.methodIsCalled("setType", machine, "Checking if method 'setType' has been called");
        
        var m = new machine('rover', '0.1.2');
        
        m.update('3.2.1', 'New Rover');
    });
    
         *
         * This assertion is useful when testing for example an Ext JS class where event listeners are added during
         * class instantiation time, which means you need to observe the prototype method before instantiation.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The constructor function or the name of the class that contains the method
         * @param {Number} n The expected number of calls
         * @param {String} desc The description of the assertion
         */
        methodIsCalledNTimes: function(fn, className, n, desc, isGreaterEqual){
            var me          = this,
                counter     = 0;

            desc            = desc ? (desc + ' ') : '';
            
            try {
                if (me.typeOf(className) == 'String') className = me.global.eval(className)
            } catch (e) {
                me.fail(desc, {
                    assertionName       : 'isMethodCalled',
                    annotation          : "Exception [" + e + "] caught, while evaluating the class name [" + className + "]"
                })

                return
            }

            var prototype   = className.prototype;
            var prop        = typeof fn === "string" ? fn : me.getPropertyName(prototype, fn);

            me.on('beforetestfinalizeearly', function () {
                if (counter === n || (isGreaterEqual && counter > n)) {
                    me.pass(desc || (prop + ' method was called exactly ' + n + ' times'));
                } else {
                    me.fail(desc || prop, {
                        assertionName       : 'isCalledNTimes ' + prop,
                        got                 : counter,
                        need                : n ,
                        needDesc            : ("Need " + (isGreaterEqual ? 'at least ' : 'exactly '))
                    });
                }
            });

            fn                  = prototype[ prop ];
            prototype[ prop ]   = function () { counter++; return fn.apply(this, arguments); };
        },

        /**
         * This assertion passes if the class method is called at least one time during the test life span.
         * 
         * See {@link #methodIsCalledNTimes} for more details.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The class constructor function or name of the class that contains the method
         * @param {String} desc The description of the assertion.
         */
        methodIsCalled : function(fn, className, desc) {
            this.methodIsCalledNTimes(fn, className, 1, desc, true);
        },

        /**
         * This assertion passes if the class method is not called during the test life span.
         * 
         * See {@link #methodIsCalledNTimes} for more details.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The class constructor function or name of the class that contains the method
         * @param {String} desc The description of the assertion.
         */
        methodIsntCalled : function(fn, className, desc) {
            this.methodIsCalledNTimes(fn, className, 0, desc);
        }
    }
});
;
/**
@class Siesta.Test.Date

A mixin with the additinal assertions for dates. Being consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Date', {
    
    methods : {
        
        isDateEq: function (got, expectedDate, description) {
            this.isDateEqual.apply(this, arguments);
        },

        
        /**
         * This assertion passes when the 2 provided dates are equal and fails otherwise.
         * 
         * It has a synonym: `isDateEq`
         * 
         * @param {Date} got The 1st date to compare
         * @param {Date} expectedDate The 2nd date to compare
         * @param {String} [description] The description of the assertion
         */
        isDateEqual: function (got, expectedDate, description) {
            if (got - expectedDate === 0) {
                this.pass(description, {
                    descTpl         : '{got} date is equal to {expectedDate}',
                    got             : got,
                    expectedDate    : expectedDate
                });
            } else {
                this.fail(description, {
                    assertionName   : 'isDateEqual',
                    
                    got         : got ? got.toString() : '',
                    gotDesc     : 'Got',
                    
                    need        : expectedDate.toString()
                });
            }
        }
    }
});
;
/**
@class Siesta.Test.More

A mixin with additional generic assertion methods, which can work cross-platform between browsers and NodeJS. 
Is being consumed by {@link Siesta.Test}, so all of them are available in all tests. 

*/
Role('Siesta.Test.More', {
    
    requires        : [ 'isFailed', 'typeOf', 'on' ],
    
    
    has : {
        autoCheckGlobals        : false,
        expectedGlobals         : Joose.I.Array,

        disableGlobalsCheck     : false,
        
        browserGlobals : { 
            init : [
                'console',
                'getInterface',
                'ExtBox1',
                '__IE_DEVTOOLBAR_CONSOLE_COMMAND_LINE',
                'seleniumAlert',
                'onload',
                'onerror', 
                'StartTest',
                'startTest',
                'describe',
                // will be reported in IE8 after overriding
                'setTimeout',
                'clearTimeout',
                'requestAnimationFrame',
                'cancelAnimationFrame',
                '__coverage__',
                /__cov_\d+/
            ]
        },
        
        /**
         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000. 
         */
        waitForTimeout          : 10000,
        
        waitForPollInterval     : 100
    },
    
    
    methods : {
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `>` operator will return `true` and fails otherwise. 
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} desc The description of the assertion
         */
        isGreater : function (value1, value2, desc) {
            if (value1 > value2)
                this.pass(desc, {
                    descTpl             : '`{value1}` is greater than `{value2}`',
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName   : 'isGreater',
                    
                    got         : value1,
                    need        : value2,
                    
                    needDesc    : "Need, greater than"
                })
        },
        
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `<` operator will return `true` and fails otherwise. 
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} desc The description of the assertion
         */
        isLess : function (value1, value2, desc) {
            if (value1 < value2)
                this.pass(desc, {
                    descTpl             : '`{value1}` is less than `{value2}`',
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName   : 'isLess',
                    
                    got         : value1,
                    need        : value2,
                    
                    needDesc    : "Need, less than"
                })
        },
        

        isGE : function () {
            this.isGreaterOrEqual.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `>=` operator will return `true` and fails otherwise. 
         * 
         * It has a synonym - `isGE`.
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} desc The description of the assertion
         */
        isGreaterOrEqual : function (value1, value2, desc) {
            if (value1 >= value2)
                this.pass(desc, {
                    descTpl             : '`{value1}` is greater or equal to `{value2}`',
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName   : 'isGreaterOrEqual',
                    
                    got         : value1,
                    need        : value2,
                    
                    needDesc    : "Need, greater or equal to"
                })
        },
        

        
        isLE : function () {
            this.isLessOrEqual.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `<=` operator will return `true` and fails otherwise. 
         * 
         * It has a synonym - `isLE`.
         * 
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} desc The description of the assertion
         */
        isLessOrEqual : function (value1, value2, desc) {
            if (value1 <= value2)
                this.pass(desc, {
                    descTpl             : '`{value1}` is less or equal to `{value2}`',
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName   : 'isLessOrEqual',
                    
                    got         : value1,
                    need        : value2,
                    
                    needDesc    : "Need, less or equal to"
                })
        },
        
        
        /**
         * This assertion suppose to compare the numeric values. It passes when the passed values are approximately the same (the difference 
         * is withing a threshold). A threshold can be provided explicitly (when assertion is called with 4 arguments), 
         * or it will be set to 5% from the 1st value (when calling assertion with 3 arguments).
         * 
         * @param {Number} value1 The 1st value to compare
         * @param {Number} value2 The 2nd value to compare
         * @param {Number} threshHold The maximum allowed difference between values. This argument can be omited. 
         * @param {String} desc The description of the assertion
         */
        isApprox : function (value1, value2, threshHold, desc) {
            if (arguments.length == 2) threshHold  = Math.abs(value1 * 0.05)
            
            if (arguments.length == 3) {
                if (this.typeOf(threshHold) == 'String') {
                    desc            = threshHold
                    threshHold      = Math.abs(value1 * 0.05)
                }
            }
            
            // this function normalizes the fractional numbers to fixed point presentation
            // for example in JS: 1.05 - 1 = 0.050000000000000044
            // so what we do is: (1.05 * 10^2 - 1 * 10^2) / 10^2 = (105 - 100) / 100 = 0.05
            var subtract    = function (value1, value2) {
                var fractionalLength    = function (v) {
                    var afterPointPart = (v + '').split('.')[ 1 ]
                    
                    return afterPointPart && afterPointPart.length || 0
                }
                
                var maxLength           = Math.max(fractionalLength(value1), fractionalLength(value2))
                var k                   = Math.pow(10, maxLength);

                return (value1 * k - value2 * k) / k;
            };            
            
            if (Math.abs(subtract(value2, value1)) <= threshHold)
                this.pass(desc, {
                    descTpl             : '`{value1}` is approximately equal to `{value2}`',
                    value1              : value1,
                    value2              : value2,
                    annotation          : value2 == value1 ? 'Exact match' : 'Match within treshhold: ' + threshHold
                })
            else
                this.fail(desc, {
                    assertionName       : 'isApprox', 
                    got                 : value1, 
                    need                : value2, 
                    needDesc            : 'Need approx',
                    annotation          : 'Threshold is: ' + threshHold
                })
        },
        
        
        /**
         * This assertion passes when the passed `string` matches to a regular expression `regex`. When `regex` is a string, 
         * assertion will check that it is a substring of `string`
         * 
         * @param {String} string The string to check for "likeness"
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} desc The description of the assertion
         */
        like : function (string, regex, desc) {
            if (this.typeOf(regex) == "RegExp")
            
                if (string.match(regex))
                    this.pass(desc, {
                        descTpl             : '`{string}` matches regexp {regex}',
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'like', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : 'Need string matching'
                    })
            else
             
                if (string.indexOf(regex) != -1)
                    this.pass(desc, {
                        descTpl             : '`{string}` has a substring: `{regex}`',
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'like', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : 'Need string containing'
                    })
        },
        
        /**
         * This method is the opposite of 'like', it adds failed assertion, when the string matches the passed regex.
         * 
         * @param {String} string The string to check for "unlikeness"
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} desc The description of the assertion
         */
        unlike : function(string, regex, desc) {
            if (this.typeOf(regex) == "RegExp")
            
                if (!string.match(regex))
                    this.pass(desc, {
                        descTpl             : '`{string}` does not match regexp {regex}',
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'unlike', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : 'Need string not matching'
                    })
            else
             
                if (string.indexOf(regex) == -1)
                    this.pass(desc, {
                        descTpl             : '`{string}` does not have a substring: `{regex}`',
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'unlike', 
                        got                 : string, 
                        need                : regex, 
                        needDesc            : 'Need string not containing'
                    })
        },
        
        
        "throws" : function () {
            this.throwsOk.apply(this, arguments)
        },
        
        throws_ok : function () {
            this.throwsOk.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the `func` function throws the exception during executing, and the
         * stringified exception passes the 'like' assertion (with 'expected' parameter).
         * 
         * It has synonyms - `throws_ok` and `throws`.
         * 
         * @param {Function} func The function which supposed to throw an exception
         * @param {String/RegExp} expected The regex against which to test the stringified exception, can be also a plain string
         * @param {String} desc The description of the assertion
         */
        throwsOk : function (func, expected, desc) {
            if (this.typeOf(func) != 'Function') throw new Error('throws_ok accepts a function as 1st argument')
            
            var e = this.getExceptionCatcher()(func)
            
            // assuming no one will throw undefined exception..
            if (e === undefined) {
                this.fail(desc, {
                    assertionName       : 'throws_ok', 
                    annotation          : 'Function did not throw an exception'
                })
                
                return
            }
            
            if (e instanceof this.getTestErrorClass())
                //IE uses non-standard 'description' property for error msg
                e = e.message || e.description
                
            e = '' + e
                
            if (this.typeOf(expected) == "RegExp")
            
                if (e.match(expected))
                    this.pass(desc, {
                        descTpl             : 'Function throws exception matching to {expected}',
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'throws_ok', 
                        got                 : e, 
                        gotDesc             : 'Exception stringifies to',
                        need                : expected, 
                        needDesc            : 'Need string matching'
                    })
            else
             
                if (e.indexOf(expected) != -1)
                    this.pass(desc, {
                        descTpl             : 'Function throws exception containing a substring: {expected}',
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'throws_ok', 
                        got                 : e, 
                        gotDesc             : 'Exception stringifies to',
                        need                : expected, 
                        needDesc            : 'Need string containing'
                    })
        },
        
        
        
        lives_ok : function () {
            this.livesOk.apply(this, arguments)
        },
        
        lives : function () {
            this.livesOk.apply(this, arguments)
        },
        
        /**
         * This assertion passes, when the supplied `func` function doesn't throw an exception during execution.
         * 
         * This method has two synonyms: `lives_ok` and `lives`
         * 
         * @param {Function} func The function which is not supposed to throw an exception
         * @param {String} desc The description of the assertion
         */
        livesOk : function (func, desc) {
            if (this.typeOf(func) != 'Function') {
                func = [ desc, desc = func ][ 0 ]
            }
            
            var e = this.getExceptionCatcher()(func)
            
            if (e === undefined) 
                this.pass(desc, {
                    descTpl             : 'Function does not throw any exceptions'
                })
            else
                this.fail(desc, {
                    assertionName       : 'lives_ok', 
                    annotation          : 'Function threw an exception: ' + e
                })
        },
        
        
        isa_ok : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },
        

        isaOk : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },
        
        /**
         * This assertion passes, when the supplied `value` is the instance of the `className`. The check is performed with
         * `instanceof` operator. The `className` parameter can be supplied as class constructor or as string, representing the class
         * name. In the latter case the `class` will eval'ed to receive the class constructor.
         * 
         * This method has synonyms: `isaOk`, `isa_ok`
         * 
         * @param {Mixed} value The value to check for 'isa' relationship
         * @param {Class/String} className The class to check for 'isa' relationship with `value`
         * @param {String} desc The description of the assertion
         */
        isInstanceOf : function (value, className, desc) {
            try {
                if (this.typeOf(className) == 'String') className = this.global.eval(className)
            } catch (e) {
                this.fail(desc, {
                    assertionName       : 'isa_ok', 
                    annotation          : "Exception [" + e + "] caught, while evaluating the class name [" + className + "]"
                })
                
                return
            }
            
            if (value instanceof className) 
                this.pass(desc, {
                    descTpl             : '{value} is an instance of correct class',
                    value               : value
                })
            else
                this.fail(desc, {
                    assertionName       : 'isa_ok', 
                    got                 : value, 
                    need                : String(className), 
                    needDesc            : 'Need, instance of'
                })
        },
        
        
        /**
         * This assertion passes, if supplied value is a String.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isString : function (value, desc) {
            if (this.typeOf(value) == 'String')
                this.pass(desc, {
                    descTpl     : '{value} is a string',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "A string value"
                })
        },
        
        
        /**
         * This assertion passes, if supplied value is an Object
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isObject : function (value, desc) {
            if (this.typeOf(value) == 'Object')
                this.pass(desc, {
                    descTpl     : '{value} is an object',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "An object value"
                })
        },
        

        /**
         * This assertion passes, if supplied value is an Array
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isArray : function (value, desc) {
            if (this.typeOf(value) == 'Array')
                this.pass(desc, {
                    descTpl     : '{value} is an array',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "An array value"
                })
        },


        /**
         * This assertion passes, if supplied value is a Number.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isNumber : function (value, desc) {
            if (this.typeOf(value) == 'Number')
                this.pass(desc, {
                    descTpl     : '{value} is a number',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "A number value"
                })
        },


        /**
         * This assertion passes, if supplied value is a Boolean.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isBoolean : function (value, desc) {
            if (this.typeOf(value) == 'Boolean')
                this.pass(desc, {
                    descTpl     : '{value} is a boolean',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "A boolean value"
                })
        },

        
        /**
         * This assertion passes, if supplied value is a Date.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isDate : function (value, desc) {
            if (this.typeOf(value) == 'Date')
                this.pass(desc, {
                    descTpl     : '{value} is a date',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "A date value"
                })
        },

        
        /**
         * This assertion passes, if supplied value is a RegExp.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isRegExp : function (value, desc) {
            if (this.typeOf(value) == 'RegExp')
                this.pass(desc, {
                    descTpl     : '{value} is a regular expression',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "A regular expression value"
                })
        },
        
        
        /**
         * This assertion passes, if supplied value is a Function.
         * 
         * @param {Mixed} value The value to check.
         * @param {String} desc The description of the assertion
         */
        isFunction : function (value, desc) {
            if (this.typeOf(value) == 'Function')
                this.pass(desc, {
                    descTpl     : '{value} is a function',
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : "A function value"
                })
        },        
        
        
        is_deeply : function (obj1, obj2, desc) {
            this.isDeeply.apply(this, arguments)
        },
        
        /**
         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with '==' operator, so `[ 1 ]` and `[ "1" ] objects will be equal. The objects should not contain cyclic references.
         * 
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         * 
         * This method has a synonym: `is_deeply`
         * 
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} desc The description of the assertion
         */
        isDeeply : function (obj1, obj2, desc) {
            if (this.typeOf(obj1) === this.typeOf(obj2) && this.compareObjects(obj1, obj2))
                this.pass(desc, {
                    descTpl             : '{obj1} is deeply equal to {obj2}',
                    obj1                : obj1,
                    obj2                : obj2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isDeeply', 
                    got                 : obj1, 
                    need                : obj2 
                })
        },
        
        
        /**
         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with '===' operator, so `[ 1 ]` and `[ "1" ] objects will be different. The objects should not contain cyclic references.
         * 
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         * 
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} desc The description of the assertion
         */
        isDeeplyStrict : function (obj1, obj2, desc) {
            if (this.typeOf(obj1) === this.typeOf(obj2) && this.compareObjects(obj1, obj2, true))
                this.pass(desc, {
                    descTpl             : '{obj1} is strictly deeply equal to {obj2}',
                    obj1                : obj1,
                    obj2                : obj2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isDeeplyStrict', 
                    got                 : obj1, 
                    need                : obj2 
                })
        },
        
        expectGlobal : function () {
            this.expectGlobals.apply(this, arguments)
        },
        
        
        /**
         * This method accepts a variable number of names of expected properties in the global scope. When verifying the globals with {@link #verifyGlobals}
         * assertions, the expected gloabls will not be counted as failed assertions.
         * 
         * This method has a synonym with singular name: `expectGlobal`
         * 
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        expectGlobals : function () {
            this.expectedGlobals.push.apply(this.expectedGlobals, arguments)
        },
        
        
        /**
         * This method accepts a variable number of names of expected properties in the global scope and then performs a globals check. 
         *
         * It will scan all globals properties in the scope of test and compare them with the list of expected globals. Expected globals can be provided with:
         * {@link #expectGlobals} method or {@link Siesta.Harness#expectedGlobals expectedGlobals} configuration option of harness.
         * 
         * You can enable this assertion to automatically happen at the end of each test, using {@link Siesta.Harness#autoCheckGlobals autoCheckGlobals} option of the harness.
         * 
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        verifyGlobals : function () {
            if (this.disableGlobalsCheck) {
                this.diag('Testing leakage of global variables is not supported on this platform')
                
                return
            }
            
            this.expectGlobals.apply(this, arguments)
            
            var me                  = this
            var expectedStrings     = {}
            var expectedRegExps     = []
            
            Joose.A.each(this.expectedGlobals.concat(this.browserGlobals), function (value) {
                if (me.typeOf(value) == 'RegExp')
                    expectedRegExps.push(value)
                else
                    expectedStrings[ value ] = true 
            })
            
            this.diag('Global variables')
            
            var failed              = false
            
            for (var name in this.global) {
                if (expectedStrings[ name ]) continue
                
                var isExpected      = false
                
                for (var i = 0; i < expectedRegExps.length; i++) {
                    if (expectedRegExps[ i ].test(name)) {
                        isExpected = true
                        break
                    }
                }
                
                if (!isExpected) {
                    me.fail('Unexpected global found', 'Global name: ' + name + ', value: ' + Siesta.Util.Serializer.stringify(this.global[name]))
                    
                    failed      = true
                }
            }
            
            if (!failed) this.pass('No unexpected global variables found')
        },
        
        
        // will create a half-realized, "phantom", "isWaitFor" assertion, which is only purposed
        // for user to get the instant feedback about "waitFor" actions
        // this assertion will be "finalized" and added to the test results in the "finalizeWaiting"
        startWaiting : function (description, sourceLine) {
            var result = new Siesta.Result.Assertion({
                description     : description,
                isWaitFor       : true,
                sourceLine      : sourceLine
            });
            
            this.fireEvent('testupdate', this, result, this.getResults())
            
            return result;
        },
        
        
        finalizeWaiting : function (result, passed, desc, annotation, errback) {
            // Treat this is an ordinary assertion from now on
            result.completed = true;
            
            if (passed)
                this.pass(desc, annotation, result)
            else {
                this.fail(desc, annotation, result);
                
                errback && errback()
            }
        },
        
        
        /**
         * Waits for passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * As an additional feature, the callback will receive the result from the checker method as the 1st argument.
         * 

    t.waitFor(
        function () { return document.getElementById('someEl') },
        function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument "el"
        }
    })

         * You can also call this method with a single Object having the following properties: `method`, `callback`, `scope`, `timeout`, `interval`:

    t.waitFor({
        method      : function () { return document.getElementById('someEl') },
        callback    : function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument "el"
        }
    })

         * 
         * @param {Object/Function/Number} method Either a function which should return true when a certain condition has been fulfilled, or a number of ms to wait before calling the callback. 
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled. 
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test. 
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         * 
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback). 
         * No call to checker will be performed and callback will not receive a result from it. 
         */
        waitFor : function (method, callback, scope, timeout, interval)  {
            var description         = ' condition to be fullfilled';
            var assertionName       = 'waitFor';
            var errback

            if (arguments.length === 1 && this.typeOf(method) == 'Object') {
                var options     = method;
                
                method          = options.method;
                callback        = options.callback;
                scope           = options.scope;
                timeout         = options.timeout;
                interval        = options.interval
                
                description     = options.description || description;
                assertionName   = options.assertionName || assertionName;
                
                // errback is called in case "waitFor" has failed
                errback         = options.errback
            }
            
            var isWaitingForTime        = this.typeOf(method) == 'Number'

            var description             = isWaitingForTime ? (method + ' ms') : description;
            var me                      = this;
            
            callback                    = callback || function () {}
            
            var sourceLine              = me.getSourceLine();
            var originalSetTimeout      = me.originalSetTimeout;
            var originalClearTimeout    = me.originalClearTimeout;
            var pollTimeout
            
            // early notification about the started "waitFor" operation
            var waitAssertion           = me.startWaiting('Waiting for ' + description, sourceLine);
            
            interval                    = interval || this.waitForPollInterval
            timeout                     = timeout || this.waitForTimeout
            
            // this async frame not supposed to fail, because its delayed to `timeout + 3 * interval`
            // failure supposed to be generated in the "pollFunc" and this async frame to be closed
            // however, in IE it happens that async frame may end earlier than failure from "pollFunc"
            // in such case we report same error as in "pollFunc"
            var async                   = this.beginAsync((isWaitingForTime ? method : timeout) + 3 * interval, function () {
                originalClearTimeout(pollTimeout)
                
                me.finalizeWaiting(waitAssertion, false, 'Waited too long for: ' + description, {
                    assertionName       : assertionName,
                    annotation          : 'Condition was not fullfilled during ' + timeout + 'ms'
                }, errback)
                
                return true
            })
            
            var isDone      = false

            // stop polling, if this test instance has finalized (probably because of exception)
            this.on('beforetestfinalize', function () {
                if (!isDone) {
                    isDone      = true
                    
                    me.finalizeWaiting(waitAssertion, false, 'Waiting aborted');
                    me.endAsync(async)
                    
                    originalClearTimeout(pollTimeout)
                }
            }, null, { single : true })

            if (isWaitingForTime) {
                pollTimeout = originalSetTimeout(function() {
                    isDone      = true
                    
                    me.finalizeWaiting(waitAssertion, true, 'Waited ' + method + ' ms');
                    me.endAsync(async);
                    me.processCallbackFromTest(callback, [], scope || me)
                }, method);
                
            } else {
            
                var startDate   = new Date()
            
                var pollFunc    = function () {
                    var time = new Date() - startDate;
                    
                    if (time > timeout) {
                        me.endAsync(async);

                        me.finalizeWaiting(waitAssertion, false, 'Waited too long for: ' + description, {
                            assertionName       : assertionName,
                            annotation          : 'Condition was not fullfilled during ' + timeout + 'ms'
                        }, errback)
                        
                        isDone      = true
                    
                        return
                    }
                
                    try {
                        var result = method.call(scope || me);
                    } catch (e) {
                        me.endAsync(async);
                    
                        me.finalizeWaiting(waitAssertion, false, assertionName + ' checker threw an exception', {
                            assertionName       : assertionName,
                            got                 : e.toString(),
                            gotDesc             : "Exception"
                        }, errback)
                    
                        isDone      = true
                        
                        return
                    }
                
                    if (result != null && result !== false) {
                        me.endAsync(async);
                        
                        isDone      = true
                        
                        me.finalizeWaiting(waitAssertion, true, 'Waited ' + time + ' ms for ' + description);
                        
                        me.processCallbackFromTest(callback, [ result ], scope || me)
                    } else 
                        pollTimeout = originalSetTimeout(pollFunc, interval)
                }
            
                pollFunc()
            }
            
            return {
                force : function () {
                    // wait operation already completed 
                    if (isDone) return
                    
                    isDone      = true
                    
                    originalClearTimeout(pollTimeout)
                    
                    me.endAsync(async);
                    
                    me.finalizeWaiting(waitAssertion, true, 'Forced finalization of waiting for ' + description);
                    
                    me.processCallbackFromTest(callback, [], scope || me)
                }
            }
        },

        /**
         * Waits for the number of a number millseconds and calls the callback when after waiting. This is just a convenience synonym for the {@link #waitFor} method.

         t.waitForMs(1500, callback)

         *
         * @param {Number} method The number of ms to wait before calling the callback.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForMs : function() {
            return this.waitFor.apply(this, arguments);
        },
        

        /**
         * Waits for the passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * This is just a convenience synonym for the {@link #waitFor} method.
         *

         t.waitForFn(function() { return true; }, callback)

         *
         * @param {Function} fn The checker function.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForFn : function() {
            return this.waitFor.apply(this, arguments);
        },
        
        // takes the step function and tries to analyze if it is missing the call to "next"
        // returns "true" if "next" is used, 
        analyzeChainStep : function (func) {
            var sources         = func.toString()
            var firstArg        = sources.match(/function\s*[^(]*\(\s*(.*?)\s*(?:,|\))/)[ 1 ]
                        
            if (!firstArg) return false
            
            var body            = sources.match(/\{([\s\S]*)\}/)[ 1 ]
            
            return body.indexOf(firstArg) != -1
        },
        
        
        /**
         * This method accept either variable number of arguments (steps) or the array of them. 
         * Each step should be either a function or configuration object for test actions. 
         * These functions / actions will be executed in order.
         * 
         * 1) If step is a function, as the 1st argument, it will receive a callback to call when the step is completed. 
         * As the 2nd and further arguments, the step function will receive the arguments passed to the previous callback.
         * 
         * The last step will receive a no-op callback, which can be ignored or still called. **Note**, that last step is assumed to
         * complete synchronously! If you need to launch some asynchronous process in the last step, you may need to add another empty function step
         * to the end of the chain.
         * 
         * 2) If a step is presented with action configuration object, then the callback will be called by the action class automatically,
         * there's no need to provide any. Configuration object should contain the "action" property, specifying the action class 
         * and some other config options (depending from the action class). For brevity, instead of "action" property, configuration 
         * object may contain the property corresponding to the action name itself, with the action's target. See the following examples and also
         * refer to the documentation of the action classes. 
         * 
         * If configuration object will contain a "desc" property, a passing assertion with it value will be added to the test, after this step completion.
         * 
         * 3) If step is a sub test instance, created with {@link #getSubTest} method, then step will launch it.
         * 
         * Its better to see how it works on the example. For example, when using using only functions:
         
    t.chain(
        // function receives a callback as 1st argument
        function (next) {
            // we pass that callback to the "click" method
            t.click(buttonEl, next)
        },
        function (next) {
            t.type(fieldEl, 'Something', next)
        },
        function (next) {
            t.is(fieldEl.value == 'Something', 'Correct value in the field')
            
            // call the callback with some arguments
            next('foo', 'bar')  
        }, 
        // those arguments are now available as arguments of next step
        function (next, value1, value2) {
            t.is(value1, 'foo', 'The arguments for the callback are translated to the arguments of the step')
            t.is(value2, 'bar', 'The arguments for the callback are translated to the arguments of the step')
        }
    )

         * 
         * The same example, using action configuration objects for first 2 steps. For the list of available actions please refer to the classes in the Siesta.Test.Action namespace.
         
    t.chain(
        {
            action      : 'click',
            target      : buttonEl,
            desc        : "Clicked on the button"
        },
        // or
        {
            click       : buttonEl,
            desc        : "Clicked on the button"
        },

        {
            action      : 'type',
            target      : fieldEl,
            text        : 'Something',
            desc        : "Typed in the field"
        },
        // or
        {
            type        : 'Something',
            target      : fieldEl,
            desc        : "Typed in the field"
        },
        
        
        function (next) {
            t.is(fieldEl.value == 'Something', 'Correct value in the field')
            
            next('foo', 'bar')  
        }, 
        ...
    )
    
         * Please note, that by default, each step is expected to complete within the {@link Siesta.Harness#defaultTimeout} time. 
         * You can change this with the `timeout` property of the step configuration object, allowing some steps to last longer.
         * Steps with sub-tests are expected to complete within {@link Siesta.Harness#subTestTimeout}.
         * 
         * In a special case, `action` property of the step configuration object can be a function. In this case you can also 
         * provide a `timeout` property, otherwise this case is identical to using functions:
         *  

    t.chain(
        {
            action      : function (next) { ... },
            // allow 50s for the function to call "next" before step will be considered timed-out
            timeout     : 50000
        },
        ...
    )
    
         *  **Tip**:
         *  
         *  If step is presented with a `null` or `undefined` value it will be ignored. Additionally, the step may be presented 
         *  with an array of steps - all arrays in the input will be flattened.
         *  
         *  These tips allows us to implement conditional steps processing, like this:
         *  

    var el1IsInDom          = t.$('.some-class1')[ 0 ]
    var el2IsInDom          = t.$('.some-class2')[ 0 ]
    
    t.chain(
        { click : '.some-other-el' },
        
        el1IsInDom ? [
            { click : el1IsInDom },
            
            el2IsInDom ? [
                { click : el1IsInDom },
            ] : null,
        ] : null,
        
        ...
    )

         *  
         *  @param {Function/Object/Array} step1 The function to execute or action configuration, or the array of such
         *  @param {Function/Object} step2 The function to execute or action configuration
         *  @param {Function/Object} stepN The function to execute or action configuration
         */
        chain : function () {
            // inline any arrays in the arguments into one array
            var steps       = this.flattenArray(arguments)
            
            var nonEmpty    = []
            Joose.A.each(steps, function (step) { if (step) nonEmpty.push(step) })
            
            steps           = nonEmpty
            
            var len         = steps.length
            
            // do nothing
            if (!len) return;
            
            var me          = this
            var self        = arguments.callee
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : self.hasOwnProperty('actionDelay') ? self.actionDelay : this.actionDelay,
                
                observeTest     : this
            })
            
            // hack to allow configuration of `actionDelay`...
            delete self.actionDelay
            
            var sourceLine  = me.getSourceLine();
            
            var args        = []
            
            Joose.A.each(steps, function (step, index) {
                
                var isLast      = index == len - 1
                
                queue.addAsyncStep({
                    processor : function (data) {
                        var isStepWithOwnAsyncFrame  = step.action == 'wait' || step.waitFor || (step instanceof Siesta.Test)
                        
                        if (!isStepWithOwnAsyncFrame) {
                            var timeout     = step.timeout || me.defaultTimeout
                            
                            // + 100 to allow `waitFor` steps (which will be waiting the `timeout` time) to
                            // generate their own failures
                            var async       = me.beginAsync(timeout + 100, function () {
                                me.fail(
                                    'The step in `t.chain()` call did not complete within required timeframe, chain can not proceed',
                                    {
                                        sourceLine      : sourceLine,
                                        annotation      : 'Step number: ' + (index + 1) + ' (1-based)' + (sourceLine ? '\nAt line    : ' + sourceLine : ''),
                                        ownTextOnly     : true
                                    }
                                )
                                
                                return true
                            })
                        }
                        
                        var nextFunc    = function () {
                            if (!isStepWithOwnAsyncFrame) me.endAsync(async)
                            
                            args    =  Array.prototype.slice.call(arguments);
                            
                            if (step.desc) {
                                me.pass(step.desc);
                            }
                            data.next()
                        }
                        
                        if (step instanceof Siesta.Test) {
                            me.launchSubTest(step, nextFunc)
                        } else if (me.typeOf(step) == 'Function' || me.typeOf(step.action) == 'Function') {
                            var func    = me.typeOf(step) == 'Function' ? step : step.action
                            
                            // if the last step is a function - then provide "null" as the "next" callback for it
                            args.unshift(isLast ? function () {} : nextFunc)
                            
                            if (!isLast && !me.analyzeChainStep(func)) me.fail('Step function [' + func.toString() + '] does not use provided "next" function anywhere')
                            
                            if (me.transparentEx)
                                func.apply(me, args)
                            else {
                                var e = me.getExceptionCatcher()(function () {
                                    func.apply(me, args)
                                })
                                
                                if (e !== undefined) {
                                    me.fail("Chain step threw an exception", { annotation : e + '' })
                                }
                            }
                            
                            // and finalize the async frame manually, as the "nextFunc" for last step will never be called
                            isLast && me.endAsync(async)
                            
                        } else if (me.typeOf(step) == 'String') {
                            var action      = new Siesta.Test.Action.Eval({
                                actionString        : step,
                                next                : nextFunc,
                                test                : me
                            })
                            
                            action.process()
                            
                        } else {
                            if (!step.args) step.args   = args
                            
                            // Don't pass target to next step if it is a waitFor action, it does not make sense and messes up the arguments
                            if (!isLast && (steps[ index + 1 ].waitFor || steps[ index + 1 ].action == 'wait')) {
                                step.passTargetToNext = false;
                            }

                            step.next       = nextFunc
                            step.test       = me
                            
                            var action      = Siesta.Test.ActionRegistry().create(step)
                            
                            action.process()
                        }
                    } 
                })
            })
            
            queue.run()
        }
    },
    
    
    after : {
        
        initialize        : function () {
            
            this.on('beforetestfinalize', function () {
                
                if (this.autoCheckGlobals && !this.isFailed() && !this.parent) this.verifyGlobals()
                
            }, this)
        }
    }
        
})
//eof Siesta.Test.More
;
Role('Siesta.Test.Role.Placeholder', {
    
    requires    : [
        'equalsTo'
    ]
})
;
Class('Siesta.Test.BDD.Placeholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        clsConstructor  : { required : true },
        t               : null,
        context         : null,
        
        globals         : {
            init            : [
                'String',
                'Boolean',
                'Number',
                'Date',
                'RegExp',
                'Function',
                'Array',
                'Object'
            ]
        }
    },
    
    
    methods     : {
        
        getClassName : function (onlyGlobals) {
            var clsConstructor      = this.getClassConstructor()
            var context             = this.context

            var clsName
            
            Joose.A.each(this.globals, function (property) {
                if (clsConstructor == context[ property ]) { clsName = property; return false }    
            })
            
            return onlyGlobals ? clsName : clsName || clsConstructor + ''
        },
        
        
        getClassConstructor : function () {
            return this.clsConstructor
        },
        
        
        equalsTo : function (value) {
            var clsConstructor      = this.getClassConstructor()
            
            if (!clsConstructor) return true
            
            if (value instanceof Siesta.Test.BDD.Placeholder) {
                var ownClassName    = this.getClassName(true)
                
                if (
                    value.getClassName(true) == 'Object' && (
                        ownClassName == 'Date' ||
                        ownClassName == 'RegExp' ||
                        ownClassName == 'Function'||
                        ownClassName == 'Array'
                    )
                ) {
                    return true
                }
                
                return clsConstructor == value.getClassConstructor()
            }
            
            var isEqual             = false
            
            var globalCls           = this.getClassName(true)
            
            if (globalCls)
                isEqual             = this.t.typeOf(value) == globalCls || (value instanceof this.context[ globalCls ])
            
            return isEqual || (value instanceof clsConstructor)
        },
        
        
        toString : function () {
            return 'any ' + this.getClassName()
        }
    }
})
;
Class('Siesta.Test.BDD.NumberPlaceholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        value           : { required : true },
        threshold       : null
    },
    
    
    methods     : {
        
        initialize : function () {
            if (this.threshold == null) this.threshold = this.value * 0.05
        },
        
        
        equalsTo : function (value) {
            return Math.abs(value - this.value) <= this.threshold
        },
        
        
        toString : function () {
            return 'any number approximately equal to ' + this.value
        }
    }
})
;
/**
@class Siesta.Test.BDD.Expectation

This class is a central point for writing assertions in the BDD style. Instances of this class can be generated with the {@link Siesta.Test#expect expect}
method. Then, calling some method on the instance will create a new assertion in the test.

* **Note**, that to negate any assertion, you can use a special property {@link #not}, that also contains an expectation instance, but with the opposite meaning.

For example:

    t.expect(1).toBe(1)
    t.expect(1).not.toBe(2)
    
    t.expect('Foo').toContain('oo')
    t.expect('Foo').not.toContain('bar')


*/
Class('Siesta.Test.BDD.Expectation', {
    
    has         : {
        value           : null,
        
        isNot           : false,
        
        /**
         * @property {Siesta.Test.BDD.Expectation} not Another expectation instance with the negated meaning. 
         */
        not             : null,
        
        t               : null
    },
    
    
    methods     : {
        
        initialize : function () {
            if (!this.isNot) this.not = new this.constructor({
                isNot           : true,
                t               : this.t,
                
                value           : this.value
            })
        },
        
        
        process : function (passed, config) {
            var isNot       = this.isNot
            config          = config || {}
            
            config.not      = config.not || isNot ? 'not ' : ''
            config.got      = config.hasOwnProperty('got') ? config.got : this.value
            
            if (config.noGot) delete config.got
            
            var assertionName   = config.assertionName
            
            if (assertionName && isNot) config.assertionName = assertionName.replace(/^(expect\(.+?\)\.)/, '$1not.')
            
            passed          = isNot ? !passed : passed
            
            this.t[ passed ? 'pass' : 'fail' ](null, config)
        },
        
        
        /**
         * This assertion compares the value provided to the {@link Siesta.Test#expect expect} method with the `expectedValue` argument.
         * Comparison is done with `===` operator, so it should be used only with the primitivies - numbers, strings, booleans etc.
         * To deeply compare JSON objects and arrays, use {@link #toEqual} method.
         * 
         * This method works correctly with the placeholders generated with {@link Siesta.Test#any any} method
         * 
         * @param {Primitive} expectedValue An expected value 
         */
        toBe : function (expectedValue) {
            this.process(this.t.compareObjects(this.value, expectedValue, true, true), {
                descTpl             : 'Expect {got} {!not}to be {need}',
                assertionName       : 'expect(got).toBe(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? 'Need not' : 'Need'
            })
        },
        
        
        /**
         * This assertion compares the value provided to the {@link Siesta.Test#expect expect} method with the `expectedValue` argument.
         * Comparison works for JSON objects and/or arrays, it is performed "deeply". Right now the values should not contain cyclic references.
         * 
         * This method works correctly with the placeholders generated with {@link Siesta.Test#any any} method
         * 
         * @param {Mixed} expectedValue An expected value 
         */
        toEqual : function (expectedValue) {
            this.process(this.t.compareObjects(this.value, expectedValue, true), {
                descTpl             : 'Expect {got} {!not}to be equal to {need}',
                assertionName       : 'expect(got).toEqual(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? 'Need not' : 'Need'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is `null`.
         */
        toBeNull : function () {
            this.process(this.t.compareObjects(this.value, null, true, true), {
                descTpl             : 'Expect {got} {!not}to be null',
                assertionName       : 'expect(got).toBeNull()',
                need                : null,
                needDesc            : this.isNot ? 'Need not' : 'Need'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is `NaN`.
         */
        toBeNaN : function () {
            var value   = this.value
            
            this.process(this.t.typeOf(value) == 'Number' && value != value, {
                descTpl             : 'Expect {got} {!not}to be NaN',
                assertionName       : 'expect(got).toBeNaN()',
                need                : NaN,
                needDesc            : this.isNot ? 'Need not' : 'Need'
            })
        },

        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is not the `undefined` value.
         */
        toBeDefined : function () {
            this.process(this.value !== undefined, {
                descTpl             : 'Expect {got} {!not}to be defined',
                assertionName       : 'expect(got).toBeDefined()'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is the `undefined` value.
         */
        toBeUndefined : function (value) {
            this.process(this.value === undefined, {
                descTpl             : 'Expect {got} {!not}to be undefined',
                assertionName       : 'expect(got).toBeUndefined()'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is "truthy" - evaluates to `true`.
         * For example - non empty strings, numbers except the 0, objects, arrays etc.
         */
        toBeTruthy : function () {
            this.process(this.value, {
                descTpl             : 'Expect {got} {!not}to be truthy',
                assertionName       : 'expect(got).toBeTruthy()'
            })
        },
        
        
        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is "falsy" - evaluates to `false`.
         * For example - empty strings, number 0, `null`, `undefined`, etc.
         */
        toBeFalsy : function () {
            this.process(!this.value, {
                descTpl             : 'Expect {got} {!not}to be falsy',
                assertionName       : 'expect(got).toBeFalsy()'
            })
        },
        
        
        /**
         * This assertion passes, when the string provided to the {@link Siesta.Test#expect expect} method matches the regular expression.
         * 
         * @param {RegExp} regexp The regular expression to match the string against
         */
        toMatch : function (regexp) {
            if (this.t.typeOf(regexp) != 'RegExp') throw new Error("`expect().toMatch()` matcher expects a regular expression")
            
            this.process(new RegExp(regexp).test(this.value), {
                descTpl             : 'Expect {got} {!not}to match {need}',
                assertionName       : 'expect(got).toMatch(need)',
                need                : regexp,
                needDesc            : this.isNot ? 'Need not matching' : 'Need matching'
            })
        },
        
        
        /**
         * This assertion passes in 2 cases:
         * 
         * 1) When the value provided to the {@link Siesta.Test#expect expect} method is a string, and it contains a passed substring.
         * 2) When the value provided to the {@link Siesta.Test#expect expect} method is an array (or array-like), and it contains a passed element.
         * 
         * @param {String/Mixed} element The element of the array or a sub-string
         */
        toContain : function (element) {
            var value       = this.value
            var t           = this.t
            
            var passed      = false

            if (t.typeOf(value) == 'String') {
                this.process(value.indexOf(element) >= 0, {
                    descTpl             : 'Expect {got} {!not}to contain {need}',
                    assertionName       : 'expect(got).toContain(need)',
                    need                : element,
                    needDesc            : this.isNot ? 'Need string not containing' : 'Need string containing'
                })
            } else {
                // Normalize to allow NodeList, Arguments etc.
                value = Array.prototype.slice.call(value);

                for (var i = 0; i < value.length; i++)
                    if (t.compareObjects(element, value[ i ], true)) {
                        passed      = true
                        break
                    }

                this.process(passed, {
                    descTpl             : 'Expect {got} {!not}to contain {need}',
                    assertionName       : 'expect(got).toContain(need)',
                    need                : element,
                    needDesc            : this.isNot ? 'Need array not containing' : 'Need array containing'
                })

            }
        },
        
        
        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is less than the
         * expected number.
         * 
         * @param {Number} expectedValue The number to compare with
         */
        toBeLessThan : function (expectedValue) {
            this.process(this.value < expectedValue, {
                descTpl             : 'Expect {got} {!not}to be less than {need}',
                assertionName       : 'expect(got).toBeLessThan(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? 'Need value bigger or equal than' : 'Need value less than'
            })
        },
        
        
        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is greater than the
         * expected number.
         * 
         * @param {Number} expectedValue The number to compare with
         */
        toBeGreaterThan : function (expectedValue) {
            this.process(this.value > expectedValue, {
                descTpl             : 'Expect {got} {!not}to be greater than {need}',
                assertionName       : 'expect(got).toBeGreaterThan(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? 'Need value less or equal than' : 'Need value greater than'
            })
        },
        
        
        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is approximately equal
         * the given number. The proximity can be defined as the `precision` argument  
         * 
         * @param {Number} expectedValue The number to compare with
         * @param {Number} [precision=2] The number of digits after dot (comma) that should be same in both numbers.
         */
        toBeCloseTo : function (expectedValue, precision) {
            precision       = precision != null ? precision : 2
            
            // not sure why we divide the precision by 2, but jasmine does that for some reason
            var threshold   = Math.pow(10, -precision) / 2
            var delta       = Math.abs(this.value - expectedValue)
            
            this.process(delta < threshold, {
                descTpl             : 'Expect {got} {!not}to be close to {need}',
                assertionName       : 'expect(got).toBeCloseTo(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? 'Need value not close to' : 'Need value close to',
                annotation          : delta ? "Threshold is " + threshold : 'Exact match'
            })        
        },
        
        
        /**
         * This assertion passes when the function, provided to the {@link Siesta.Test#expect expect} method, throws any exception
         * during its execution.
         */
        toThrow : function () {
            var func    = this.value
            var t       = this.t
            
            if (t.typeOf(func) != 'Function') throw new Error("`expect().toMatch()` matcher expects a function")
            
            var e       = t.getExceptionCatcher()(func)
            
            if (e instanceof t.getTestErrorClass())
                //IE uses non-standard 'description' property for error msg
                e = e.message || e.description
                
            this.process(e !== undefined, {
                descTpl             : 'Expect function {!not}to throw exception',
                assertionName       : 'expect(func).toThrow()',
                annotation          : e ? "Thrown exception: " + Siesta.Util.Serializer.stringify(e) : 'No exception thrown',
                
                noGot               : true
            })
        },
        
        
        // TODO
        toHaveBeenCalled : function () {
        },
        
        
        // TODO
        toHaveBeenCalledWith : function () {
        }
    }
})
;
/**
@class Siesta.Test.BDD

A mixin providing a BDD style layer for most of the assertion methods.
It is consumed by {@link Siesta.Test}, so all of its methods are available in all tests. 

*/
Role('Siesta.Test.BDD', {
    
    requires    : [
        'getSubTest', 'chain'
    ],
    
    has         : {
        specType                : null, // `describe` or `it`
        
        sequentialSubTests      : Joose.I.Array,
        
        // flag, whether the "run" function of the test (containing actual test code) have been already run
        codeProcessed           : false,
        
        launchTimeout           : null,
        
        // Siesta.Test.BDD.Expectation should already present on the page
        expectationClass        : Siesta.Test.BDD.Expectation
    },
    
    
    methods     : {
        
        checkSpecFunction : function (func, type, name) {
            if (!func)          throw new Error("Code body is not provided for " + (type == 'describe' ? 'suite' : 'spec') + ' [' + name + ']')
            if (!func.length)   throw new Error("Code body of " + (type == 'describe' ? 'suite' : 'spec') + ' [' + name + '] does not declare a test instance as 1st argument')
        },
        
        
        /**
         * This is an "exclusive" version of the regular {@link #describe} suite. When such suites presents in some test file,
         * the other regular suites at the same level will not be executed, only "exclusive" ones.
         * 
         * @param {String} name The name or description of the suite
         * @param {Function} code The code function for this suite. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this suite. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        ddescribe : function (name, code, timeout) {
            this.describe(name, code, timeout, true)
        },
        
        
        /**
         * This is a no-op method, allowing you to quickly ignore some suites. 
         */
        xdescribe : function () {
        },
        
        
        /**
         * This method starts a sub test with *suite* (in BDD terms). Such suite consists from one or more *specs* (see method {@link #it}} or other suites.
         * The number of nesting levels is not limited. All suites of the same nesting level are executed sequentially. 
         * 
         * For example:
         * 
    t.describe('A product', function (t) {
    
        t.it('should have feature X', function (t) {
            ...
        })
        
        t.describe('feature X', function (t) {
            t.it('should be cool', function (t) {
                ...
            })
        })
    })
         *
         * See also {@link #xdescribe}, {@link #ddescribe}
         * 
         * @param {String} name The name or description of the suite
         * @param {Function} code The code function for this suite. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this suite. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        describe : function (name, code, timeout, isExclusive) {
            this.checkSpecFunction(code, 'describe', name)
            
            var subTest     = this.getSubTest({
                name            : name,
                run             : code,
                
                isExclusive     : isExclusive,
                
                specType        : 'describe',
                timeout         : timeout
            })
            
            if (this.codeProcessed) this.scheduleSpecsLaunch()
            
            this.sequentialSubTests.push(subTest)
        },
        
        
        /**
         * This is an "exclusive" version of the regular {@link #it} spec. When such specs presents in some suite,
         * the other regular specs at the same level will not be executed, only "exclusive" ones. Note, that even "regular" suites (`t.describe`) sections
         * will be ignored, if they are on the same level with the exclusive `iit` section.
         * 
         * @param {String} name The name or description of the spec
         * @param {Function} code The code function for this spec. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this spec. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        iit : function (name, code, timeout) {
            if (this.harness.isAutomated) {
                this.fail('t.iit should only be used during debugging');
            }
            this.it(name, code, timeout, true)
        },
        
        
        /**
         * This is a no-op method, allowing you to quickly ignore some specs. 
         */
        xit : function () {
        },
        
        
        /**
         * This method starts a sub test with *spec* (in BDD terms). Such spec consists from one or more assertions (or *expectations*, *matchers*, etc) or other nested specs
         * and/or suites. See the {@link #expect} method. The number of nesting levels is not limited. All specs of the same nesting level are executed sequentially. 
         * 
         * For example:
         * 
    t.describe('A product', function (t) {
    
        t.it('should have feature X', function (t) {
            ...
        })
        
        t.it('should have feature Y', function (t) {
            ...
        })
    })
         *
         * See also {@link #xit}, {@link #iit}
         * 
         * @param {String} name The name or description of the spec
         * @param {Function} code The code function for this spec. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this spec. If not provided {@link Siesta.Harness#subTestTimeout} value is used.
         */
        it : function (name, code, timeout, isExclusive) {
            this.checkSpecFunction(code, 'it', name)
            
            var subTest     = this.getSubTest({
                name            : name,
                run             : code,
                
                isExclusive     : isExclusive,
                
                specType        : 'it',
                timeout         : timeout
            })
            
            if (this.codeProcessed) this.scheduleSpecsLaunch()
            
            this.sequentialSubTests.push(subTest)
        },
        
        
        /**
         * This method returns an "expectation" instance, which can be used to check various assertions about the passed value.
         * 
         * **Note**, that every expectation has a special property `not`, that contains another expectation, but with the negated meaning.
         * 
         * For example:
         * 

    t.expect(1).toBe(1)
    t.expect(1).not.toBe(2)
    
    t.expect('Foo').toContain('oo')
    t.expect('Foo').not.toContain('bar')
 
 
         * Please refer to the documentation of the {@link Siesta.Test.BDD.Expectation} class for the list of available methods.
         * 
         * @param {Mixed} value Any value, that will be assert about
         * @return {Siesta.Test.BDD.Expectation} Expectation instance
         */
        expect : function (value) {
            return new this.expectationClass({
                t           : this,
                value       : value
            })
        },
        
        
        /**
         * This method returns a *placeholder*, denoting any instance of the provided class constructor. Such placeholder can be used in various
         * comparison assertions, like {@link #is}, {@link #isDeeply}, {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         * 
         * For example:

    t.is(1, t.any(Number))
    
    t.expect(1).toBe(t.any(Number))
    
    t.isDeeply({ name : 'John', age : 45 }, { name : 'John', age : t.any(Number))
    
    t.expect({ name : 'John', age : 45 }).toEqual({ name : 'John', age : t.any(Number))
    
    t.is(NaN, t.any(), 'When class constructor is not provided `t.any()` should match anything')

         * 
         * @param {Function} clsConstructor A class constructor instances of which are denoted with this placeholder. As a special case if this argument
         * is not provided, a placeholder will match any value. 
         * 
         * @return {Object} A placeholder object
         */
        any : function (clsConstructor) {
            return new Siesta.Test.BDD.Placeholder({
                clsConstructor      : clsConstructor,
                t                   : this,
                context             : this.global
            })
        },
        
        /**
         * This method returns a *placeholder*, denoting any number approximately equal to the provided value. 
         * Such placeholder can be used in various comparison assertions, like {@link #is}, {@link #isDeeply}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()}, 
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         * 
         * For example:

    t.is(1, t.anyNumberApprox(1.2, 0.5))
    
    t.expect(1).toBe(t.any(Number))
    
         * 
         * @param {Number} value The approximate value
         * @param {Number} [threshold] The threshold. If omitted, it is set to 5% from the `value`.
         *  
         * @return {Object} A placeholder object
         */
        anyNumberApprox : function (value, threshold) {
            return new Siesta.Test.BDD.NumberPlaceholder({
                value               : value,
                threshold           : threshold
            })
        },
        
        
        scheduleSpecsLaunch : function () {
            if (this.launchTimeout) return
            
            var async                   = this.beginAsync()
            var originalSetTimeout      = this.originalSetTimeout
            var me                      = this
            
            this.launchTimeout          = originalSetTimeout(function () {
                me.endAsync(async)
                me.launchTimeout        = null
                
                me.launchSpecs()
            }, 0)
        },
        
        
        launchSpecs : function () {
            var me                  = this
            var sequentialSubTests  = this.sequentialSubTests
            
            this.sequentialSubTests = []
            
            // hackish way to pass a config to `t.chain`
            this.chain.actionDelay  = 0
            
            var exclusiveSubTests   = []
            
            Joose.A.each(sequentialSubTests, function (subTest) {
                if (subTest.isExclusive) exclusiveSubTests.push(subTest)
            })
            
            this.chain(exclusiveSubTests.length ? exclusiveSubTests : sequentialSubTests)
        }
    },
    
    
    override : {
        afterLaunch : function () {
            this.codeProcessed      = true
            
            this.launchSpecs()
            
            this.SUPERARG(arguments)
        }
    }
        
})
//eof Siesta.Test.BDD
;
Role('Siesta.Test.Sub', {
    
    has : {
        isExclusive         : false,
        parent              : { required : true }
    },
    
    
    methods : {
        
        getExceptionCatcher : function () {
            return this.parent.getExceptionCatcher()
        },
        
        
        getTestErrorClass : function () {
            return this.parent.getTestErrorClass()
        },
        
        
        getStartTestAnchor : function () {
            return this.parent.getStartTestAnchor()
        },
        
        
        expectGlobals : function () {
            return this.parent.expectGlobals.apply(this.parent, arguments)
        }
    }
        
})
//eof Siesta.Test
;
/**
@class Siesta.Test
@mixin Siesta.Test.More
@mixin Siesta.Test.Date 
@mixin Siesta.Test.Function
@mixin Siesta.Test.BDD 

`Siesta.Test` is a base testing class in Siesta hierarchy. Its not supposed to be created manually, instead, the harness will create it for you.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

Please note: Each test will be run in **its own**, completely **isolated** and **clean** global scope (created with the iframe). 
**There is no need to cleanup anything**.

SYNOPSIS
========

    StartTest(function(t) {
        t.diag("Sanity")
        
        t.ok($, 'jQuery is here')
        
        t.ok(Your.Project, 'My project is here')
        t.ok(Your.Project.Util, '.. indeed')
        
        setTimeout(function () {
        
            t.ok(true, "True is ok")
        
        }, 500)
    })    


*/

Class('Siesta.Test', {
    
    does        : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Test.More,
        Siesta.Test.Date,
        Siesta.Test.Function,
        Siesta.Test.BDD,
        JooseX.Observable
    ],
    
    
    has        : {
        name                : null,
        
        /**
         * @property url The url of this test, as given to the {@link Siesta.Harness#start start} method. All subtests of some top-level test shares the same url.
         */
        url                 : { required : true },
        urlExtractRegex     : {
            is      : 'rwc',
            lazy    : function () {
                return new RegExp(this.url.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1") + ':(\\d+)')
            }
        },
        
        assertPlanned       : null,
        assertCount         : 0,
        
        // whether this test contains only "todo" assertions
        isTodo              : false,
        
        results             : {
            lazy    : function () {
                return new Siesta.Result.SubTest({ description  : this.name || 'Root', test : this })
            }
        },
        
        run                 : { required : true },
        startTestAnchor     : null,
        exceptionCatcher    : null,
        testErrorClass      : null,
        
        generation          : function () {
            return Math.random()
        },
        
        parent              : null,
        harness             : { required : true },
        
        /**
         * @cfg {Number} isReadyTimeout 
         * 
         * Timeout in milliseconds to wait for test start. Default value is 10000. See also {@link #isReady}  
         */
        isReadyTimeout      : 10000,

        // indicates that a test has thrown an exception (not related to failed assertions)
        failed              : false,
        failedException     : null, // stringified exception
        failedExceptionType : null, // type of exception
        
        // start and end date are stored as numbers (new Date() - 0)
        // this is to allow sharing date instances between different contexts
        startDate           : null,
        endDate             : null,
        lastActivityDate    : null,
        contentManager      : null,
        
        // the scope provider for the context of the test page
        scopeProvider       : null,
        // the context of the test page
        global              : { required : true },
        
        // the scope provider for the context of the test script
        // usually the same as the `scopeProvider`, but may be different in case of using `separateContext` option
        scriptScopeProvider : null,
        
        transparentEx       : false,
        
        needDone            : false,
        isDone              : false,
        
        defaultTimeout      : 15000,
        // a default timeout for sub tests
        subTestTimeout      : null,
        // a timeout of this particular test
        timeout             : null,
        
        timeoutsCount       : 1,
        timeoutIds          : Joose.I.Object,
        idsToIndex          : Joose.I.Object,
        waitTitles          : Joose.I.Object,
        
        
        // indicates that test function has completed the execution (test may be still running due to async)
        processed           : false,
        
        callback            : null,
        
        // Nbr of exceptions detected while running the test
        nbrExceptions       : 0,
        testEndReported     : false,
        
        // only used for testing itself, otherwise should be always `true`
        needToCleanup               : true,
        
        overrideSetTimeout          : false,
        
        originalSetTimeout          : { required : true },
        originalClearTimeout        : { required : true },
        
        sourceLineForAllAssertions  : false,
        
        $passCount                  : null,
        $failCount                  : null
    },
    
    
    methods : {
        
        initialize : function () {
            // suppress bubblings of some events (JooseX.Observable does not provide better mechanism for that, yet)
            this.on('teststart', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.on('testfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.on('beforetestfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.on('beforetestfinalizeearly', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.subTestTimeout     = 2 * this.defaultTimeout
        },
        
        /**
         * This method allows you to delay the start of the test, for example for performing some asynchronous setup code (like login into application).
         * Note, that you may want to use {@link #setup} method instead, as its a bit simpler for implementation.  
         * 
         * It is supposed to be overriden in the subclass of Siesta.Test and should return object with properties "ready" and "reason" 
         * ("reason" is only meaningful for "ready : false"). Test instance will poll this method and will only launch
         * the test, when this method will return "ready : true". If waiting for this will take longer than {@link #isReadyTimeout} then, test
         * will be launched anyway, but a failing assertion will be added to it.
         * 
         * **Important** This method should always check the value returned by `this.SUPER` call. 
         * 
         * Typical example of using this method will be:
         * 

    Class('My.Test.Class', {
        
        isa         : Siesta.Test.Browser,
            
        has         : {
            isCustomSetupDone           : false
        },
        
        override : {
            
            isReady : function () {
                var result = this.SUPERARG(arguments);
    
                if (!result.ready) return result;
    
                if (!this.isCustomSetupDone) return {
                    ready       : false,
                    reason      : "Waiting for `isCustomSetupDone` took too long - something wrong?"
                }
                
                return {
                    ready       : true
                }
            },
    
            
            start : function () {
                var me      = this;
                
                Ext.Ajax.request({
                    url     : 'do_login.php',
                    
                    params  : { ... },
                    
                    success : function () {
                        me.isCustomSetupDone    = true
                    }
                })
                
                this.SUPERARG(arguments)
            }
        },
        
        ....
    })
    
         * 
         * @return {Object} Object with properties `{ ready : true/false, reason : 'description' }`
         */
        isReady: function() {
            // this should allow us to wait until the presense of "run" function
            // it will become available after call to StartTest method
            // which some users may call asynchronously, after some delay
            // see https://www.assembla.com/spaces/bryntum/tickets/379
            // in this case test can not be configured using object as 1st argument for StartTest
            this.run    = this.run || this.getStartTestAnchor().args && this.getStartTestAnchor().args[ 0 ]
            
            return {
                ready   : this.typeOf(this.run) == 'Function',
                reason  : 'No code provided to test'
            }
        },
        
        
        isFromTheSameGeneration : function (test2) {
            return this.generation == test2.generation
        },
        

        toString : function() {
            return this.url
        },
        
        
        // deprecated
        plan : function (value) {
            if (this.assertPlanned != null) throw new Error("Test plan can't be changed")
            
            this.assertPlanned = value
        },
        
        
        addResult : function (result) {
            var isAssertion = result instanceof Siesta.Result.Assertion
            
            if (isAssertion) result.isTodo = this.isTodo
            
            // only allow to add diagnostic results and todo results after the end of test
            // and only if "needDone" is enabled
            if (isAssertion && (this.isDone || this.isFinished()) && !result.isTodo) {
                if (!this.testEndReported) {
                    this.testEndReported = true
                    
                    this.fail("Adding assertions after the test has finished.")
                }
            }

            if (isAssertion && !result.index) {
                result.index = ++this.assertCount
            }

            this.getResults().push(result)
            
            // clear the cache
            this.$passCount     = this.$failCount   = null
            
            /**
             * This event is fired when an individual test case receives a new result (assertion or diagnostic message).
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             * 
             * @event testupdate
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             * @param {Siesta.Result} result The new result. Instance of Siesta.Result.Assertion or Siesta.Result.Diagnostic classes
             */
            this.fireEvent('testupdate', this, result, this.getResults())

            this.lastActivityDate = new Date();
        },
        

        /**
         * This method output the diagnostic message.  
         * @param {String} desc The text of diagnostic message
         */
        diag : function (desc) {
            this.addResult(new Siesta.Result.Diagnostic({
                description : desc
            }))
        },
        
        
        /**
         * This method add the passed assertion to this test.
         * 
         * @param {String} desc The description of the assertion
         * @param {String/Object} annotation The string with additional description how exactly this assertion passes. Will be shown with monospace font.
         * Can be also an object with the following properties:
         * @param {String} annotation.annotation The actual annotation text
         * @param {String} annotation.descTpl The template for the default description text. Will be used if user did not provide any description for
         * assertion. Template can contain variables in braces. The values for variables are taken as properties of `annotation` parameters with the same name:
         * 

    this.pass(desc, {
        descTpl         : '{value1} sounds like {value2}',
        value1          : '1',
        value2          : 'one
    })

         * 
         */
        pass : function (desc, annotation, result) {
            if (annotation && this.typeOf(annotation) != 'String') {
                // create a default assertion description
                if (!desc && annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)
                
                // actual annotation
                annotation          = annotation.annotation
            }
            
            if (result) {
                result.passed       = true
                result.description  = desc || ''
                result.annotation   = annotation
            }
            
            this.addResult(result || new Siesta.Result.Assertion({
                passed          : true,
                
                annotation      : annotation,
                description     : desc || '',
                sourceLine      : (result && result.sourceLine) || (annotation && annotation.sourceLine) || this.sourceLineForAllAssertions && this.getSourceLine() || null
            }))
        },
        
        
        /**
         * This method returns a result of `Object.prototype.toString` applied to the passed argument. The `[object` and trailing `]` are trimmed. 
         * 
         * @param {Mixed} object
         * @return {String} The name of the "type" for this object.
         */
        typeOf : function (object) {
            return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
        },
        
        /**
         * This method add the failed assertion to this test.
         * 
         * @param {String} desc The description of the assertion
         * @param {String/Object} annotation The additional description how exactly this assertion fails. Will be shown with monospace font.
         * 
         * Can be either string or an object with the following properties. In the latter case a string will be constructed from the properties of the object.
         * 
         * - `assertionName` - the name of assertion, will be shown in the 1st line, along with originating source line (in FF and Chrome only)
         * - `got` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `need` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `gotDesc` - a prompt for "got", default value is "Got", but can be for example: "We have" 
         * - `needDesc` - a prompt for "need", default value is "Need", but can be for example: "We need"
         * - `annotation` - A text to append on the last line, can contain some additional explanations
         * 
         *  The "got" and "need" values will be stringified to the "not quite JSON" notation. Notably the points of circular references will be 
         *  marked with `[Circular]` marks and the values at 4th (and following) level of depth will be marked with triple points: `[ [ [ ... ] ] ]`  
         */
        fail : function (desc, annotation, result) {
            var sourceLine          = (result && result.sourceLine) || (annotation && annotation.sourceLine) || this.getSourceLine()
            
            if (annotation && this.typeOf(annotation) != 'String') {
                if (!desc && annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)
                
                var strings             = []
                
                var params              = annotation
                var annotation          = params.annotation
                var assertionName       = params.assertionName
                var hasGot              = params.hasOwnProperty('got')
                var hasNeed             = params.hasOwnProperty('need')
                var gotDesc             = params.gotDesc || 'Got'
                var needDesc            = params.needDesc || 'Need'
                
                if (!params.ownTextOnly && (assertionName || sourceLine)) strings.push(
                    'Failed assertion ' + (assertionName ? '`' + assertionName + '` ' : '') + this.formatSourceLine(sourceLine)
                )
                
                if (hasGot && hasNeed) {
                    var max         = Math.max(gotDesc.length, needDesc.length)
                    
                    gotDesc         = this.appendSpaces(gotDesc, max - gotDesc.length + 1)
                    needDesc        = this.appendSpaces(needDesc, max - needDesc.length + 1)
                }
                
                if (hasGot)     strings.push(gotDesc   + ': ' + Siesta.Util.Serializer.stringify(params.got))
                if (hasNeed)    strings.push(needDesc  + ': ' + Siesta.Util.Serializer.stringify(params.need))
                
                if (annotation) strings.push(annotation)
                
                annotation      = strings.join('\n')
            }
            
            if (result) {
                // Failing a pending waitFor operation
                result.name         = assertionName;
                result.passed       = false;
                result.annotation   = annotation;
                result.description  = desc;
            }
            
            this.addResult(result || new Siesta.Result.Assertion({
                name        : assertionName,
                passed      : false,
                sourceLine  : sourceLine,
            
                annotation  : annotation,
                description : desc
            }))

            if (this.harness.activateDebuggerOnFail) {
                eval("debugger");
            }

            if (this.harness.breakOnFail) {
                this.finalize(true);
                throw 'Assertion failed, test execution aborted';
            }
        },

        
        getSource : function () {
            return this.contentManager.getContentOf(this.url)
        },
        
        
        getSourceLine : function () {
            try {
                throw new Error()
            } catch (e) {
                if (e.stack) {
                    var match       = e.stack.match(this.urlExtractRegex())
                    
                    if (match) return match[ 1 ]
                }
                
                return null
            }
        },
        
        
        getStartTestAnchor : function () {
            return this.startTestAnchor
        },
        
        
        getExceptionCatcher : function () {
            return this.exceptionCatcher
        },
        
        
        getTestErrorClass : function () {
            return this.testErrorClass
        },

        
        processCallbackFromTest : function (callback, args, scope) {
            var me      = this

            if (!callback) return true;

            if (this.transparentEx) {
                callback.apply(scope || this.global, args || [])
            } else {
                var e = this.getExceptionCatcher()(function(){
                    callback.apply(scope || me.global, args || [])
                })
            
                if (e) {
                    this.failWithException(e)
                    
                    // flow should be interrupted - exception detected
                    return false
                }
            }
            
            // flow can be continued
            return true
        },

        
        getStackTrace : function (e) {
            if (Object(e) !== e)    return null
            if (!e.stack)           return null
            
            var text            = e.stack + '';
            var isFirefox       = /^@/.test(text)
            var lines           = text.split('\n')
            
            var result          = []
            var match
            
            for (var i = 0; i < lines.length; i++) {
                if (!lines[ i ]) continue
                
                if (!i) {
                    if (isFirefox) 
                        result.push(e + '')
                    else {
                        result.push(lines[ i ])
                        continue;
                    }
                }
            
                if (isFirefox) {
                    match       = /@(.*?):(\d+)/.exec(lines[ i ]);
                    
                    // the format of stack trace in Firefox has changed, 080_exception_parsing should fail
                    if (!match) return null
                    
                    result.push('    at line ' + match[ 2 ] + ' of ' + match[ 1 ])
                } else {
                    match       = /\s*at\s(.*?):(\d+):(\d+)/.exec(lines[ i ]);
                    
                    // the format of stack trace in Chrome has changed, 080_exception_parsing should fail
                    if (!match) return null
                    
                    result.push('    at line ' + match[ 2 ] + ', character ' + match[ 3 ] + ', of ' + match[ 1 ])
                }
            }
                
            if (!result.length) return null
            
            return result
        },
        
        
        formatSourceLine : function (sourceLine) {
            return sourceLine ? 'at line ' + sourceLine + ' of ' + this.url : ''
        },
        
        
        appendSpaces : function (str, num) {
            var spaces      = ''
            
            while (num--) spaces += ' '
            
            return str + spaces
        },
        
        
        eachAssertion : function (func, scope) {
            scope       = scope || this
            
            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.Assertion) func.call(scope, result)
            })
        },
        
        
        eachSubTest : function (func, scope) {
            scope       = scope || this
            
            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.SubTest) func.call(scope, result.test)
            })
        },
        
        
        eachChildTest : function (func, scope) {
            scope       = scope || this
            
            this.getResults().eachChild(function (result) {
                if (result instanceof Siesta.Result.SubTest) func.call(scope, result.test)
            })
        },
        
        
        countKeys : function (object) {
            var counter = 0
            
            Joose.O.eachOwn(object, function () {
                counter++
            })
            
            return counter
        },
        
        
        /**
         * This method performs a deep comparison of the passed JSON objects. Objects must not contain cyclic references.
         * You can use this method in your own assertions.
         * 
         * @param {Mixed} obj1 The 1st object to compare
         * @param {Mixed} obj2 The 2nd object to compare
         * @param {Boolean} strict When passed the `true` value, the comparison of the primitive values will be performed with the 
         * `===` operator (so [ 1 ] and [ "1" ] object will be different). Additionally, when this flag is set to `true`, then
         * when comparing Function, RegExp and Date instances, additional check that objects contains the same set of own properties ("hasOwnProperty")
         * will be performed. 
         * @param {Boolean} onlyPrimitives When set to `true`, the function will not recurse into composite objects (like [] or {}) and will just report that
         * objects are different. Use this mode when you are only interesetd in comparison of primitive values (numbers, strings, etc).
         * @param {Boolean} asObjects When set to `true`, the function will compare various special Object instances, like Functions, RegExp etc,
         * by comparison of there properties only and not taking the anything else into account.
         * @return {Boolean} `true` if the passed objects are equal
         */
        compareObjects : function (obj1, obj2, strict, onlyPrimitives, asObjects) {
            var obj1IsPlaceholder       = Joose.O.isInstance(obj1) && obj1.meta.does(Siesta.Test.Role.Placeholder)
            var obj2IsPlaceholder       = Joose.O.isInstance(obj2) && obj2.meta.does(Siesta.Test.Role.Placeholder)
            
            if (strict) {
                if (obj1 === obj2) return true
            } else 
                if (obj1 == obj2) return true
                
            if (obj1IsPlaceholder && obj2IsPlaceholder)
                return obj1.equalsTo(obj2)
            else if (obj2IsPlaceholder)
                return obj2.equalsTo(obj1)
            else if (obj1IsPlaceholder)
                return obj1.equalsTo(obj2)
                
            if (onlyPrimitives) return false
            
            var type1 = this.typeOf(obj1)
            var type2 = this.typeOf(obj2)
            
            if (type1 != type2) return false
            
            var me = this
                
            if (type1 == 'Object' || asObjects)
                if (this.countKeys(obj1) != this.countKeys(obj2)) 
                    return false
                else {
                    var res = Joose.O.eachOwn(obj1, function (value, name) {
                        
                        if (!me.compareObjects(value, obj2[ name ], strict)) return false
                    })
                    
                    return res === false ? false : true
                }
                
            if (type1 == 'Array')
                if (obj1.length != obj2.length) 
                    return false
                else {
                    for (var i = 0; i < obj1.length; i++)
                        if (!this.compareObjects(obj1[ i ], obj2[ i ], strict)) return false
                    
                    return true
                }
                
            if (type1 == 'Function') 
                return obj1.toString() == obj2.toString() && (!strict || this.compareObjects(obj1, obj2, strict, false, true))
            
            if (type1 == 'RegExp') 
                return obj1.source == obj2.source && obj1.global == obj2.global && obj1.ignoreCase == obj2.ignoreCase 
                    && obj1.multiline == obj2.multiline && (!strict || this.compareObjects(obj1, obj2, strict, false, true))
                
            if (type1 == 'Date') return !Boolean(obj1 - obj2) && (!strict || this.compareObjects(obj1, obj2, strict, false, true))
            
            return false
        }, 
        
        
        /**
         * This assertion passes when the supplied `value` evalutes to `true` and fails otherwise.
         *  
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} desc The description of the assertion
         */
        ok : function (value, desc) {
            if (value) 
                this.pass(desc, {
                    descTpl             : '`{value}` is a "truthy" value',
                    value               : value
                })
            else 
                this.fail(desc, {
                    assertionName       : 'ok', 
                    got                 : value, 
                    annotation          : 'Need "truthy" value'
                })
        },
        
        
        notok : function () {
            this.notOk.apply(this, arguments)
        },
        
        /**
         * This assertion passes when the supplied `value` evalutes to `false` and fails otherwise.
         * 
         * It has a synonym - `notok`.
         *  
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} desc The description of the assertion
         */
        notOk : function (value, desc) {
            if (!value) 
                this.pass(desc, {
                    descTpl             : '`{value}` is not a "truthy" value',
                    value               : value
                })
            else 
                this.fail(desc, {
                    assertionName       : 'notOk', 
                    got                 : value, 
                    annotation          : 'Need "falsy" value'
                })
        },
        
        
        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `==` operator returns true and fails otherwise.
         * 
         * As a special case, one or both arguments can be *placeholders*, generated with method {@link #any}. 
         * 
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} desc The description of the assertion
         */
        is : function (got, expected, desc) {
            if (expected && got instanceof this.global.Date) {
                this.isDateEqual(got, expected, desc);
            } else if (this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'is', 
                    got                 : got, 
                    need                : expected 
                })
        },
        

        
        isnot : function () {
            this.isNot.apply(this, arguments)
        },

        isnt : function () {
            this.isNot.apply(this, arguments)
        },
        
        
        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `!=` operator returns true and fails otherwise.
         * It has synonyms - `isnot` and `isnt`.
         * 
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         * 
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} desc The description of the assertion
         */
        isNot : function (got, expected, desc) {
            if (!this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is not equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isnt', 
                    got                 : got, 
                    need                : expected,
                    needDesc            : 'Need, not'
                })
        },
        

        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `===` operator returns true and fails otherwise.
         * 
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         * 
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} desc The description of the assertion
         */
        isStrict : function (got, expected, desc) {
            if (this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is strictly equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isStrict', 
                    got                 : got, 
                    need                : expected,
                    needDesc            : 'Need strictly'
                })
        },

        
        isntStrict : function () {
            this.isNotStrict.apply(this, arguments)
        },
        
        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `!==` operator returns true and fails otherwise.
         * It has synonyms - `isntStrict`.
         * 
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         * 
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} desc The description of the assertion
         */
        isNotStrict : function (got, expected, desc) {
            if (!this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is not strictly equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isntStrict', 
                    got                 : got, 
                    need                : expected,
                    needDesc            : 'Need, strictly not'
                })
        },
        
        
        /**
         * This method starts the "asynchronous frame". The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame can be finished with the {@link #endWait} call. Unlike the {@link #beginAsync}, this method requires you to provide
         * the unique id for the asynchronous frame. 
         * 
         * For example:
         * 
         *      t.wait("require")
         *      
         *      Ext.require('Some.Class', function () {
         *      
         *          t.ok(Some.Class, 'Some class was loaded')
         *          
         *          t.endWait("require")
         *      })
         * 
         * 
         * @param {String} title The unique id for the asynchronous frame.
         * @param {String} howLong The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         */
        wait : function (title, howLong) {
            if (this.waitTitles.hasOwnProperty(title)) throw new Error("Already doing a `wait` with title [" + title + "]")
            
            return this.waitTitles[ title ] = this.beginAsync(howLong)
        },
        
        
        /**
         * This method finalize the "asynchronous frame" started with {@link #wait}.
         * 
         * @param {String} title The id of frame to finalize, which was previously passed to {@link #wait} method
         */
        endWait : function (title) {
            if (!this.waitTitles.hasOwnProperty(title)) throw new Error("There were no call to `wait` with title [" + title + "]")
            
            this.endAsync(this.waitTitles[ title ])
            
            delete this.waitTitles[ title ]
        },
        
        
        
        /**
         * This method starts the "asynchronous frame". The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame should be finished with the {@link #endAsync} call within the provided `time`, otherwise a failure will be reported. 
         * 
         * For example:
         * 
         *      var async = t.beginAsync()
         *      
         *      Ext.require('Some.Class', function () {
         *      
         *          t.ok(Some.Class, 'Some class was loaded')
         *          
         *          t.endAsync(async)
         *      })
         * 
         * 
         * @param {Number} time The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         * @param {Function} errback Optional. The function to call in case the call to {@link #endAsync} was not detected withing `time`. If function
         * will return any "truthy" value, the failure will not be reported (you can report own failure with this errback).
         *  
         * @return {Object} The frame object, which can be used in {@link #endAsync} call
         */
        beginAsync : function (time, errback) {
            time                        = time || this.defaultTimeout
            
            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout
            
            var index                   = this.timeoutsCount++
            
            // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
            // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
            // can't just use `this.originalSetTimeout` because of scoping issues
            var timeoutId               = originalSetTimeout(function () {
                
                if (me.hasAsyncFrame(index)) {
                    if (!errback || !errback.call(me, me)) me.fail('No matching `endAsync` call within ' + time + 'ms')
                    
                    me.endAsync(index)
                }
            }, time)
            
            this.timeoutIds[ index ]    = timeoutId
            
            return index
        },
        
        
        hasAsyncFrame : function (index) {
            return this.timeoutIds.hasOwnProperty(index)
        },
        
        
        /**
         * This method finalize the "asynchronous frame" started with {@link #beginAsync}.
         * 
         * @param {Object} frame The frame to finalize (returned by {@link #beginAsync} method
         */
        endAsync : function (index) {
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout || this.global.clearTimeout
            var counter = 0
            
            if (index == null) Joose.O.each(this.timeoutIds, function (timeoutId, indx) {
                index = indx
                if (counter++) throw new Error("Calls to endAsync without argument should only be performed if you have single beginAsync statement") 
            })
            
            var timeoutId               = this.timeoutIds[ index ]
            
            // need to call in this way for IE < 9
            originalClearTimeout(timeoutId)
            delete this.timeoutIds[ index ]
            
            var me = this
            
            if (this.processed && !this.isFinished())
                // to allow potential call to `done` after `endAsync`
                originalSetTimeout(function () {
                    me.finalize()
                }, 1)
        },
        
        
        clearTimeouts : function () {
            var originalClearTimeout    = this.originalClearTimeout
            
            Joose.O.each(this.timeoutIds, function (value, id) {
                originalClearTimeout(value)
            })
            
            this.timeoutIds = {}
        },
        
        
        // deprecated
        skipIf : function (condition, why, code, howMany) {
            howMany = howMany || 1
            
            if (condition) {
                
                for (var i = 1; i <= howMany; i++) this.addResult(new Siesta.Result.Assertion({
                    passed      : true,
                    isSkipped   : true,
                    
                    description : 'SKIPPED: ' + why
                }))    
                
            } else
                code()
        },
        
        
        // deprecated
        skip : function (why, code, howMany) {
            this.skipIf(true, why, code, howMany)
        },
        
        
        processSubTestConfig : function (config) {
            return Joose.O.extend({
                trait                   : Siesta.Test.Sub,
                
                parent                  : this,
                
                isTodo                  : this.isTodo,
                transparentEx           : this.transparentEx,
                
                waitForTimeout          : this.waitForTimeout,
                waitForPollInterval     : this.waitForPollInterval,
                defaultTimeout          : this.defaultTimeout,
                timeout                 : this.subTestTimeout,
                
                global                  : this.global,
                url                     : this.url,
                scopeProvider           : this.scopeProvider,
                harness                 : this.harness,
                generation              : this.generation,
                
                overrideSetTimeout      : false,
                originalSetTimeout      : this.originalSetTimeout,
                originalClearTimeout    : this.originalClearTimeout,
                
                autoCheckGlobals        : false,
                needToCleanup           : false
            }, config)            
        },
        
        
        /**
         * Returns a new instance of the test class, configured as being a "sub test" of the current test.
         * 
         * The number of nesting levels is not limited - ie sub-tests may have own sub-tests.
         * 
         * Note, that this method does not starts the sub test, but only instatiate it. To start the sub test, use {@link #launchSubTest} method. 
         * 
         * @param {String} name The name of the test. Will be used in the UI, as the parent node name in the assertions tree
         * @param {Function} code A function with test code. Will receive a test instance as the 1st argument. 
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time, 
         * it will be considered failed. If not provided, the {@link Siesta.Harness#subTestTimeout} value is used. 
         * 
         * @return {Siesta.Test} A sub test instance
         */
        getSubTest : function (arg1, arg2, arg3) {
            var config
            
            if (arguments.length == 2 || arguments.length == 3) 
                config = {
                    name        : arg1,
                    run         : arg2,
                    timeout     : arg3
                } 
            else if (arguments.length == 1 && this.typeOf(arg1) == 'Function') 
                config  = {
                    name        : 'Sub test',
                    run         : arg1
                }
            
            config              = config || arg1 || {}
            
            // pass-through only valid timeout values
            if (config.timeout == null) delete config.timeout
            
            var name            = config.name
            
            if (!config.run) {
                this.failWithException("Code body is not provided for sub test [" + name + "]")
                throw new Error("Code body is not provided for sub test [" + name + "]")
            }
            if (!config.run.length) {
                this.failWithException('Code body of sub test [' + name + '] does not declare a test instance as 1st argument')
                throw new Error('Code body of sub test [' + name + '] does not declare a test instance as 1st argument')
            }
            
            return new (config.meta || this.constructor)(this.processSubTestConfig(config))
        },
        
        
        /**
         * This method launch the provided sub test instance.
         * 
         * @param {Siesta.Test} subTest A test instance to launch
         * @param {Function} callback A function to call, after the test is completed. This function is called regardless from the test execution result.
         */
        launchSubTest : function (subTest, callback) {
            var me          = this
            
            var async       = this.beginAsync(subTest.timeout || this.subTestTimeout, function () {
                me.fail('Subtest ' + (subTest.name ? '[' + subTest.name + ']' : '') +' failed to finish within ' + this.subTestTimeout + 'ms')
                
                testEndListener.remove()
                
                subTest.finalize(true)
                
                callback && callback(subTest)
                
                return true
            })
            
            var testEndListener = subTest.on('testfinalize', function () {
                me.endAsync(async)
                
                callback && callback(subTest)
            })
            
            this.addResult(subTest.getResults())
            
            subTest.start()
        },
        
        
        /**
         * With this method you can mark a group of assertions as "todo", assuming they most likely will fail,
         * but it's still worth to try to run them.
         * The supplied `code` function will be run, it will receive a new test instance as the 1st argument,
         * which should be used for assertion checks (and not the primary test instance, received from `StartTest`).
         * 
         * Assertions, failed inside of the `code` block will be still treated by harness as "green".
         * Assertions, passed inside of the `code` block will be treated by harness as bonus ones and highlighted.
         *
         * See also {@link Siesta.Test.ExtJS#knownBugIn} method. Note, that this method will start a new {@link #subTest sub test}. 
         *
         * For example:

            t.todo('Scheduled for 4.1.x release', function (todo) {

                var treePanel    = new Ext.tree.Panel()

                todo.is(treePanel.getView().store, treePanel.store, 'NodeStore and TreeStore have been merged and there is only 1 store now');
            })

         * @param {String} why The reason/description for the todo
         * @param {Function} code A function, wrapping the "todo" assertions. This function will receive a special test class instance
         * which should be used for assertion checks
         */
        todo : function (why, code, callback) {
            if (this.typeOf(why) == 'Function') why = [ code, code = why ][ 0 ]
            
            var todo        = this.getSubTest({
                name            : why,
                
                run             : code,
                
                isTodo          : true,
                transparentEx   : false
            })

            this.launchSubTest(todo, callback)
        },
        
        
        /**
         * This method starts a new sub test. Sub tests have separate order of assertions. In the browser UI,
         * sub tests are presented with the "parent" node of the assertions tree. Sub tests are useful if you want to test
         * several asynchronous processes in parallel, and would like to see assertions from every process separated.
         * 
         * Sub tests may have their own sub tests, the number of nesting levels is not limited.
         * 
         * Sub test can contain asynchronous methods as any other tests. Sub tests are considered completed
         * only when all of its asynchronous methods have completed *and* all of its sub-tests are completed too.
         * 
         * For example:
         *

    t.subTest('Load 1st store', function (t) {
        var async   = t.beginAsync()
    
        store1.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store1.getCount(), 0, "Store1 has been loaded")
            }
        })
    })
    
    t.subTest('Load 2nd store', function (t) {
        var async   = t.beginAsync()
    
        store2.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store2.getCount(), 0, "Store2 has been loaded")
            }
        })
    })

         * Note, that sub test starts right away, w/o waiting for any previous sub tests to complete. If you'd like to run several sub-tests
         * sequentially, use {@link #chain} method in combination with {@link #getSubTest} method. 
         * 
         * @param {String} desc The name of the sub test. Will be shown as the name of the parent node in assertion tree.
         * @param {Function} code The test function to execute. It will receive a test instance as 1st argument. This test instance *must* be
         * used for assertions inside of the test function
         * @param {Function} callback The callback to execute after the sub test completes (either successfully or not)
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time, 
         * it will be considered failed. If not provided, the {@link Siesta.Harness#subTestTimeout} value is used. 
         */
        subTest : function (desc, code, callback, timeout) {
            var subTest     = this.getSubTest({
                name            : desc || "Sub test",
                
                timeout         : timeout,
                
                run             : code
            })

            this.launchSubTest(subTest, callback)
        },
        
        
        failWithException : function (e) {
            this.failed                 = true
            
            var stackTrace              = this.getStackTrace(e)
            var stringified             = e + ''
            var annotation              = (stackTrace || []).join('\n')

            this.failedException        = stringified
            this.failedExceptionType    = this.typeOf(e)
            
            // prepend the exception message to the stack trace if its not already there
            if (annotation.indexOf(stringified) == -1) annotation = stringified + annotation
            
            this.addResult(new Siesta.Result.Assertion({
                isException     : true,
                exceptionType   : this.failedExceptionType,
                passed          : false,
                description     : (this.parent ? "Sub-test `" + this.name + "`" : 'Test ') + ' threw an exception',
                annotation      : annotation
            }))
            
            
            /**
             * This event is fired when an individual test case has thrown an exception.
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             * 
             * @event testfailedwithexception
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just threw an exception
             * @param {Object} exception The exception thrown
             */
            this.fireEvent('testfailedwithexception', this, e, stackTrace);
            
            this.finalize(true)
        },
        
        
        start : function (alreadyFailedWithException) {
            if (this.startDate) {
                throw 'Test has already been started';
            }

            this.startDate  = new Date() - 0
            
            /**
             * This event is fired when an individual test case starts. When *started*, the test may still be waiting for the {@link #isReady} condition
             * to be fullfilled. Once all conditions are fullfilled the test will be *launched*.
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on harness as well. 
             * 
             * @event teststart
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             */
            this.fireEvent('teststart', this);
            
            if (alreadyFailedWithException) {
                this.failWithException(alreadyFailedWithException) 
                
                return
            }
            
            if (this.parent) {
                this.launch()
                return
            }
            
            var me              = this;
            var errorMessage; 
            var readyRes        = me.isReady();
            
            // Note, that `setTimeout, setInterval` and similar methods here are from the harness context
            
            var cont            = function (isReadyError) {
                var hasTimedOut     = false
                
                var setupTimeout    = setTimeout(function () {
                    hasTimedOut     = true
                    me.launch('`setup` method took too long to complete')
                }, me.isReadyTimeout)
                
                me.setup(
                    function () {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch()
                        }
                    },
                    function (setupError) {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch(setupError)
                        }
                    }
                );
            }
            
            if (readyRes.ready) {
                // We're ready to go
                cont();
            } else {
                // Need to wait for isReady to give green light
                var timeout         = setTimeout(function () {
                    clearInterval(interval)
                    cont(errorMessage)
                    
                }, me.isReadyTimeout)
                
                var interval = setInterval(function(){ 
                    readyRes = me.isReady();
                
                    if (readyRes.ready) {
                        clearInterval(interval)
                        clearTimeout(timeout)
                        cont();
                    } else {
                        errorMessage = readyRes.reason || errorMessage;
                    }
                }, 100);
            }
        },
        
        
        /**
         * This method can perform any setup code your tests need. It is called before the begining of every test and receives
         * a callback and errback, which should be called once the setup has completed. Typical usage for this method can be for example
         * to log in into the application, before interacting with it:
         * 

    Class('My.Test.Class', {
        
        isa         : Siesta.Test.Browser,
            
        override : {
            
            setup : function (callback, errback) {
                Ext.Ajax.request({
                    url     : 'do_login.php',
                    
                    params  : { ... },
                    
                    success : function () {
                        callback()
                    },
                    failure : function () {
                        errback('Login failed')
                    }
                })
            }
        },
        
        ....
    })

         * 
         * This method will be called *after* the {@link #isReady} method has reported that test is ready for start.
         * 
         * If setup has failed for some reason, then a errback should be called and failing assertion will be added to the test
         * (test will be lauched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         * 
         * Note, that setup is supposed to be completed within the {@link #isReadyTimeout} timeout, otherwise it will be 
         * considered failed and test will be launched with failed assertion.
         * 
         * @param {Function} callback A function to call when setup has completed successfully
         * @param {Function} errback A function to call when setup has completed with an error
         */
        setup : function (callback, errback) {
            callback.call(this)
        },
            

        launch : function (errorMessage) {
            if (errorMessage) {
                this.fail('Error happened even before the test has started', {
                    annotation      : errorMessage
                })
            }
            
            var me                      = this
            var global                  = this.global
            
            var scopeProvider           = this.scopeProvider
            
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout
            
            // this.overrideSetTimeout
            if (this.overrideSetTimeout) {
                // see http://www.adequatelygood.com/2011/4/Replacing-setTimeout-Globally
                scopeProvider.runCode('var setTimeout, clearTimeout;')
                
                global.setTimeout = function (func, delay) {
                    
                    var index = me.timeoutsCount++
                    
                    // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
                    // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
                    var timeoutId = originalSetTimeout(function () {
                        originalClearTimeout(timeoutId)
                        delete me.timeoutIds[ index ]
                        
                        // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                        if (me.processed && !me.isFinished())
                            // we are doing that after slight delay, potentially allowing to setup some other async frames in the "func" below
                            originalSetTimeout(function () {
                                me.finalize()
                            }, 1)
                        
                        func()
                        
                    }, delay)
    
                    // in NodeJS saves the index of the timeout descriptor to the descriptor
                    if (typeof timeoutId == 'object') 
                        timeoutId.__index = index
                    else
                        // in browser (where `timeoutId` is a number) - to the `idsToIndex` hash
                        me.idsToIndex[ timeoutId ] = index
                        
                    return me.timeoutIds[ index ] = timeoutId
                }
                
                global.clearTimeout = function (id) {
                    if (id == null) return
                    
                    var index
                    
                    // in NodeJS `setTimeout` returns an object and not a simple ID
                    if (typeof id == 'object') {
                        index       = id.__index
                        if (me.timeoutIds[ index ] != id) throw "Incorrect state"
                    } else {
                        index       = me.idsToIndex[ id ]
                        
                        delete me.idsToIndex[ id ]
                    }
                    
                    originalClearTimeout(id)
                    
                    if (index != null) delete me.timeoutIds[ index ]
                    
                    // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                    if (me.processed && !me.isFinished())
                        // we are doing that after slight delay, potentially allowing to setup some other async frames after the "clearTimeout" will complete
                        originalSetTimeout(function () {
                            me.finalize()
                        }, 1)
                }
            }
            // eof this.overrideSetTimeout
            
            // we only don't need to cleanup up when doing a self-testing or for sub-tests
            if (this.needToCleanup) {
                scopeProvider.beforeCleanupCallback = function () {
                    // if scope cleanup happens most probably user has restarted the test and is not interested in the results
                    // of previous launch
                    // finalizing the previous test in such case
                    if (!me.isFinished()) me.finalize(true)
                    
                    if (me.overrideSetTimeout) {
                        global.setTimeout       = originalSetTimeout
                        global.clearTimeout     = originalClearTimeout
                    }
                    
                    // cleanup the closures just in case (probably useful for IE)
                    originalSetTimeout          = originalClearTimeout  = null
                    global                      = run                   = null
                    
                    me.eachSubTest(function (subTest) {
                        subTest.cleanup()
                    })
                }
            }
            
            var run     = this.run
            
            if (this.transparentEx)
                run(me)
            else 
                var e = this.getExceptionCatcher()(function(){
                    run(me)
                })
            
            this.afterLaunch(e)
        },
        
        
        cleanup : function () {
            this.originalSetTimeout     = this.originalClearTimeout     = null
            this.global                 = this.run                      = null
            this.exceptionCatcher       = this.testErrorClass           = null
            this.startTestAnchor                                        = null
        },
        
        
        // a method executed after the "run" function has been ran - used in BDD role for example
        afterLaunch : function (e) {
            if (e)
                this.failWithException(e)
            else
                this.finalize()
        },
        
        
        finalize : function (force) {
            if (this.isFinished()) return
            
            this.processed = true
            
            if (force) {
                this.clearTimeouts()
                
                this.eachChildTest(function (childTest) { childTest.finalize(true) })
            }
            
            if (!Joose.O.isEmpty(this.timeoutIds)) {
                if (
                    !this.__timeoutWarning && this.overrideSetTimeout && this.lastActivityDate &&
                    new Date() - this.lastActivityDate > this.defaultTimeout * 2
                ) {
                    this.diag('Your test is still considered to be running, if this is unexpected please see console for more information');
                    this.warn('Your test [' + this.url + '] has not finalized, most likely since a timer (setTimeout) is still active. ' + 
                              'If this is the expected behavior, try setting "overrideSetTimeout : false" on your Harness configuration.');
                    this.__timeoutWarning = true;
                }

                return
            }

            if (!this.needDone && !this.isDone) {
                // this is early "testfinalize" hook, we need "early" and "usual" hooks, since we want globals check to be the last assertion
                this.fireEvent('beforetestfinalizeearly', this)

                if (!force && !Joose.O.isEmpty(this.timeoutIds)) {
                    // Firing the beforetestXXX events may trigger additional test actions
                    return;
                }

                /**
                 * This event is fired before the individual test case ends (no any corresponded harness actions will be run yet).
                 * 
                 * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on harness as well.
                 * 
                 * @event beforetestfinalize
                 * @member Siesta.Test
                 * @param {JooseX.Observable.Event} event The event instance
                 * @param {Siesta.Test} test The test instance that is about to finalize
                 */
                this.fireEvent('beforetestfinalize', this);
            }
            
            this.endDate = new Date() - 0

            if (!this.parent) this.addResult(new Siesta.Result.Summary({
                isFailed            : this.isFailed(),
                description         : this.getSummaryMessage()
            }))
            
            /**
             * This event is fired when an individual test case ends (either because it has completed correctly or thrown an exception).
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on the harness as well.
             * 
             * @event testfinalize
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has completed
             */
            this.fireEvent('testfinalize', this);
            
            // a test end event that bubbles
            this.fireEvent('testendbubbling', this);
            
            this.callback && this.callback()
        },
        
        
        getSummaryMessage : function (lineBreaks) {
            var res             = []
            
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            var total           = failCount + passCount
            
            res.push('Passed: ' + passCount)
            res.push('Failed: ' + failCount)
            
            if (!this.failed) {
                // there was a t.plan() call
                if (assertPlanned != null) {
                    if (total < assertPlanned) 
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran only ' + total)
                        
                    if (total > assertPlanned) 
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran ' +  (total - assertPlanned) + ' extra tests, ' + total + ' total.')
                    
                    if (total == assertPlanned && !failCount) res.push('All tests passed')
                } else {
                    if (!this.isDoneCorrectly()) res.push('Test has completed, but there were no `t.done()` call. Add it at the bottom, or use `t.beginAsync()` for asynchronous code')
                    
                    if (this.isDoneCorrectly() && !failCount) res.push('All tests passed')
                }
            }
            
            return lineBreaks ? res.join(lineBreaks) : res
        },
        
        
        /**
         * This method indicates that test has completed at the expected point and no more assertions are planned. Adding assertions after the call to `done`
         * will add a failing assertion "Adding assertion after test completion".
         * 
         * @param {Number} delay Optional. When provided, the test will not complete right away, but will wait for `delay` milliseconds for additional assertions. 
         */
        done : function (delay) {
            var me      = this
            
            if (delay) {
                var async = this.beginAsync()
                
                var originalSetTimeout = this.originalSetTimeout
                
                originalSetTimeout(function () {
                    
                    me.endAsync(async)
                    me.done() 
                
                }, delay)
                
            } else {
                this.fireEvent('beforetestfinalizeearly')
                this.fireEvent('beforetestfinalize');
                
                this.isDone = true
                
                if (this.processed) this.finalize()
            }
        },
        
        // `isDoneCorrectly` means that either test does not need the call to `done`
        // or the call to `done` has been already made
        isDoneCorrectly : function () {
            return !this.needDone || this.isDone
        },
        
        
        getAssertionCount : function (excludeTodo) {
            var count   = 0
            
            this.eachAssertion(function (assertion) {
                if (!excludeTodo || !assertion.isTodo) count++
            })
            
            return count
        },
        
        
        // cached method except the "includeTodo" case
        getPassCount : function (includeTodo) {
            if (this.$passCount != null && !includeTodo) return this.$passCount
            
            var passCount = 0
            
            this.eachAssertion(function (assertion) {
                if (assertion.passed && (includeTodo || !assertion.isTodo)) passCount++
            })
            
            return includeTodo ? passCount : this.$passCount = passCount
        },

        getTodoPassCount : function () {
            var todoCount = 0;
            
            this.eachAssertion(function (assertion) {
                if (assertion.isTodo && assertion.passed) todoCount++;
            });
            
            return todoCount;
        },

        getTodoFailCount : function () {
            var todoCount = 0;
            
            this.eachAssertion(function (assertion) {
                if (assertion.isTodo && !assertion.passed) todoCount++;
            });
            
            return todoCount;
        },
        
        
        // cached method except the "includeTodo" case
        getFailCount : function (includeTodo) {
            if (this.$failCount != null && !includeTodo) return this.$failCount
            
            var failCount = 0
            
            this.eachAssertion(function (assertion) {
                if (!assertion.passed && (includeTodo || !assertion.isTodo)) failCount++
            })
            
            return includeTodo ? failCount : this.$failCount = failCount
        },
        
        
        getFailedAssertions : function () {
            var failed      = [];
            
            this.eachAssertion(function (assertion) {
                if (!assertion.isPassed()) failed.push(assertion)
            })
            
            return failed
        },
        
        
        isPassed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            
            return this.isFinished() && !this.failed && !failCount && (
                assertPlanned != null && passCount == assertPlanned
                    ||
                assertPlanned == null && this.isDoneCorrectly()
            )
        },
        
        
        isFailed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            
            return this.failed || failCount || (
            
                this.isFinished() && ( 
                    assertPlanned != null && passCount != assertPlanned
                        ||
                    assertPlanned == null && !this.isDoneCorrectly()
                )
            )
        },
        
        
        isFailedWithException : function () {
            return this.failed
        },
        
        
        isStarted : function () {
            return this.startDate != null
        },
        
        
        isFinished : function () {
            return this.endDate != null
        },
        
        
        getDuration : function () {
            return this.endDate - this.startDate
        },
        
        
        getBubbleTarget : function () {
            return this.parent || this.harness;
        },
        
        
        warn : function (message) {
            this.addResult(new Siesta.Result.Diagnostic({
                description : message,
                isWarning   : true
            }))
        },
        
        
        flattenArray : function (array) {
            var me          = this
            var result      = []
            
            Joose.A.each(array, function (el) {
                if (me.typeOf(el) == 'Array') 
                    result.push.apply(result, me.flattenArray(el))
                else
                    result.push(el)
            })
            
            return result
        }
    }
    // eof methods
        
})
//eof Siesta.Test;
Singleton('Siesta.Test.ActionRegistry', {
    
    has : {
        actionClasses       : Joose.I.Object,
        
        targetShortcuts     : function () {
            return [ 
                'waitFor', 
                'click', 
                'rightClick', 
                'doubleClick', 
                'dblClick',
                'doubleTap', 
                'drag', 
                'longpress', 
                'mouseDown', 
                'mouseUp', 
                'moveCursorTo', 
                'swipe', 
                'tap', 
                'type' 
            ]
        }
    },

    
    methods : {
        
        registerAction : function (name, constructor) {
            this.actionClasses[ name.toLowerCase() ] = constructor
        },

        
        getActionClass : function (name) {
            return this.actionClasses[ name.toLowerCase() ]
        },
        
        
        create : function (obj) {
            if (obj !== Object(obj)) throw "Action configuration should be an Object instance"
            
            if (!obj.action) {
                var lowerCasedKeys      = {}
                
                Joose.O.eachOwn(obj, function (value, key) {
                    lowerCasedKeys[ key.toLowerCase() ] = key
                })
                
                var me                  = this
                
                Joose.A.each(this.targetShortcuts, function (shortcut) {
                    shortcut            = shortcut.toLowerCase()
                    
                    if (lowerCasedKeys.hasOwnProperty(shortcut)) {
                        obj.action      = shortcut
                        
                        switch (shortcut) {
                            case 'waitfor'  : 
                            // do nothing 
                            break
                            
                            case 'type'     :
                                obj.text        = obj[ lowerCasedKeys[ shortcut ] ]
                            break
                                
                            default         : 
                                obj.target      = obj[ lowerCasedKeys[ shortcut ] ]
                        }
                        
                        return false
                    }
                })
            }
            
            if (!obj.action) throw "Need to include `action` property or shortcut property in the step config"
            
            var actionClass = this.getActionClass(obj.action)

            return new actionClass(obj)
        }
    }
});
;
/**
@class Siesta.Test.Action

Base class for {@link Siesta.Test#chain} actions.

*/
Class('Siesta.Test.Action', {
    
    has : {
        args                : null, 
        
        /**
         * @cfg {String} desc When provided, once step is completed, a passing assertion with this text will be added to a test.
         * This configuration option can be useful to indicate the progress of "wait" steps  
         */
        desc                : null,
        test                : { required : true },
        next                : { required : true },
        
        requiredTestMethod  : null
    },

    
    methods : {
        
        initialize : function () {
            var requiredTestMethod  = this.requiredTestMethod
            
            // additional sanity check
            if (requiredTestMethod && !this.test[ requiredTestMethod ]) 
                throw new Error("Action [" + this + "] requires `" + requiredTestMethod + "` method in your test class") 
        },
        
        
        process : function () {
            this.next()
        }
    }
});
;
/**

@class Siesta.Test.Action.Done
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with "done" shortcut:

    t.chain(
        {
            action      : 'done'
        }
    )

This action will just call the {@link Siesta.Test#done done} method of the test.

*/
Class('Siesta.Test.Action.Done', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Number} delay
         * 
         * An optional `delay` argument for {@link Siesta.Test#done done} call.
         */
        delay  :        null
    },

    
    methods : {
        
        process : function () {
            this.test.done(this.delay)
            
            this.next()
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('done', Siesta.Test.Action.Done);
/**

@class Siesta.Test.Action.Wait
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with "wait" or "delay" shortcuts:

    t.chain(
        {
            action      : 'wait',   // or "delay"
            delay       : 1000      // 1 second
        }
    )

Alternatively, for convenience, this action can be included in the chain using "waitFor" config (the "action" property can be omitted):

    t.chain(
        {
            waitFor     : 'selector',           // or any other waitFor* method name
            args        : [ '.x-grid-row' ]     // an array of arguments for the specified method
        }
    )
    
    t.chain(
        {
            waitFor     : 'rowsVisible',        // or any other waitFor* method name
            args        : [ grid ]              // an array of arguments for the specified method
        }
    )
    
    t.chain(
        {
            waitFor     : 'waitForRowsVisible', // full method name is also ok
            args        : grid                  // a single value will be converted to array automatically
        }
    )
    
In the latter case, this action will perform a call to the one of the `waitFor*` methods of the test instance.
The name of the method is computed by prepending the uppercased value of `waitFor` config with the string "waitFor" 
(unless it doesn't already start with "waitFor").
The arguments for method call can be provided as the "args" array. Any non-array value for "args" will be converted to an array with one element.
* **Note**, that this action will provide a `callback`, `scope`, and `timeout` arguments for `waitFor*` methods - you should not specify them. 


As a special case, the value of `waitFor` config can be a Number or Function - that will trigger the call to {@link Siesta.Test#waitFor} method with provided value:

    t.chain(
        {
            waitFor     : 500
        },
        // same as
        {
            waitFor     : '',
            args        : [ 500 ] 
        },
        {
            waitFor     : function () { return document.body.className.match(/someClass/) }
        }
    )

*/
Class('Siesta.Test.Action.Wait', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Number} delay
         * 
         * A number of milliseconds to wait before continuing.
         */
        delay           : 1000,
        
        /**
         * @cfg {Number} timeout
         * 
         * The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        timeout         : null,

        /**
         * @cfg {Array/Function} args
         * 
         * The array of arguments to pass to waitForXXX method. You should omit the 3 last parameters: callback, scope, timeout. Any non-array value will be converted to 
         * a single-value array. Can be also a function, returning either an array of a single value, which will be converted to array.
         * Function will be called using test instance as a "this" scope.
         * If you need to pass a function, as an argument, wrap in the array. Compare: 
    {
        waitFor : 'SomeCondition',
        // will be called when processing the action, should return an array of arguments
        args    : function () {} 
    }
    
    {
        waitFor : 'SomeCondition',
        // won't be called, instead will be passed as 1st argument
        args    : [ function () {} ] 
    }
         *  
         */
        args            : null,

        /**
         * @cfg {String} waitFor
         * 
         * The name of the `waitFor` method to call. You can omit the leading "waitFor":
         * 

    t.chain(
        {
            waitFor     : 'selector',
            ...
        },
        // same as
        {
            waitFor     : 'waitForSelector',
            ...
        }
    )
         * 
         */
        waitFor         : null
    },

    
    methods : {
        
        process : function () {
            var waitFor     = this.waitFor;
            var test        = this.test

            if (test.typeOf(waitFor) === 'Number' || test.typeOf(waitFor) === 'Function') {
                // Caller supplied a function returning true when done waiting or
                // a number of milliseconds to wait for.
                this.args   = [ waitFor ];
                waitFor     = '';
            }
            
            if (waitFor == null) {
                this.args   = [ this.delay ];
                waitFor     = '';
            }
            
            if (test.typeOf(this.args) === "Function") {
                this.args   = this.args.call(test, this);
            }
            
            if (test.typeOf(this.args) !== "Array") {
                this.args   = [ this.args ];
            }

            // also allow full method names
            waitFor         = waitFor.replace(/^waitFor/, '')
            var methodName  = 'waitFor' + Joose.S.uppercaseFirst(waitFor);
            
            if (!test[methodName]){
                throw 'Could not find a waitFor method named ' + methodName;
            }

            // If using simple waitFor statement, use the object notation to be able to pass a description
            // which gives better debugging help than "Waited too long for condition to be fulfilled".
            if (methodName === 'waitFor') {
                test[methodName]({
                    method          : this.args[ 0 ],
                    callback        : this.next,
                    scope           : test,
                    timeout         : this.timeout || test.waitForTimeout,
                    description     : this.desc || ''
                });
            } else {
                test[methodName].apply(test, this.args.concat(this.next, test, this.timeout || test.waitForTimeout));
            }
        }
    }
});

Joose.A.each([ 'wait', 'waitFor', 'delay' ], function(name) {
    Siesta.Test.ActionRegistry().registerAction(name, Siesta.Test.Action.Wait);
});;
/**

@class Siesta.Test.Action.Eval
@extends Siesta.Test.Action

This action can be included in the `t.chain` steps only with a plain string. Siesta will examine the passed string,
and call an apropriate method of the test class. String should have the following format: 
    
    methodName(params) 

Method name is anything until the first parenthes. Method name may have an optional prefix `t.`. 
Everything in between of outermost parentheseswill be treated as parameters for method call. For example:

    t.chain(
        // string should look like a usual method call, 
        // but arguments can't reference any variables
        // strings should be quoted, to include quoting symbol in string use double slash: \\
        't.click("combo[type=some\\"Type] => .x-form-trigger")',
        
        // leading "t." is optional, but quoting is not
        'waitForComponent("combo[type=someType]")',
        
        // JSON objects are ok, but they should be a valid JSON - ie object properties should be quoted
        'myClick([ 10, 10 ], { "foo" : "bar" })',
    )
    
* **Note** You can pass the JSON objects as arguments, but they should be serialized as valid JSON - ie object properties should be quoted.
    
* **Note** A callback for next step in chain will be always appended to provided parameters. Make sure it is placed in a correct spot!
For example if method signature is `t.someMethod(param1, param2, callback)` and you are calling this method as:
    
    t.chain(
        `t.someMethod("text")`
    )
it will fail - callback will be provided in place of `param2`. Instead call it as: 
    
    t.chain(
        `t.someMethod("text", null)`
    )

This action may save you few keystrokes, when you need to perform some action with static arguments (known prior the action).

*/
Class('Siesta.Test.Action.Eval', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        actionString        : null
    },

    
    methods : {
        
        process : function () {
            var test            = this.test
            var parsed          = this.parseActionString(this.actionString)
            
            if (parsed.error) {
                test.fail(parsed.error)
                this.next()
                return
            }
            
            var methodName      = parsed.methodName
            
            if (!methodName || test.typeOf(test[ methodName ]) != 'Function') {
                test.fail("Invalid method name: " + methodName)
                this.next()
                return
            }
            
            parsed.params.push(this.next)
            
            test[ methodName ].apply(test, parsed.params)
        },
        
        
        parseActionString : function (actionString) {
            var match           = /^\s*(.+?)\(\s*(.*)\s*\)\s*$/.exec(actionString)
            
            if (!match) return {
                error       : "Wrong format of the action string: " + actionString
            }
            
            var methodName      = match[ 1 ].replace(/^t\./, '')
            
            try {
                var params      = JSON.parse('[' + match[ 2 ] + ']')
            } catch (e) {
                return {
                    error       : "Can't parse arguments: " + match[ 2 ]
                }
            }
            
            return {
                methodName      : methodName,
                params          : params
            }
        }
    }
});
;
/**

@class Siesta.Harness
@mixin Siesta.Role.CanStyleOutput

`Siesta.Harness` is an abstract base harness class in Siesta hierarchy. This class provides no UI, 
you should use one of it subclasses, for example {@link Siesta.Harness.Browser}

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.


Synopsys
========

    var Harness,
        isNode        = typeof process != 'undefined' && process.pid
    
    if (isNode) {
        Harness = require('siesta');
    } else {
        Harness = Siesta.Harness.Browser;
    }
        
    
    Harness.configure({
        title     : 'Awesome Test Suite',
        
        transparentEx       : true,
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],
        
        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })
    
    
    Harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
        
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
            
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
        
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
            
            autoCheckGlobals    : false,
            
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/


Class('Siesta.Harness', {
    
    does        : [
        JooseX.Observable
    ],
    
    has : {
        /**
         * @cfg {String} title The title of the test suite. Can contain HTML. When provided in the test file descriptor - will change the name of test in the harness UI.
         */
        title               : null,
        
        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test}.
         * You can subclass {@link Siesta.Test} and provide a new class. 
         * 
         * This option can be also specified in the test file descriptor. 
         */
        testClass           : Siesta.Test,
        contentManagerClass : Siesta.Content.Manager,
        
        // fields of test descriptor:
        // - id - either `url` or wbs + group - computed
        // - url
        // - isMissing - true if test file is missing
        // - testCode - a test code source (can be provided by user)
        // - testConfig - config object provided to the StartTest
        // - index - (in the group) computed
        // - scopeProvider
        // - scopeProviderConfig
        // - preload
        // - alsoPreload
        // - parent - parent descriptor (or harness for top-most ones) - computed
        // - preset - computed by harness - instance of Siesta.Content.Preset
        // - forceDOMVisible - true to show the <iframe> on top of all others when running this test
        //                     (required for IE when using "document.getElementFromPoint()") 
        // OR - object 
        // - group - group name
        // - items - array of test descriptors
        // - expanded - initial state of the group (true by default)
        descriptors         : Joose.I.Array,
        descriptorsById     : Joose.I.Object,
        
        launchCounter       : 0,
        
        launches            : Joose.I.Object,
        
        scopesByURL         : Joose.I.Object,
        testsByURL          : Joose.I.Object,
        
        /**
         * @cfg {Boolean} transparentEx When set to `true` harness will not try to catch any exception, thrown from the test code.
         * This is very useful for debugging - you can for example use the "break on error" option in Firebug.
         * But, using this option may naturally lead to unhandled exceptions, which may leave the harness in incosistent state - 
         * refresh the browser page in such case.
         *  
         * Defaults to `false` - harness will do its best to detect any exception thrown from the test code.
         * 
         * This option can be also specified in the test file descriptor. 
         */
        transparentEx       : false,
        
        scopeProviderConfig     : null,
        scopeProvider           : null,
        
        /**
         * @cfg {String} runCore Either `parallel` or `sequential`. Indicates how the individual tests should be run - several at once or one-by-one.
         * Default value is "parallel". You do not need to change this option usually.
         */
        runCore                 : 'parallel',
        
        /**
         * @cfg {Number} maxThreads The maximum number of tests running at the same time. Only applicable for `parallel` run-core.
         */
        maxThreads              : 4,
        
        /**
         * @cfg {Boolean} autoCheckGlobals When set to `true`, harness will automatically issue an {@link Siesta.Test#verifyGlobals} assertion at the end of each test,
         * so you won't have to manually specify it each time. The assertion will be triggered only if test completed successfully. Default value is `false`.
         * See also {@link #expectedGlobals} configuration option and {@link Siesta.Test#expectGlobals} method.
         * 
         * This option will be always disabled in Opera, since every DOM element with `id` is being added as a global symbol in it.
         * 
         * This option can be also specified in the test file descriptor.
         */
        autoCheckGlobals        : false,
        
        disableGlobalsCheck     : false,
        
        /**
         * @cfg {Array} expectedGlobals An array of properties names which are likely to present in the scope of each test. There is no need to provide the name
         * of built-in globals - harness will automatically scan them from the empty context. Only provide the names of global properties which will be created
         * by your preload code.
         * 
         * For example
         * 
    Harness.configure({
        title               : 'Ext Scheduler Test Suite',
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'MyProject',
            'SomeExternalLibrary'
        ],
        ...
    })
            
         * This option can be also specified in the test file descriptor.
         */
        expectedGlobals         : Joose.I.Array,
        // will be populated by `populateCleanScopeGlobals` 
        cleanScopeGlobals       : Joose.I.Array,
        
        /**
         * @cfg {Array} preload The array which contains the *preload descriptors* describing which files/code should be preloaded into the scope of each test.
         * 
         * Preload descriptor can be:
         * 
         * - a string, containing an url to load (cross-domain urls are ok, if url ends with ".css" it will be loaded as CSS)
         * - an object `{ type : 'css/js', url : '...' }` allowing to specify the CSS files with different extension
         * - an object `{ type : 'css/js', content : '...' }` allowing to specify the inline content for script / style. The content should only be the tag content - not the tag itself, it'll be created by Siesta.
         * - an object `{ text : '...' }` which is a shortcut for `{ type : 'js', content : '...' }`
         * 
         * For example:
         * 
    Harness.configure({
        title           : 'Ext Scheduler Test Suite',
        
        preload         : [
            'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            {
                text    : 'MySpecialGlobalFunc = function () { if (typeof console != "undefined") ... }'
            }
        ],
        ...
    })
            
         * This option can be also specified in the test file descriptor. **Note**, that if test descriptor has non-empty {@link Siesta.Harness.Browser#hostPageUrl hostPageUrl}
         * option, then *it will not inherit* the `preload` option from parent descriptors or harness, **unless** it has the `preload` config set to string `inherit`. 
         * If both `hostPageUrl` and `preload` are set on the harness level, `preload` value still will be inherited. For example:
         *
    Harness.configure({
        hostPageUrl     : 'general-page.html',
        preload         : [ 'my-file.js' ],
        ...
    })
    
    Harness.start(
        // this test will inherit both `hostPageUrl` and `preload`
        'test1.js',
        {
            // no preloads inherited
            hostPageUrl     : 'host-page.html',
            url             : 'test2.js'
        }, 
        {
            // inherit `preload` value from the upper level - [ 'my-file.js' ]
            hostPageUrl     : 'host-page.html',
            preload         : 'inherit',
            url             : 'test3.js'
        }, 
        {
            group           : 'Some group',
            hostPageUrl     : 'host-page2.html',
            preload         : 'inherit',
            
            items           : [
                // inherit `hostPageUrl` value from the group
                // inherit `preload` value from the upper level - [ 'my-file.js' ]
                url             : 'test3.js'
            ]
        }
    )
    
         * When using the code coverage feature, one need to explicitly mark the JavaScript files that needs to be instrumented with the "instrument : true".
         * See {@link Siesta.Harness.Browser#enableCodeCoverage} for details.
         * 

    Harness.configure({
        preload         : [
            {
                type        : 'js',
                url         : 'some_file.js',
                instrument  : true
            }
        ],
        ...
    })


         *     
         *     
         */
        preload                 : Joose.I.Array,
        
        /**
         * @cfg {Array} alsoPreload The array with preload descriptors describing which files/code should be preloaded **additionally**.
         * 
         * This option can be also specified in the test file descriptor.
         */
        
        /**
         * @cfg {Object} listeners The object which keys corresponds to event names and values - to event handlers. If provided, the special key "scope" will be treated as the 
         * scope for all event handlers, otherwise the harness itself will be used as scope.
         * 
         * Note, that the events from individual {@link Siesta.Test test cases} instances will bubble up to the harness - you can listen to all of them in one place: 
         * 

    Harness.configure({
        title     : 'Awesome Test Suite',
        
        preload : [
            'http://cdn.sencha.io/ext-4.1.0-gpl/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.1.0-gpl/ext-all-debug.js',
            
            'preload.js'
        ],
        
        listeners : {
            testsuitestart      : function (event, harness) {
                log('Test suite is starting: ' + harness.title)
            },
            testsuiteend        : function (event, harness) {
                log('Test suite is finishing: ' + harness.title)
            },
            teststart           : function (event, test) {
                log('Test case is starting: ' + test.url)
            },
            testupdate          : function (event, test, result) {
                log('Test case [' + test.url + '] has been updated: ' + result.description + (result.annotation ? ', ' + result.annotation : ''))
            },
            testfailedwithexception : function (event, test) {
                log('Test case [' + test.url + '] has failed with exception: ' + test.failedException)
            },
            testfinalize        : function (event, test) {
                log('Test case [' + test.url + '] has completed')
            }
        }
    })

         */
        
        
        /**
         * @cfg {Boolean} cachePreload When set to `true`, harness will cache the content of the preload files and provide it for each test, instead of loading it 
         * from network each time. This option may give a slight speedup in tests execution (especially when running the suite from the remote server), but see the 
         * caveats below. Default value is `false`.
         * 
         * Caveats: this option doesn't work very well for CSS (due to broken relative urls for images). Also its not "debugging-friendly" - as you will not be able 
         * to setup breakpoints for cached code. 
         */
        cachePreload            : false,
        
        mainPreset              : null,
        emptyPreset             : null,
        
        verbosity               : 0,
        
        /**
         * @cfg {Boolean} keepResults When set to `true`, harness will not cleanup the context of the test immediately. Instead it will do so, only when
         * the test will run again. This will allow you for example to examine the DOM of tests. Default value is `true` 
         */
        keepResults             : true,
        
        /**
         * @cfg {Number} keepNLastResults
         * 
         * Only meaningful when {@link #keepResults} is set to `false`. Indicates the number of the test results which still should be kept, for user examination.
         * Results are cleared when their total number exceed this value, based on FIFO order.
         */
        keepNLastResults        : 2,
        
        lastResultsURLs         : Joose.I.Array,
        lastResultsByURL        : Joose.I.Object,
        
        /**
         * @cfg {Boolean} overrideSetTimeout When set to `true`, the tests will override the native "setTimeout" from the context of each test
         * for asynchronous code tracking. If setting it to `false`, you will need to use `beginAsync/endAsync` calls to indicate that test is still running.
         * 
         * This option can be also specified in the test file descriptor. Defaults to `false`.
         */
        overrideSetTimeout      : false,
        
        /**
         * @cfg {Boolean} needDone When set to `true`, the tests will must indicate that that they have reached the correct exit point with `t.done()` call, 
         * after which, adding any assertions is not allowed. Using this option will ensure that test did not exit prematurely with some exception silently caught.
         * 
         * This option can be also specified in the test file descriptor.
         */
        needDone                : false,
        
        needToStop              : false,
        
        // the default timeout for tests will be increased when launching more than this number of files
        increaseTimeoutThreshold    : 8,
        
        // the start and end dates for the most recent `launch` method
        startDate               : null,
        endDate                 : null,
        
        /**
         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000.
         * 
         * This option can be also specified in the test file descriptor.
         */
        waitForTimeout          : 10000,
        
        /**
         * @cfg {Number} defaultTimeout Default timeout for `beginAsync` operation (in milliseconds). Default value is 15000.
         * 
         * This option can be also specified in the test file descriptor.
         */
        defaultTimeout          : 15000,
        
        /**
         * @cfg {Number} subTestTimeout Default timeout for sub tests. Default value is twice bigger than {@link #defaultTimeout}.
         * 
         * This option can be also specified in the test file descriptor.
         */
        subTestTimeout          : null,
        
        /**
         * @cfg {Number} isReadyTimeout Default timeout for test start (in milliseconds). Default value is 15000. See {@link Siesta.Test#isReady} for details.
         * 
         * This option can be also specified in the test file descriptor.
         */
        isReadyTimeout          : 10000,
        
        /**
         * @cfg {Number} pauseBetweenTests Default timeout between tests (in milliseconds). Increase this settings for big test suites, to give browser time for memory cleanup.
         */
        pauseBetweenTests       : 300,
        
        setupDone               : false,
        
        sourceLineForAllAssertions      : false
    },
    
    
    methods : {
        
        initialize : function () {
            var me      = this
            
            me.on('testupdate', function (event, test, result, parentResult) {
                me.onTestUpdate(test, result, parentResult);
            })
            
            me.on('testfailedwithexception', function (event, test, exception, stack) {
                me.onTestFail(test, exception, stack);
            })
            
            me.on('teststart', function (event, test) {
                me.onTestStart(test);
            })
            
            me.on('testfinalize', function (event, test) {
                me.onTestEnd(test);
            })
        },
        
        onTestUpdate : function (test, result, parentResult) {
        },
        
        
        onTestFail : function (test, exception, stack) {
        },
        
        
        onTestStart : function (test) {
        },
        
        
        onTestEnd : function (test) {
        },
        
        
        onTestSuiteStart : function (descriptors, contentManager) {
            this.startDate  = new Date()
            
            /**
             * This event is fired when the test suite starts. Note, that when running the test suite in the browsers, this event can be fired several times
             * (for each group of tests you've launched).  
             * 
             * You can subscribe to it, using regular ExtJS syntax:
             * 
             *      Harness.on('testsuitestart', function (event, harness) {}, scope, { single : true })
             * 
             * See also the "/examples/events"
             * 
             * @event testsuitestart
             * @member Siesta.Harness
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Harness} harness The harness that just has started
             */
            this.fireEvent('testsuitestart', this)
        },
        
        
        onTestSuiteEnd : function (descriptors, contentManager) {
            this.endDate    = new Date()
            
            /**
             * This event is fired when the test suite ends. Note, that when running the test suite in the browsers, this event can be fired several times
             * (for each group of tests you've launched).  
             * 
             * @event testsuiteend
             * @member Siesta.Harness
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Harness} harness The harness that just has ended
             */
            this.fireEvent('testsuiteend', this)
        },
        
        
        onBeforeScopePreload : function (scopeProvider, url) {
            this.fireEvent('beforescopepreload', scopeProvider, url)
        },
        
        
        onAfterScopePreload : function (scopeProvider, url) {
            this.fireEvent('afterscopepreload', scopeProvider, url)
        },
        
        
        onCachingError : function (descriptors, contentManager) {
        },
        
        
        /**
         * This method configures the harness instance. It just copies the passed configuration option into harness instance.
         *
         * @param {Object} config - configuration options (values of attributes for this class)
         */
        configure : function (config) {
            Joose.O.copy(config, this)
            
            var me      = this
            
            if (config.listeners) Joose.O.each(config.listeners, function (value, name) {
                if (name == 'scope') return
                
                me.on(name, value, config.scope || me)
            })
        },
        
        
        // backward compat
        processPreloadArray : function (preload) {
            var me = this
            
            Joose.A.each(preload, function (url, index) {
                
                // do not process { text : "" } preload descriptors
                if (Object(url) === url) return 
                
                preload[ index ] = me.normalizeURL(url)
            })
            
            return preload
        },
        
        
        populateCleanScopeGlobals : function (scopeProvider, callback) {
            var scopeProviderClass  = eval(scopeProvider)
            var cleanScope          = new scopeProviderClass()
            
            var cleanScopeGlobals   = this.cleanScopeGlobals        
            
            // we can also use "create" and not "setup" here
            // create will only create the iframe (in browsers) and will not try to update its content
            // the latter crashes IE8
            cleanScope.setup(function () {
                
                for (var name in cleanScope.scope) cleanScopeGlobals.push(name)
                
                callback()
                
                // this setTimeout seems to stop the spinning loading indicator in FF
                // accorting to https://github.com/3rd-Eden/Socket.IO/commit/bad600fb1fb70238f42767c56f01256470fa3c15
                // it only works *after* onload (this callback will be called *in* onload)
                
                setTimeout(function () {
                    // will remove the iframe (in case of browser harness) from DOM and stop loading indicator
                    cleanScope.cleanup()    
                }, 0)
            })
        },
        
        
        startSingle : function (desc, callback) {
            var me              = this
            
            this.__counter__    = this.__counter__ || 0 
            
            var startSingle     = function () {
                me.launch([ me.normalizeDescriptor(desc, me, me.__counter__++) ], callback)
            }
            
            me.setupDone ? startSingle() : this.setup(startSingle)
        },
        
        
        setup : function (callback) {
            var me              = this
            
            this.mainPreset     = new Siesta.Content.Preset({
                preload     : this.processPreloadArray(this.preload)
            })
            
            this.emptyPreset    = new Siesta.Content.Preset()
            
            this.populateCleanScopeGlobals(this.scopeProvider, function () {
                me.setupDone        = true
                
                callback()
            })
        },
        
        /**
         * This method will launch a test suite. It accepts a variable number of *test file descriptors* or an array of such. A test file descritor is one of the following:
         * 
         * - a string, containing a test file url
         * - an object containing the `url` property `{ url : '...', option1 : 'value1', option2 : 'value2' }`. The `url` property should point to the test file.
         * Other properties can contain values of some configuration options of the harness (marked accordingly). In this case, they will **override** the corresponding values,
         * provided to harness or parent descriptor. 
         * - an object `{ group : 'groupName', items : [], expanded : true, option1 : 'value1' }` specifying the folder of test files. The `expanded` property
         * sets the initial state of the folder - "collapsed/expanded". The `items` property can contain an array of test file descriptors.
         * Other properties will override the applicable harness options **for all child descriptors**.
         * 
         * If test descriptor is `null` or other "falsy" value it is ignored.
         * 
         * Groups (folder) may contain nested groups. Number of nesting levels is not limited.
         * 
         * For example, one may easily have a special group of test files, having its own preload configuration (for example for testing on-demand loading). In the same
         * time some test in that group may have its own preload, overriding others.

    Harness.configure({
        title           : 'Ext Scheduler Test Suite',
        preload         : [
            'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            '../awesome-app-all-debug.js'
        ],
        ...
    })
    
    Harness.start(
        // regular file
        'data/crud.t.js',
        // a group with own "preload" config for its items
        {
            group       : 'On-demand loading',
            
            preload     : [
                'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
                'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            ],
            items       : [
                'ondemand/sanity.t.js',
                'ondemand/special-test.t.js',
                // a test descriptor with its own "preload" config (have the most priority)
                {
                    url         : 'ondemand/4-0-6-compat.t.js',
                    preload     : [
                        'http://cdn.sencha.io/ext-4.0.6/resources/css/ext-all.css',
                        'http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js',
                    ]
                },
                // sub-group
                {
                    group       : 'Sub-group',
                    items       : [
                        ...
                    ]
                }
            ]
        },
        ...
    )

         * Additionally, you can provide a test descriptor in the test file itself, adding it as the 1st or 2nd argument for `StartTest` call:  
         * 
    StartTest({
        autoCheckGlobals    : false,
        alsoPreload         : [ 'some_additional_preload.js' ]
    }, function (t) {
        ...
    }) 
         * 
         * Values from this object takes the highest priority and will override any other configuration.
         * 
         * @param {Array/Mixed} descriptor1 or an array of descriptors
         * @param {Mixed} descriptor2
         * @param {Mixed} descriptorN
         */
        start : function () {
            // a bit hackish - used by Selenium reporter..
            var me      = Siesta.my.activeHarness = this
            var args    = Array.prototype.concat.apply([], arguments)
            
            this.setup(function () {
                me.normalizeDescriptors(args)
                
                me.launch(me.descriptors)
            })
        },
        
        
        // good to have this as a seprate method for testing
        normalizeDescriptors : function (descArray) {
            var me              = this
            
            var descriptors     = []
            
            Joose.A.each(descArray, function (desc, index) {
                if (desc) descriptors.push(me.normalizeDescriptor(desc, me, index))
            })
            
            me.descriptors      = descriptors
        },

        
        launch : function (descriptors, callback, errback) {
            var launchId                = this.launchCounter++
            var launchData              = this.launches[ launchId ] = {}
            
            var me                      = this
            
            //console.time('launch')
            //console.time('launch-till-preload')
            //console.time('launch-after-preload')
            
            this.needToStop             = false
            
            // no folders, only leafs
            var flattenDescriptors      = this.flattenDescriptors(descriptors)
            var testScriptsPreset       = new Siesta.Content.Preset()
            var presets                 = [ testScriptsPreset, this.mainPreset ]
            
            Joose.A.each(flattenDescriptors, function (desc) { 
                if (desc.preset != me.mainPreset && desc.preset != me.emptyPreset) presets.push(desc.preset)
                
                if (!desc.testCode) testScriptsPreset.addResource(desc.url)
                
                me.deleteTestByURL(desc.url)
            })
            
            // cache either everything (this.cachePreload) or only the test files (to be able to show missing files / show content) 
            var contentManager  = launchData.contentManager = new this.contentManagerClass({
                harness         : this,
                presets         : [ testScriptsPreset ].concat(this.cachePreload ? presets : [])
            })
            
            var options         = {
                increaseTimeout     : this.runCore == 'parallel' && flattenDescriptors.length > this.increaseTimeoutThreshold,
                launchId            : launchId
            }
            
            //console.time('caching')
            
            me.onTestSuiteStart(descriptors, contentManager)
            
            contentManager.cache(function () {
                
                //console.timeEnd('caching')
                
                Joose.A.each(flattenDescriptors, function (desc) {
                    var url             = desc.url
                    
                    if (contentManager.hasContentOf(url)) {
                        var testConfig  = desc.testConfig = Siesta.getConfigForTestScript(contentManager.getContentOf(url))
                        
                        // if testConfig contains the "preload" or "alsoPreload" key - then we need to update the preset of the descriptor
                        if (testConfig && (testConfig.preload || testConfig.alsoPreload)) desc.preset = me.getDescriptorPreset(desc)
                    } else
                        // if test code is provided, then test is considered not missing 
                        // allow subclasses to define there own logic when found missing test file
                        if (!desc.testCode) me.markMissingFile(desc)
                        
                    me.normalizeScopeProvider(desc)
                })
                
                me.fireEvent('testsuitelaunch', descriptors, contentManager)
                
                me.runCoreGeneral(flattenDescriptors, contentManager, options, function () {
                    me.onTestSuiteEnd(descriptors, contentManager)
                    
                    callback && callback(descriptors)
                    
                    delete me.launches[ launchId ]
                })
                
            }, function () {}, true)
        },
        
        
        markMissingFile : function (desc) {
            desc.isMissing = true
        },
        
        
        flattenDescriptors : function (descriptors, includeFolders) {
            var flatten     = []
            var me          = this
            
            Joose.A.each(descriptors, function (descriptor) {
                
                if (descriptor.group) {
                    
                    if (includeFolders) flatten.push(descriptor)
                    
                    flatten.push.apply(flatten, me.flattenDescriptors(descriptor.items, includeFolders))
                    
                } else
                    flatten.push(descriptor)
            })
            
            return flatten
        },
        
        
        lookUpValueInDescriptorTree : function (descriptor, configName, doNotLookAtRoot) {
            var testConfig  = descriptor.testConfig
            
            if (testConfig && testConfig.hasOwnProperty(configName))    return testConfig[ configName ]
            if (descriptor.hasOwnProperty(configName))                  return descriptor[ configName ]
            
            var parent  = descriptor.parent
            
            if (parent) {
                if (parent == this)
                    if (doNotLookAtRoot) 
                        return undefined
                    else
                        return this[ configName ]
                
                return this.lookUpValueInDescriptorTree(parent, configName, doNotLookAtRoot)
            }
            
            return undefined
        },
        

        getDescriptorConfig : function (descriptor, configName, doNotLookAtRoot) {
            return this.lookUpValueInDescriptorTree(descriptor, configName, doNotLookAtRoot)
        },
        
        
        getDescriptorPreset : function (desc) {
            var preload                 = this.getDescriptorConfig(desc, 'preload', true)
            var alsoPreload             = this.getDescriptorConfig(desc, 'alsoPreload', true)
            
            if (preload || alsoPreload) {
                var totalPreload        = (preload || this.preload).concat(alsoPreload || [])
                
                // filter out empty array as preloads - return `emptyPreset` for them
                return totalPreload.length ? new Siesta.Content.Preset({ preload : this.processPreloadArray(totalPreload) }) : this.emptyPreset
            }
                
            return this.mainPreset
        },
        
        
        normalizeScopeProvider : function (desc) {
            var scopeProvider = this.getDescriptorConfig(desc, 'scopeProvider')
            
            if (scopeProvider) {
                var match 
                
                if (match = /^=(.+)/.exec(scopeProvider))
                    scopeProvider = match[ 1 ]
                else 
                    scopeProvider = scopeProvider.replace(/^(Scope\.Provider\.)?/, 'Scope.Provider.')
            }
            
            desc.scopeProvider          = scopeProvider
            desc.scopeProviderConfig    = this.getDescriptorConfig(desc, 'scopeProviderConfig') 
        },
        
        
        normalizeDescriptor : function (desc, parent, index, level) {
            if (typeof desc == 'string') desc = { url : desc }
            
            level       = level || 0
            
            var me      = this
            
            desc.parent = parent
            
            // folder
            if (desc.group) {
                desc.id     = parent == this ? 'testFolder-' + level + '-' + index : parent.id + '/' + level + '-' + index
                
                var items   = []
                
                Joose.A.each(desc.items || [], function (subDesc, index) {
                    if (subDesc) items.push(me.normalizeDescriptor(subDesc, desc, index, level + 1))
                })
                
                desc.items  = items
                
            } else {
                // leaf case
                desc.id                     = desc.url
                desc.preset                 = this.getDescriptorPreset(desc)
                
                // the only thing left to normlize in the descriptor is now "scopeProvider"
                // we postpone this normalization to the moment after loading of the test files, 
                // since they can also contain "scopeProvider"-related configs
                // see "normalizeScopeProvider"
            }
            
            this.descriptorsById[ desc.id ] = desc
            
            return desc
        },
        
        
        runCoreGeneral : function (descriptors, contentManager, options, callback) {
            var runCoreMethod   = 'runCore' + Joose.S.uppercaseFirst(this.runCore)
            
            if (typeof this[ runCoreMethod ] != 'function') throw new Error("Invalid `runCore` specified: [" + this.runCore + "]")
            
            this[ runCoreMethod ](descriptors, contentManager, options, callback)
        },
        
        
        runCoreParallel : function (descriptors, contentManager, options, callback) {
            var me              = this
            var processedNum    = 0
            var count           = descriptors.length
            
            if (!count) callback()
            
            var exitLoop                = false
            var hasExited               = false
            var hasLaunchedAllThreads   = false
            
            var doProcessURL  = function (desc) {
                me.processURL(desc, desc.index, contentManager, options, function () {
                    processedNum++
                    
                    // set the internal closure `exitLoop` to stop launching new branches
                    // on the 1st encountering of `me.needToStop` flag
                    if (me.needToStop || exitLoop) {
                        exitLoop = true
                        
                        if (!hasExited) {
                            hasExited = true
                            callback()
                        }
                        
                        return
                    }
                    
                    if (processedNum == count) 
                        callback()
                    else
                        launchThread(descriptors)
                })
            }
            
            var launchThread  = function (descriptors) {
                var desc = descriptors.shift()
                
                if (!desc) return
                
                if (hasLaunchedAllThreads)
                    setTimeout(function () {
                        doProcessURL(desc)
                    }, me.pauseBetweenTests)
                else
                    doProcessURL(desc)
            }
            
            for (var i = 1; i <= this.maxThreads; i++) launchThread(descriptors)
            
            hasLaunchedAllThreads = true
        },
        
        
        runCoreSequential : function (descriptors, contentManager, options, callback) {
            if (descriptors.length && !this.needToStop) {
                var desc = descriptors.shift()
                
                var me = this
                
                this.processURL(desc, desc.index, contentManager, options, function () {

                    if (descriptors.length)
                        setTimeout(function () {
                            me.runCoreSequential(descriptors, contentManager, options, callback)
                        }, me.pauseBetweenTests)
                    else
                        callback()
                })
                
            } else
                callback()
        },
        
        
        getSeedingCode : function (desc, launchId) {
            var code    = function (descId, launchId) {
                StartTest = startTest = describe = function () { arguments.callee.args = arguments };
                
                StartTest.launchId          = launchId
                StartTest.id                = descId
                
                // for older IE - the try/catch should be from the same context as the exception
                StartTest.exceptionCatcher  = function (func) { var ex; try { func() } catch (e) { ex = e; }; return ex; };
                
                // for Error instances we try to pick up the values from "message" or "description" property
                // so need to have a correct constructor from the context of test
                StartTest.testErrorClass    = Error;
            }
            
            return ';(' + code.toString() + ')(' + JSON.stringify(desc.id) + ', ' + launchId + ')'
        },
        
        
        getScopeProviderConfigFor : function (desc, launchId) {
            var config          = Joose.O.copy(desc.scopeProviderConfig || {})
            
            config.seedingCode  = this.getSeedingCode(desc, launchId)
            
            return config
        },
        
        
        keepTestResult : function (url) {
            // already keeping 
            if (this.lastResultsByURL[ url ]) {
                var indexOf     = -1
                
                Joose.A.each(this.lastResultsURLs, function (resultUrl, i) { 
                    if (resultUrl == url) { indexOf = i; return false }
                })
                
                this.lastResultsURLs.splice(indexOf, 1)
                this.lastResultsURLs.push(url)
                
                return
            }
            
            this.lastResultsURLs.push(url)
            this.lastResultsByURL[ url ] = true
            
            if (this.lastResultsURLs.length > this.keepNLastResults) this.releaseTestResult()
        },
        
        
        releaseTestResult : function () {
            if (this.lastResultsURLs.length <= this.keepNLastResults) return
            
            var url     = this.lastResultsURLs.shift()
            
            delete this.lastResultsByURL[ url ]
            
            var test    = this.getTestByURL(url)
            
            if (test && test.isFinished()) this.cleanupScopeForURL(url)
        },
        
        
        isKeepingResultForURL : function (url) {
            return this.lastResultsByURL[ url ]
        },
        
        
        setupScope : function (desc, launchId) {
            var url                 = desc.url
            var scopeProvideClass   = eval(desc.scopeProvider)
            
            this.cleanupScopeForURL(url)
            
            this.keepTestResult(url)
            
            return this.scopesByURL[ url ] = new scopeProvideClass(this.getScopeProviderConfigFor(desc, launchId))
        },
        
        
        cleanupScopeForURL : function (url) {
            var scopeProvider = this.scopesByURL[ url ]
            
            if (scopeProvider) {
                delete this.scopesByURL[ url ]
                
                scopeProvider.cleanup()
            }
        },


        // should prepare the "seedingScript" - include it to the `scopeProvider`
        prepareScopeSeeding : function (scopeProvider, desc, contentManager) {
            if (desc.testCode || this.cachePreload && contentManager.hasContentOf(desc.url))
                scopeProvider.addPreload({
                    type        : 'js', 
                    content     : desc.testCode || contentManager.getContentOf(desc.url)
                })
            else
                scopeProvider.seedingScript = this.resolveURL(desc.url, scopeProvider, desc)
        },

        
        // should normalize non-standard urls (like specifying Class.Name in preload)
        // such behavior is not documented and generally deprecated
        normalizeURL : function (url) {
            return url
        },
            
            
        resolveURL : function (url, scopeProvider, desc) {
            return url
        },
        
        
        canUseCachedContent : function (resource) {
            return this.cachePreload && resource instanceof Siesta.Content.Resource.JavaScript
        },
        
        
        addCachedResourceToPreloads : function (scopeProvider, contentManager, resource) {
            scopeProvider.addPreload({
                type        : 'js',
                content     : contentManager.getContentOf(resource)
            })
        },
        
        
        processURL : function (desc, index, contentManager, urlOptions, callback) {
            var me      = this
            var url     = desc.url
            
            if (desc.isMissing) {
                callback()
                
                return
            }
            
            // a magical shared object, which will contain the `test` property with test instance, once the test will be created
            var testHolder      = {}
            // an array of errors occured during preload phase
            var preloadErrors   = []    
            
            var scopeProvider   = this.setupScope(desc, urlOptions.launchId)
            var transparentEx   = this.getDescriptorConfig(desc, 'transparentEx')
            
            var onErrorHandler  = function (msg, url, lineNumber) {
                var test = testHolder.test
                
                if (test && test.isStarted()) {
                    test.nbrExceptions++;
                    test.failWithException(msg + ' ' + url + ' ' + lineNumber)
                } else {
                    preloadErrors.push(msg + ' ' + url + ' ' + lineNumber)
                }
            }
            
            // trying to setup the `onerror` handler as early as possible - to detect each and every exception from the test
            scopeProvider.addOnErrorHandler(onErrorHandler, !transparentEx)
            
//            scopeProvider.addPreload({
//                type        : 'js', 
//                content     : 'console.time("scope-onload")'
//            })
            
            desc.preset.eachResource(function (resource) {
                var hasConent       = contentManager.hasContentOf(resource)
                
                if (hasConent && me.canUseCachedContent(resource)) {
                    me.addCachedResourceToPreloads(scopeProvider, contentManager, resource)
                } else {
                    var resourceDesc    = resource.asDescriptor()
                    
                    if (resourceDesc.url) resourceDesc.url = me.resolveURL(resourceDesc.url, scopeProvider, desc)
                    
                    scopeProvider.addPreload(resourceDesc)
                }
            })

            
            me.prepareScopeSeeding(scopeProvider, desc, contentManager)
            
            this.onBeforeScopePreload(scopeProvider, url)
            
            //console.timeEnd('launch-till-preload')
            
            //console.time('preload')
            
//            scopeProvider.addPreload({
//                type        : 'js', 
//                content     : 'console.timeEnd("scope-onload")'
//            })
            
            scopeProvider.setup(function () {
                me.onAfterScopePreload(scopeProvider, url)
                
                // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                // then do nothing
                if (!scopeProvider.scope) {
                    callback()
                    
                    return
                }
                
                var startTestAnchor     = scopeProvider.scope.StartTest
                
                var args                = startTestAnchor && startTestAnchor.args
                
                // pick either 1st or 2nd argument depending which one is a function 
                var runFunc             = args && (typeof args[ 0 ] == 'function' ? args[ 0 ] : args[ 1 ])
                
                me.launchTest({
                    testHolder          : testHolder,
                    desc                : desc,
                    scopeProvider       : scopeProvider,
                    contentManager      : contentManager,
                    urlOptions          : urlOptions,
                    preloadErrors       : preloadErrors,
                    onErrorHandler      : onErrorHandler,
                    
                    startTestAnchor     : startTestAnchor,
                    
                    runFunc             : runFunc
                }, callback)
            });
        },
        
        
        launchTest : function (options, callback) {
            var scopeProvider   = options.scopeProvider
            var desc            = options.desc
//            desc, scopeProvider, contentManager, options, preloadErrors, onErrorHandler, callback
            
            //console.timeEnd('preload')
            //console.timeEnd('launch-after-preload')
            var me              = this
            var url             = desc.url
            var testClass       = me.getDescriptorConfig(desc, 'testClass')
        
            // after the scope setup, the `onerror` handler might be cleared - installing it again
            scopeProvider.addOnErrorHandler(options.onErrorHandler, !this.getDescriptorConfig(desc, 'transparentEx'))
            
            var testConfig      = me.getNewTestConfiguration(desc, scopeProvider, options.contentManager, options.urlOptions, options.runFunc, options.startTestAnchor)
            
            testConfig.callback = function () {
                if (!me.keepResults) {
                    if (!me.isKeepingResultForURL(url)) me.cleanupScopeForURL(url)
                }
        
                callback && callback()
            }
            
            var test            = options.testHolder.test = new testClass(testConfig)
            this.saveTestWithURL(url, test)
            
            scopeProvider.scope.setTimeout(function() {
                //console.timeEnd('launch')
                
                me.fireEvent('beforeteststart', test)
                
                // start the test after slight delay - to run it already *after* onload (in browsers)
                // in the edge case, test can be already finished before its even started :)
                // this happens if user re-launch the test during these 10ms - test will be 
                // finalized forcefully in the "deleteTestByUrl" method
                if (!test.isFinished()) test.start(options.preloadErrors[ 0 ])
            }, 10);
        },
        
        
        getNewTestConfiguration : function (desc, scopeProvider, contentManager, options, runFunc, startTestAnchor) {
            var scope           = scopeProvider.scope
            
            var config          = {
                url                 : desc.url,
            
                harness             : this,
                run                 : runFunc,
                
                startTestAnchor     : startTestAnchor,
                
                exceptionCatcher    : startTestAnchor.exceptionCatcher,
                testErrorClass      : startTestAnchor.testErrorClass,
            
                expectedGlobals     : this.cleanScopeGlobals.concat(this.getDescriptorConfig(desc, 'expectedGlobals')),
                autoCheckGlobals    : this.getDescriptorConfig(desc, 'autoCheckGlobals'),
                disableGlobalsCheck : this.disableGlobalsCheck,
            
                global              : scope,
                scopeProvider       : scopeProvider,
                
                contentManager      : contentManager,
                
                transparentEx       : this.getDescriptorConfig(desc, 'transparentEx'),
                needDone            : this.getDescriptorConfig(desc, 'needDone'),
                
                overrideSetTimeout          : this.getDescriptorConfig(desc, 'overrideSetTimeout'),
                originalSetTimeout          : scope.setTimeout,
                originalClearTimeout        : scope.clearTimeout,
                
                defaultTimeout              : this.getDescriptorConfig(desc, 'defaultTimeout') * (options.increaseTimeout ? 2 : 1),
                subTestTimeout              : this.getDescriptorConfig(desc, 'subTestTimeout') * (options.increaseTimeout ? 2 : 1),
                waitForTimeout              : this.getDescriptorConfig(desc, 'waitForTimeout') * (options.increaseTimeout ? 3 : 1),
                isReadyTimeout              : this.getDescriptorConfig(desc, 'isReadyTimeout'),
                
                sourceLineForAllAssertions  : this.sourceLineForAllAssertions
            }
            
            // potentially not safe
            if (desc.testConfig) Joose.O.extend(config, desc.testConfig)
            
            return config
        },
        
        
        getScriptDescriptor : function (id) {
            return this.descriptorsById[ id ]
        },
        
        
        getTestByURL : function (url) {
            return this.testsByURL[ url ]
        },
        
        
        saveTestWithURL : function (url, test) {
            this.testsByURL[ url ] = test
        },
        
        
        deleteTestByURL : function (url) {
            var test    = this.testsByURL[ url ]
            
            if (test) {
                test.finalize(true)
                this.cleanupScopeForURL(url)
            }
            
            delete this.testsByURL[ url ]
        },
        
        
        allPassed : function () {
            var allPassed       = true
            var me              = this
            
            Joose.A.each(this.flattenDescriptors(this.descriptors), function (descriptor) {
                // if at least one test is missing then something is wrong
                if (descriptor.isMissing) { allPassed = false; return false }
                
                var test    = me.getTestByURL(descriptor.url)
                
                // ignore missing tests (could be skipped by test filtering)
                if (!test) return
                
                allPassed = allPassed && test.isPassed()
            })
            
            return allPassed
        },
        
        
        generateReport : function (options) {
            if (!arguments.length) options = __REPORT_OPTIONS__
            
            // a string? 
            if (Object(options) !== options) options = { format : options || 'JSON' }
            
            var methodName  = 'generate' + options.format + 'Report'
            
            if (!this[ methodName ]) throw "Can't generate report - missing the `" + methodName + "` method"
            
            return this[ methodName ](options)
        },
        
        
        typeOf : function (object) {
            return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
        }
    }
    // eof methods
})
//eof Siesta.Harness
;
/**
@class Siesta.Role.CanStyleOutput
@private

A role, providing output coloring functionality

*/
Role('Siesta.Role.CanStyleOutput', {
    
    has         : {
        /**
         * @cfg {Boolean} disableColoring When set to `true` will disable the colors in the console output in automation launchers / NodeJS launcher
         */
        disableColoring : false,
        
        style               : {
            is          : 'rwc',
            lazy        : 'this.buildStyle'
        },
        
        styles              : { 
            init    : {
                'bold'      : [1, 22],
                'italic'    : [3, 23],
                'underline' : [4, 24],
                
                'black '    : [30, 39],
                'yellow'    : [33, 39],
                'cyan'      : [36, 39],
                'white'     : [37, 39],
                'green'     : [32, 39],
                'red'       : [31, 39],
                'grey'      : [90, 39],
                'blue'      : [34, 39],
                'magenta'   : [35, 39],
                
                'bgblack '  : [40, 49],
                'bgyellow'  : [43, 49],
                'bgcyan'    : [46, 49],
                'bgwhite'   : [47, 49],
                'bggreen'   : [42, 49],
                'bgred'     : [41, 49],
                'bggrey'    : [100, 49],
                'bgblue'    : [44, 49],
                'bgmagenta' : [45, 49],
                
                'inverse'   : [7, 27]
            }
        }
    },
    
    
    methods : {
        
        buildStyle : function () {
            var me          = this
            var style       = {}
            
            Joose.O.each(this.styles, function (value, name) {
                
                style[ name ] = function (text) { return me.styled(text, name) }
            })
            
            return style
        },
        
        
        styled : function (text, style) {
            if (this.disableColoring) return text
            
            var styles = this.styles
            
            return '\033[' + styles[ style ][ 0 ] + 'm' + text + '\033[' + styles[ style ][ 1 ] + 'm'
        }
    }
})
;
// consuming harness need to use `sequential` run core

Role('Siesta.Role.ConsoleReporter', {
    
    requires    : [ 'log', 'exit', 'allPassed' ],
    
    
    does        : Siesta.Role.CanStyleOutput,
    
    has : {
        // special flag which will be used by automation launchers to prevent the summary message
        // after every page
        needSummaryMessage      : true
    },
    
    
    after : {
        
        markMissingFile : function (desc) {
            this.warn("Test file [" + desc.url + "] not found.")
        },
        
        
        onTestSuiteStart : function () {
        },
        
        
        onTestSuiteEnd : function () {
            this.exit(this.getExitCode())
        },
        
        
        onTestEnd : function (test) {
            var isPassed    = test.isPassed()
            
            this.log('[' + (isPassed ? this.style().green('PASS') : this.style().red('FAIL')) + ']  ' + test.url + (isPassed ? '' : '\n')) 
        },
        
        
        onTestUpdate : function (test, result, parentResult) {
            var text            = result + ''
            var needToShow      = this.verbosity > 0
            
            if (result instanceof Siesta.Result.Assertion) {
                if (result.isWaitFor && !result.completed) return;

                if (result.isException && !result.isTodo) {
                    text        = this.style().bold(this.style().red(text))
                    
                    needToShow  = true
                } else if (result.isTodo) {
                    text        = this.styled(text, result.passed ? 'magenta' : 'yellow')
                    
                    if (result.passed && !result.isWaitFor) needToShow = true
                    
                } else {
                    text        = this.styled(text, result.passed ? 'green' : 'red')
                    
                    if (!result.passed) needToShow = true
                }
            }
            
            if (result instanceof Siesta.Result.Diagnostic) {
                text            = this.styled(text, 'bold')
                
                if (result.isWarning) {
                    this.warn(text)
                    return
                }
            }
            
            if (result instanceof Siesta.Result.Summary) {
                needToShow      = this.needSummaryMessage
                
                text            = this.styled(result.description.join(''), 'bold')
            }
            
            if (needToShow) this.log(text)
        }            
    },
    
    
    methods : {
        
        warn : function (text) {
            this.log(this.styled('[WARN] ', 'red') + text)
        },
        
        
        getSummaryMessage : function (allPassed) {
            allPassed = allPassed != null ? allPassed : this.allPassed()
            
            return allPassed ? this.style().bold(this.style().green('All tests passed')) : this.style().bold(this.style().red('There are failures'))
        },
        
        
        getExitCode : function () {
            return this.allPassed() ? 0 : 1
        }
    }
    
})


;
;
/*!
* jQuery JavaScript Library v1.6.2
* http://jquery.com/
*
* Copyright 2011, John Resig
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*
* Includes Sizzle.js
* http://sizzlejs.com/
* Copyright 2011, The Dojo Foundation
* Released under the MIT, BSD, and GPL Licenses.
*
* Date: Thu Jun 30 14:16:56 2011 -0400
*/
(function (window, undefined) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
	navigator = window.navigator,
	location = window.location;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        },

        // Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

        // Map over the $ in case of overwrite
	_$ = window.$,

        // A central reference to the root jQuery(document)
	rootjQuery,

        // A simple way to check for HTML strings or ID strings
        // (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

        // Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

        // Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

        // Check for digits
	rdigit = /\d/,

        // Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

        // JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

        // Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

        // Matches dashed string for camelizing
	rdashAlpha = /-([a-z])/ig,

        // Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
	    return letter.toUpperCase();
	},

        // Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

        // For matching the engine and version of the browser
	browserMatch,

        // The deferred used on DOM ready
	readyList,

        // The ready event handler
	DOMContentLoaded,

        // Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

        // [[Class]] -> type pairs
	class2type = {};

        jQuery.fn = jQuery.prototype = {
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                    return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = selector;
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                    // Are we dealing with HTML string or an ID?
                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [null, selector, null];

                    } else {
                        match = quickExpr.exec(selector);
                    }

                    // Verify a match, and that no context was specified for #id
                    if (match && (match[1] || !context)) {

                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            doc = (context ? context.ownerDocument || context : document);

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec(selector);

                            if (ret) {
                                if (jQuery.isPlainObject(context)) {
                                    selector = [document.createElement(ret[1])];
                                    jQuery.fn.attr.call(selector, context, true);

                                } else {
                                    selector = [doc.createElement(ret[1])];
                                }

                            } else {
                                ret = jQuery.buildFragment([match[1]], [doc]);
                                selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                            }

                            return jQuery.merge(this, selector);

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById(match[2]);

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if (elem.id !== match[2]) {
                                    return rootjQuery.find(selector);
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor(context).find(selector);
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.6.2",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: function () {
                return slice.call(this, 0);
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
                return num == null ?

                // Return a 'clean' array
			this.toArray() :

                // Return just the object
			(num < 0 ? this[this.length + num] : this[num]);
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = this.constructor();

                if (jQuery.isArray(elems)) {
                    push.apply(ret, elems);

                } else {
                    jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                    ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },

            ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // Add the callback
                readyList.done(fn);

                return this;
            },

            eq: function (i) {
                return i === -1 ?
			this.slice(i) :
			this.slice(i, +i + 1);
            },

            first: function () {
                return this.eq(0);
            },

            last: function () {
                return this.eq(-1);
            },

            slice: function () {
                return this.pushStack(slice.apply(this, arguments),
			"slice", slice.call(arguments).join(","));
            },

            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },

            end: function () {
                return this.prevObject || this.constructor(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Hold (or release) the ready event
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },

            // Handle when the DOM is ready
            ready: function (wait) {
                // Either a released hold or an DOMready/load event and not yet ready
                if ((wait === true && ! --jQuery.readyWait) || (wait !== true && !jQuery.isReady)) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready, 1);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.trigger) {
                        jQuery(document).trigger("ready").unbind("ready");
                    }
                }
            },

            bindReady: function () {
                if (readyList) {
                    return;
                }

                readyList = jQuery._Deferred();

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", jQuery.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", DOMContentLoaded);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", jQuery.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) { }

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
            },

            // A crude way of determining if an object is a window
            isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
            },

            isNaN: function (obj) {
                return obj == null || !rdigit.test(obj) || isNaN(obj);
            },

            type: function (obj) {
                return obj == null ?
			String(obj) :
			class2type[toString.call(obj)] || "object";
            },

            isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                // Not own constructor property must be Object
                if (obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) { }

                return key === undefined || hasOwn.call(obj, key);
            },

            isEmptyObject: function (obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },

            error: function (msg) {
                throw msg;
            },

            parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Attempt to parse using the native JSON parser first
                if (window.JSON && window.JSON.parse) {
                    return window.JSON.parse(data);
                }

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, ""))) {

                    return (new Function("return " + data))();

                }
                jQuery.error("Invalid JSON: " + data);
            },

            // Cross-browser xml parsing
            // (xml & tmp used internally)
            parseXML: function (data, xml, tmp) {

                if (window.DOMParser) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } else { // IE
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }

                tmp = xml.documentElement;

                if (!tmp || !tmp.nodeName || tmp.nodeName === "parsererror") {
                    jQuery.error("Invalid XML: " + data);
                }

                return xml;
            },

            noop: function () { },

            // Evaluates a script in a global context
            // Workarounds based on findings by Jim Driscoll
            // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
            globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                    // We use execScript on Internet Explorer
                    // We use an anonymous function so that context is window
                    // rather than jQuery in Firefox
                    (window.execScript || function (data) {
                        window["eval"].call(window, data);
                    })(data);
                }
            },

            // Converts a dashed string to camelCased string;
            // Used by both the css and data modules
            camelCase: function (string) {
                return string.replace(rdashAlpha, fcamelCase);
            },

            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function (object, callback, args) {
                var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                    if (isObj) {
                        for (name in object) {
                            if (callback.apply(object[name], args) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length; ) {
                            if (callback.apply(object[i++], args) === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isObj) {
                        for (name in object) {
                            if (callback.call(object[name], name, object[name]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length; ) {
                            if (callback.call(object[i], i, object[i++]) === false) {
                                break;
                            }
                        }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
		function (text) {
		    return text == null ?
				"" :
				trim.call(text);
		} :

            // Otherwise use our own trimming functionality
		function (text) {
		    return text == null ?
				"" :
				text.toString().replace(trimLeft, "").replace(trimRight, "");
		},

            // results is for internal usage only
            makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                    // The window, strings (and functions) also have 'length'
                    // The extra typeof function check is to prevent crashes
                    // in Safari 2 (See: #3039)
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type(array);

                    if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                        push.call(ret, array);
                    } else {
                        jQuery.merge(ret, array);
                    }
                }

                return ret;
            },

            inArray: function (elem, array) {

                if (indexOf) {
                    return indexOf.call(array, elem);
                }

                for (var i = 0, length = array.length; i < length; i++) {
                    if (array[i] === elem) {
                        return i;
                    }
                }

                return -1;
            },

            merge: function (first, second) {
                var i = first.length,
			j = 0;

                if (typeof second.length === "number") {
                    for (var l = second.length; j < l; j++) {
                        first[i++] = second[j];
                    }

                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
                var value, key, ret = [],
			i = 0,
			length = elems.length,
                // jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

                // Go through the array, translating each of the items to their
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }

                    // Go through every key on the object,
                } else {
                    for (key in elems) {
                        value = callback(elems[key], key, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                }

                // Flatten any nested arrays
                return ret.concat.apply([], ret);
            },

            // A global GUID counter for objects
            guid: 1,

            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: function (fn, context) {
                if (typeof context === "string") {
                    var tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }

                // Simulated bind
                var args = slice.call(arguments, 2),
			proxy = function () {
			    return fn.apply(context, args.concat(slice.call(arguments)));
			};

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can optionally be executed if it's a function
            access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                    for (var k in key) {
                        jQuery.access(elems, k, key[k], exec, fn, value);
                    }
                    return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                    // Optionally, function values get executed if exec is true
                    exec = !pass && exec && jQuery.isFunction(value);

                    for (var i = 0; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }

                    return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
            },

            now: function () {
                return (new Date()).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function (ua) {
                ua = ua.toLowerCase();

                var match = rwebkit.exec(ua) ||
			ropera.exec(ua) ||
			rmsie.exec(ua) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
			[];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            sub: function () {
                function jQuerySub(selector, context) {
                    return new jQuerySub.fn.init(selector, context);
                }
                jQuery.extend(true, jQuerySub, this);
                jQuerySub.superclass = this;
                jQuerySub.fn = jQuerySub.prototype = this();
                jQuerySub.fn.constructor = jQuerySub;
                jQuerySub.sub = this.sub;
                jQuerySub.fn.init = function init(selector, context) {
                    if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                        context = jQuerySub(context);
                    }

                    return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
                };
                jQuerySub.fn.init.prototype = jQuerySub.fn;
                var rootjQuerySub = jQuerySub(document);
                return jQuerySub;
            },

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = true;
        }

        // IE doesn't match non-breaking spaces with \s
        if (rnotwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", DOMContentLoaded);
                    jQuery.ready();
                }
            };
        }

        // The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if (jQuery.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        return jQuery;

    })();


    var // Promise methods
	promiseMethods = "done fail isResolved isRejected promise then always pipe".split(" "),
    // Static reference to slice
	sliceDeferred = [].slice;

    jQuery.extend({
        // Create a simple deferred (one callbacks list)
        _Deferred: function () {
            var // callbacks list
			callbacks = [],
            // stored [ context , args ]
			fired,
            // to avoid firing when already doing so
			firing,
            // flag to know if the deferred has been cancelled
			cancelled,
            // the deferred itself
			deferred = {

			    // done( f1, f2, ...)
			    done: function () {
			        if (!cancelled) {
			            var args = arguments,
							i,
							length,
							elem,
							type,
							_fired;
			            if (fired) {
			                _fired = fired;
			                fired = 0;
			            }
			            for (i = 0, length = args.length; i < length; i++) {
			                elem = args[i];
			                type = jQuery.type(elem);
			                if (type === "array") {
			                    deferred.done.apply(deferred, elem);
			                } else if (type === "function") {
			                    callbacks.push(elem);
			                }
			            }
			            if (_fired) {
			                deferred.resolveWith(_fired[0], _fired[1]);
			            }
			        }
			        return this;
			    },

			    // resolve with given context and args
			    resolveWith: function (context, args) {
			        if (!cancelled && !fired && !firing) {
			            // make sure args are available (#8421)
			            args = args || [];
			            firing = 1;
			            try {
			                while (callbacks[0]) {
			                    callbacks.shift().apply(context, args);
			                }
			            }
			            finally {
			                fired = [context, args];
			                firing = 0;
			            }
			        }
			        return this;
			    },

			    // resolve with this as context and given arguments
			    resolve: function () {
			        deferred.resolveWith(this, arguments);
			        return this;
			    },

			    // Has this deferred been resolved?
			    isResolved: function () {
			        return !!(firing || fired);
			    },

			    // Cancel
			    cancel: function () {
			        cancelled = 1;
			        callbacks = [];
			        return this;
			    }
			};

            return deferred;
        },

        // Full fledged deferred (two callbacks list)
        Deferred: function (func) {
            var deferred = jQuery._Deferred(),
			failDeferred = jQuery._Deferred(),
			promise;
            // Add errorDeferred methods, then and promise
            jQuery.extend(deferred, {
                then: function (doneCallbacks, failCallbacks) {
                    deferred.done(doneCallbacks).fail(failCallbacks);
                    return this;
                },
                always: function () {
                    return deferred.done.apply(deferred, arguments).fail.apply(this, arguments);
                },
                fail: failDeferred.done,
                rejectWith: failDeferred.resolveWith,
                reject: failDeferred.resolve,
                isRejected: failDeferred.isResolved,
                pipe: function (fnDone, fnFail) {
                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each({
                            done: [fnDone, "resolve"],
                            fail: [fnFail, "reject"]
                        }, function (handler, data) {
                            var fn = data[0],
							action = data[1],
							returned;
                            if (jQuery.isFunction(fn)) {
                                deferred[handler](function () {
                                    returned = fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().then(newDefer.resolve, newDefer.reject);
                                    } else {
                                        newDefer[action](returned);
                                    }
                                });
                            } else {
                                deferred[handler](newDefer[action]);
                            }
                        });
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function (obj) {
                    if (obj == null) {
                        if (promise) {
                            return promise;
                        }
                        promise = obj = {};
                    }
                    var i = promiseMethods.length;
                    while (i--) {
                        obj[promiseMethods[i]] = deferred[promiseMethods[i]];
                    }
                    return obj;
                }
            });
            // Make sure only one callback list will be used
            deferred.done(failDeferred.cancel).fail(deferred.cancel);
            // Unexpose cancel
            delete deferred.cancel;
            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },

        // Deferred helper
        when: function (firstParam) {
            var args = arguments,
			i = 0,
			length = args.length,
			count = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ?
				firstParam :
				jQuery.Deferred();
            function resolveFunc(i) {
                return function (value) {
                    args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                    if (!(--count)) {
                        // Strange bug in FF4:
                        // Values changed onto the arguments object sometimes end up as undefined values
                        // outside the $.when method. Cloning the object into a fresh array solves the issue
                        deferred.resolveWith(deferred, sliceDeferred.call(args, 0));
                    }
                };
            }
            if (length > 1) {
                for (; i < length; i++) {
                    if (args[i] && jQuery.isFunction(args[i].promise)) {
                        args[i].promise().then(resolveFunc(i), deferred.reject);
                    } else {
                        --count;
                    }
                }
                if (!count) {
                    deferred.resolveWith(deferred, args);
                }
            } else if (deferred !== firstParam) {
                deferred.resolveWith(deferred, length ? [firstParam] : []);
            }
            return deferred.promise();
        }
    });



    jQuery.support = (function () {

        var div = document.createElement("div"),
		documentElement = document.documentElement,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		support,
		fragment,
		body,
		testElementParent,
		testElement,
		testElementStyle,
		tds,
		events,
		eventName,
		i,
		isSupported;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", function () {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
        }

        // Check if a radio maintains it's value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.firstChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        div.innerHTML = "";

        // Figure out if the W3C box model works as expected
        div.style.width = div.style.paddingLeft = "1px";

        body = document.getElementsByTagName("body")[0];
        // We use our own, invisible, body unless the body is already present
        // in which case we use a div (#9239)
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0
        };
        if (body) {
            jQuery.extend(testElementStyle, {
                position: "absolute",
                left: -1000,
                top: -1000
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        support.boxModel = div.offsetWidth === 2;

        if ("zoom" in div.style) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div.style.display = "inline";
            div.style.zoom = 1;
            support.inlineBlockNeedsLayout = (div.offsetWidth === 2);

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div.style.display = "";
            div.innerHTML = "<div style='width:4px;'></div>";
            support.shrinkWrapBlocks = (div.offsetWidth !== 2);
        }

        div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
        tds = div.getElementsByTagName("td");

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        isSupported = (tds[0].offsetHeight === 0);

        tds[0].style.display = "";
        tds[1].style.display = "none";

        // Check if empty table cells still have offsetWidth/Height
        // (IE < 8 fail this test)
        support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);
        div.innerHTML = "";

        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        if (document.defaultView && document.defaultView.getComputedStyle) {
            marginDiv = document.createElement("div");
            marginDiv.style.width = "0";
            marginDiv.style.marginRight = "0";
            div.appendChild(marginDiv);
            support.reliableMarginRight =
			(parseInt((document.defaultView.getComputedStyle(marginDiv, null) || { marginRight: 0 }).marginRight, 10) || 0) === 0;
        }

        // Remove the body element we added
        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
                submit: 1,
                change: 1,
                focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        // Null connected elements to avoid leaks in IE
        testElement = fragment = select = opt = body = marginDiv = div = input = null;

        return support;
    })();

    // Keep track of boxModel
    jQuery.boxModel = jQuery.support.boxModel;




    var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([a-z])([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];

            return !!elem && !isEmptyDataObject(elem);
        },

        data: function (elem, name, data, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[jQuery.expando] : elem[jQuery.expando] && jQuery.expando;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || (pvt && id && !cache[id][internalKey])) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[jQuery.expando] = id = ++jQuery.uuid;
                } else {
                    id = jQuery.expando;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id][internalKey] = jQuery.extend(cache[id][internalKey], name);
                } else {
                    cache[id] = jQuery.extend(cache[id], name);
                }
            }

            thisCache = cache[id];

            // Internal jQuery data is stored in a separate object inside the object's data
            // cache in order to avoid key collisions between internal data and user-defined
            // data
            if (pvt) {
                if (!thisCache[internalKey]) {
                    thisCache[internalKey] = {};
                }

                thisCache = thisCache[internalKey];
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
            // not attempt to inspect the internal events object using jQuery.data, as this
            // internal data object is undocumented and subject to change.
            if (name === "events" && !thisCache[name]) {
                return thisCache[internalKey] && thisCache[internalKey].events;
            }

            return getByName ?
            // Check for both converted-to-camel and non-converted data property names
			thisCache[jQuery.camelCase(name)] || thisCache[name] :
			thisCache;
        },

        removeData: function (elem, name, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var internalKey = jQuery.expando, isNode = elem.nodeType,

            // See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

            // See jQuery.data for more information
			id = isNode ? elem[jQuery.expando] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {
                var thisCache = pvt ? cache[id][internalKey] : cache[id];

                if (thisCache) {
                    delete thisCache[name];

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!isEmptyDataObject(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (pvt) {
                delete cache[id][internalKey];

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            var internalCache = cache[id][internalKey];

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            if (jQuery.support.deleteExpando || cache != window) {
                delete cache[id];
            } else {
                cache[id] = null;
            }

            // We destroyed the entire user cache at once because it's faster than
            // iterating through each key, but we need to continue to persist internal
            // data if it existed
            if (internalCache) {
                cache[id] = {};
                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }

                cache[id][internalKey] = internalCache;

                // Otherwise, we need to eliminate the expando on the node to avoid
                // false lookups in the cache for entries that no longer exist
            } else if (isNode) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if (jQuery.support.deleteExpando) {
                    delete elem[jQuery.expando];
                } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);
                } else {
                    elem[jQuery.expando] = null;
                }
            }
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var data = null;

            if (typeof key === "undefined") {
                if (this.length) {
                    data = jQuery.data(this[0]);

                    if (this[0].nodeType === 1) {
                        var attr = this[0].attributes, name;
                        for (var i = 0, l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(this[0], name, data[name]);
                            }
                        }
                    }
                }

                return data;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);
                    data = dataAttr(this[0], key, data);
                }

                return data === undefined && parts[1] ?
				this.data(parts[0]) :
				data;

            } else {
                return this.each(function () {
                    var $this = jQuery(this),
					args = [parts[0], value];

                    $this.triggerHandler("setData" + parts[1] + "!", args);
                    jQuery.data(this, key, value);
                    $this.triggerHandler("changeData" + parts[1] + "!", args);
                });
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            var name = "data-" + key.replace(rmultiDash, "$1-$2").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN(data) ? parseFloat(data) :
					rbrace.test(data) ? jQuery.parseJSON(data) :
					data;
                } catch (e) { }

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
    // property to be considered empty objects; this property always exists in
    // order to make sure JSON.stringify does not expose internal metadata
    function isEmptyDataObject(obj) {
        for (var name in obj) {
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }




    function handleQueueMarkDefer(elem, type, src) {
        var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery.data(elem, deferDataKey, undefined, true);
        if (defer &&
		(src === "queue" || !jQuery.data(elem, queueDataKey, undefined, true)) &&
		(src === "mark" || !jQuery.data(elem, markDataKey, undefined, true))) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout(function () {
                if (!jQuery.data(elem, queueDataKey, undefined, true) &&
				!jQuery.data(elem, markDataKey, undefined, true)) {
                    jQuery.removeData(elem, deferDataKey, true);
                    defer.resolve();
                }
            }, 0);
        }
    }

    jQuery.extend({

        _mark: function (elem, type) {
            if (elem) {
                type = (type || "fx") + "mark";
                jQuery.data(elem, type, (jQuery.data(elem, type, undefined, true) || 0) + 1, true);
            }
        },

        _unmark: function (force, elem, type) {
            if (force !== true) {
                type = elem;
                elem = force;
                force = false;
            }
            if (elem) {
                type = type || "fx";
                var key = type + "mark",
				count = force ? 0 : ((jQuery.data(elem, key, undefined, true) || 1) - 1);
                if (count) {
                    jQuery.data(elem, key, count, true);
                } else {
                    jQuery.removeData(elem, key, true);
                    handleQueueMarkDefer(elem, type, "mark");
                }
            }
        },

        queue: function (elem, type, data) {
            if (elem) {
                type = (type || "fx") + "queue";
                var q = jQuery.data(elem, type, undefined, true);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!q || jQuery.isArray(data)) {
                        q = jQuery.data(elem, type, jQuery.makeArray(data), true);
                    } else {
                        q.push(data);
                    }
                }
                return q || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
			fn = queue.shift(),
			defer;

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                });
            }

            if (!queue.length) {
                jQuery.removeData(elem, type + "queue", true);
                handleQueueMarkDefer(elem, type, "queue");
            }
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            if (typeof type !== "string") {
                data = type;
                type = "fx";
            }

            if (data === undefined) {
                return jQuery.queue(this[0], type);
            }
            return this.each(function () {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function () {
                var elem = this;
                setTimeout(function () {
                    jQuery.dequeue(elem, type);
                }, time);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, object) {
            if (typeof type !== "string") {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
            function resolve() {
                if (!(--count)) {
                    defer.resolveWith(elements, [elements]);
                }
            }
            while (i--) {
                if ((tmp = jQuery.data(elements[i], deferDataKey, undefined, true) ||
					(jQuery.data(elements[i], queueDataKey, undefined, true) ||
						jQuery.data(elements[i], markDataKey, undefined, true)) &&
					jQuery.data(elements[i], deferDataKey, jQuery._Deferred(), true))) {
                    count++;
                    tmp.done(resolve);
                }
            }
            resolve();
            return defer.promise();
        }
    });




    var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	rinvalidChar = /\:|^on/,
	formHook, boolHook;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        },

        prop: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.prop);
        },

        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) { }
            });
        },

        addClass: function (value) {
            var classNames, i, l, elem,
			setClass, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (value && typeof value === "string") {
                classNames = value.split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (! ~setClass.indexOf(" " + classNames[c] + " ")) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classNames, i, l, elem, className, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }

            if ((value && typeof value === "string") || value === undefined) {
                classNames = (value || "").split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1 && elem.className) {
                        if (value) {
                            className = (" " + elem.className + " ").replace(rclass, " ");
                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                className = className.replace(" " + classNames[c] + " ", " ");
                            }
                            elem.className = jQuery.trim(className);

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
			isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className,
					i = 0,
					self = jQuery(this),
					state = stateVal,
					classNames = value.split(rspace);

                    while ((className = classNames[i++])) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ";
            for (var i = 0, l = this.length; i < l; i++) {
                if ((" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            var hooks, ret,
			elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.nodeName.toLowerCase()] || jQuery.valHooks[elem.type];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
					ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
					ret == null ? "" : ret;
                }

                return undefined;
            }

            var isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var self = jQuery(this), val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.nodeName.toLowerCase()] || jQuery.valHooks[this.type];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function (elem) {
                    var value,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

                    // Nothing was selected
                    if (index < 0) {
                        return null;
                    }

                    // Loop through all the selected options
                    for (var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++) {
                        var option = options[i];

                        // Don't return options that are disabled or in a disabled optgroup
                        if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if (one && !values.length && options.length) {
                        return jQuery(options[index]).val();
                    }

                    return values;
                },

                set: function (elem, value) {
                    var values = jQuery.makeArray(value);

                    jQuery(elem).find("option").each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attrFix: {
            // Always normalize to ensure hook usage
            tabindex: "tabIndex"
        },

        attr: function (elem, name, value, pass) {
            var nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (!("getAttribute" in elem)) {
                return jQuery.prop(elem, name, value);
            }

            var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // Normalize the name if needed
            if (notxml) {
                name = jQuery.attrFix[name] || name;

                hooks = jQuery.attrHooks[name];

                if (!hooks) {
                    // Use boolHook for boolean attributes
                    if (rboolean.test(name)) {

                        hooks = boolHook;

                        // Use formHook for forms and if the name contains certain characters
                    } else if (formHook && name !== "className" &&
					(jQuery.nodeName(elem, "form") || rinvalidChar.test(name))) {

                        hooks = formHook;
                    }
                }
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return undefined;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, "" + value);
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
				undefined :
				ret;
            }
        },

        removeAttr: function (elem, name) {
            var propName;
            if (elem.nodeType === 1) {
                name = jQuery.attrFix[name] || name;

                if (jQuery.support.getSetAttribute) {
                    // Use removeAttribute in browsers that support it
                    elem.removeAttribute(name);
                } else {
                    jQuery.attr(elem, name, "");
                    elem.removeAttributeNode(elem.getAttributeNode(name));
                }

                // Set corresponding property to false for boolean attributes
                if (rboolean.test(name) && (propName = jQuery.propFix[name] || name) in elem) {
                    elem[propName] = false;
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            tabIndex: {
                get: function (elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabIndex");

                    return attributeNode && attributeNode.specified ?
					parseInt(attributeNode.value, 10) :
					rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
						0 :
						undefined;
                }
            },
            // Use the value property for back compat
            // Use the formHook for button elements in IE6/7 (#1954)
            value: {
                get: function (elem, name) {
                    if (formHook && jQuery.nodeName(elem, "button")) {
                        return formHook.get(elem, name);
                    }
                    return name in elem ?
					elem.value :
					null;
                },
                set: function (elem, value, name) {
                    if (formHook && jQuery.nodeName(elem, "button")) {
                        return formHook.set(elem, value, name);
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function (elem, name, value) {
            var nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== undefined) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {}
    });

    // Hook for boolean attributes
    boolHook = {
        get: function (elem, name) {
            // Align boolean attributes with corresponding properties
            return jQuery.prop(elem, name) ?
			name.toLowerCase() :
			undefined;
        },
        set: function (elem, value, name) {
            var propName;
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!jQuery.support.getSetAttribute) {

        // propFix is more comprehensive and contains all fixes
        jQuery.attrFix = jQuery.propFix;

        // Use this for any attribute on a form in IE6/7
        formHook = jQuery.attrHooks.name = jQuery.attrHooks.title = jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                // Return undefined if nodeValue is empty string
                return ret && ret.nodeValue !== "" ?
				ret.nodeValue :
				undefined;
            },
            set: function (elem, value, name) {
                // Check form objects in IE (multiple bugs related)
                // Only use nodeValue if the attribute node exists on the form
                var ret = elem.getAttributeNode(name);
                if (ret) {
                    ret.nodeValue = value;
                    return value;
                }
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function (elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function (elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function (elem, value) {
                return (elem.style.cssText = "" + value);
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        });
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                get: function (elem) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        });
    });




    var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspaces = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function (nm) {
	    return nm.replace(rescape, "\\$&");
	};

    /*
    * A number of helper functions used for managing events.
    * Many of the ideas behind this code originated from
    * Dean Edwards' addEvent library.
    */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function (elem, types, handler, data) {
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            } else if (!handler) {
                // Fixes bug #7229. Fix recommended by jdalton
                return;
            }

            var handleObjIn, handleObj;

            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery._data(elem);

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if (!elemData) {
                return;
            }

            var events = elemData.events,
			eventHandle = elemData.handle;

            if (!events) {
                elemData.events = events = {};
            }

            if (!eventHandle) {
                elemData.handle = eventHandle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.handle.apply(eventHandle.elem, arguments) :
					undefined;
                };
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0, namespaces;

            while ((type = types[i++])) {
                handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

                // Namespaced event handlers
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if (!handleObj.guid) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[type],
				special = jQuery.event.special[type] || {};

                // Init the event handler queue
                if (!handlers) {
                    handlers = events[type] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push(handleObj);

                // Keep track of which events have been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, pos) {
            // don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			elemData = jQuery.hasData(elem) && jQuery._data(elem),
			events = elemData && elemData.events;

            if (!elemData || !events) {
                return;
            }

            // types is actually an event object here
            if (types && types.type) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if (!types || typeof types === "string" && types.charAt(0) === ".") {
                types = types || "";

                for (type in events) {
                    jQuery.event.remove(elem, type + types);
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ((type = types[i++])) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if (!all) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" +
					jQuery.map(namespaces.slice(0).sort(), fcleanup).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[type];

                if (!eventType) {
                    continue;
                }

                if (!handler) {
                    for (j = 0; j < eventType.length; j++) {
                        handleObj = eventType[j];

                        if (all || namespace.test(handleObj.namespace)) {
                            jQuery.event.remove(elem, origType, handleObj.handler, j);
                            eventType.splice(j--, 1);
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[type] || {};

                for (j = pos || 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if (handler.guid === handleObj.guid) {
                        // remove the given handler for the given type
                        if (all || namespace.test(handleObj.namespace)) {
                            if (pos == null) {
                                eventType.splice(j--, 1);
                            }

                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }

                        if (pos != null) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if (eventType.length === 0 || pos != null && eventType.length === 1) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    ret = null;
                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                var handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if (jQuery.isEmptyObject(elemData)) {
                    jQuery.removeData(elem, undefined, true);
                }
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function (event, data, elem, onlyHandlers) {
            // Event object or event type
            var type = event.type || event,
			namespaces = [],
			exclusive;

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
            // jQuery.Event object
			event[jQuery.expando] ? event :
            // Object literal
			new jQuery.Event(type, event) :
            // Just the event type (string)
			new jQuery.Event(type);

            event.type = type;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");

            // triggerHandler() and global events don't bubble or run the default action
            if (onlyHandlers || !elem) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Handle a global trigger
            if (!elem) {
                // TODO: Stop taunting the data cache; remove global events and always attach to document
                jQuery.each(jQuery.cache, function () {
                    // internalKey variable is just used to make it easier to find
                    // and potentially change this stuff later; currently it just
                    // points to jQuery.expando
                    var internalKey = jQuery.expando,
					internalCache = this[internalKey];
                    if (internalCache && internalCache.events && internalCache.events[type]) {
                        jQuery.event.trigger(event, data, internalCache.handle.elem);
                    }
                });
                return;
            }

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            event.target = elem;

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            var cur = elem,
            // IE doesn't like method names with a colon (#3533, #8272)
			ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Fire event on the current element, then bubble up the DOM tree
            do {
                var handle = jQuery._data(cur, "handle");

                event.currentTarget = cur;
                if (handle) {
                    handle.apply(cur, data);
                }

                // Trigger an inline bound script
                if (ontype && jQuery.acceptData(cur) && cur[ontype] && cur[ontype].apply(cur, data) === false) {
                    event.result = false;
                    event.preventDefault();
                }

                // Bubble up to document, then to window
                cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
            } while (cur && !event.isPropagationStopped());

            // If nobody prevented the default action, do it now
            if (!event.isDefaultPrevented()) {
                var old,
				special = jQuery.event.special[type] || {};

                if ((!special._default || special._default.call(elem.ownerDocument, event) === false) &&
				!(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction)() check here because IE6/7 fails that test.
                    // IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
                    try {
                        if (ontype && elem[type]) {
                            // Don't re-trigger an onFOO event when we call its FOO() method
                            old = elem[ontype];

                            if (old) {
                                elem[ontype] = null;
                            }

                            jQuery.event.triggered = type;
                            elem[type]();
                        }
                    } catch (ieError) { }

                    if (old) {
                        elem[ontype] = old;
                    }

                    jQuery.event.triggered = undefined;
                }
            }

            return event.result;
        },

        handle: function (event) {
            event = jQuery.event.fix(event || window.event);
            // Snapshot the handlers list since a called handler may add/remove events.
            var handlers = ((jQuery._data(this, "events") || {})[event.type] || []).slice(0),
			run_all = !event.exclusive && !event.namespace,
			args = Array.prototype.slice.call(arguments, 0);

            // Use the fix-ed Event rather than the (read-only) native event
            args[0] = event;
            event.currentTarget = this;

            for (var j = 0, l = handlers.length; j < l; j++) {
                var handleObj = handlers[j];

                // Triggered event must 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event.
                if (run_all || event.namespace_re.test(handleObj.namespace)) {
                    // Pass in a reference to the handler function itself
                    // So that we can later remove it
                    event.handler = handleObj.handler;
                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    var ret = handleObj.handler.apply(this, args);

                    if (ret !== undefined) {
                        event.result = ret;
                        if (ret === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }

                    if (event.isImmediatePropagationStopped()) {
                        break;
                    }
                }
            }
            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event(originalEvent);

            for (var i = this.props.length, prop; i; ) {
                prop = this.props[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary
            if (!event.target) {
                // Fixes #1925 where srcElement might not be defined either
                event.target = event.srcElement || document;
            }

            // check if target is a textnode (safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if (!event.relatedTarget && event.fromElement) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if (event.pageX == null && event.clientX != null) {
                var eventDocument = event.target.ownerDocument || document,
				doc = eventDocument.documentElement,
				body = eventDocument.body;

                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            // Add which for key events
            if (event.which == null && (event.charCode != null || event.keyCode != null)) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if (!event.metaKey && event.ctrlKey) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if (!event.which && event.button !== undefined) {
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0)));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: function (handleObj) {
                    jQuery.event.add(this,
					liveConvert(handleObj.origType, handleObj.selector),
					jQuery.extend({}, handleObj, { handler: liveHandler, guid: handleObj.handler.guid }));
                },

                remove: function (handleObj) {
                    jQuery.event.remove(this, liveConvert(handleObj.origType, handleObj.selector), handleObj);
                }
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
	function (elem, type, handle) {
	    if (elem.removeEventListener) {
	        elem.removeEventListener(type, handle, false);
	    }
	} :
	function (elem, type, handle) {
	    if (elem.detachEvent) {
	        elem.detachEvent("on" + type, handle);
	    }
	};

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!this.preventDefault) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function (event) {

        // Check if mouse(over|out) are still within the same parent element
        var related = event.relatedTarget,
		inside = false,
		eventType = event.type;

        event.type = event.data;

        if (related !== this) {

            if (related) {
                inside = jQuery.contains(this, related);
            }

            if (!inside) {

                jQuery.event.handle.apply(this, arguments);

                event.type = eventType;
            }
        }
    },

    // In case of event delegation, we only need to rename the event.type,
    // liveHandler will take care of the rest.
delegate = function (event) {
    event.type = event.data;
    jQuery.event.handle.apply(this, arguments);
};

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            setup: function (data) {
                jQuery.event.add(this, fix, data && data.selector ? delegate : withinElement, orig);
            },
            teardown: function (data) {
                jQuery.event.remove(this, fix, data && data.selector ? delegate : withinElement);
            }
        };
    });

    // submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function (data, namespaces) {
                if (!jQuery.nodeName(this, "form")) {
                    jQuery.event.add(this, "click.specialSubmit", function (e) {
                        var elem = e.target,
						type = elem.type;

                        if ((type === "submit" || type === "image") && jQuery(elem).closest("form").length) {
                            trigger("submit", this, arguments);
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function (e) {
                        var elem = e.target,
						type = elem.type;

                        if ((type === "text" || type === "password") && jQuery(elem).closest("form").length && e.keyCode === 13) {
                            trigger("submit", this, arguments);
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialSubmit");
            }
        };

    }

    // change delegation, happens here so we have bind.
    if (!jQuery.support.changeBubbles) {

        var changeFilters,

	getVal = function (elem) {
	    var type = elem.type, val = elem.value;

	    if (type === "radio" || type === "checkbox") {
	        val = elem.checked;

	    } else if (type === "select-multiple") {
	        val = elem.selectedIndex > -1 ?
				jQuery.map(elem.options, function (elem) {
				    return elem.selected;
				}).join("-") :
				"";

	    } else if (jQuery.nodeName(elem, "select")) {
	        val = elem.selectedIndex;
	    }

	    return val;
	},

	testChange = function testChange(e) {
	    var elem = e.target, data, val;

	    if (!rformElems.test(elem.nodeName) || elem.readOnly) {
	        return;
	    }

	    data = jQuery._data(elem, "_change_data");
	    val = getVal(elem);

	    // the current data will be also retrieved by beforeactivate
	    if (e.type !== "focusout" || elem.type !== "radio") {
	        jQuery._data(elem, "_change_data", val);
	    }

	    if (data === undefined || val === data) {
	        return;
	    }

	    if (data != null || val) {
	        e.type = "change";
	        e.liveFired = undefined;
	        jQuery.event.trigger(e, arguments[1], elem);
	    }
	};

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function (e) {
                    var elem = e.target, type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if (type === "radio" || type === "checkbox" || jQuery.nodeName(elem, "select")) {
                        testChange.call(this, e);
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function (e) {
                    var elem = e.target, type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if ((e.keyCode === 13 && !jQuery.nodeName(elem, "textarea")) ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple") {
                        testChange.call(this, e);
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate: function (e) {
                    var elem = e.target;
                    jQuery._data(elem, "_change_data", getVal(elem));
                }
            },

            setup: function (data, namespaces) {
                if (this.type === "file") {
                    return false;
                }

                for (var type in changeFilters) {
                    jQuery.event.add(this, type + ".specialChange", changeFilters[type]);
                }

                return rformElems.test(this.nodeName);
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialChange");

                return rformElems.test(this.nodeName);
            }
        };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger(type, elem, args) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        // Don't pass args or remember liveFired; they apply to the donor event.
        var event = jQuery.extend({}, args[0]);
        event.type = type;
        event.originalEvent = {};
        event.liveFired = undefined;
        jQuery.event.handle.call(elem, event);
        if (event.isDefaultPrevented()) {
            args[0].preventDefault();
        }
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0;

            jQuery.event.special[fix] = {
                setup: function () {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };

            function handler(donor) {
                // Donor event is always a native one; fix it and switch its type.
                // Let focusin/out handler cancel the donor focus/blur event.
                var e = jQuery.event.fix(donor);
                e.type = fix;
                e.originalEvent = {};
                jQuery.event.trigger(e, null, e.target);
                if (e.isDefaultPrevented()) {
                    donor.preventDefault();
                }
            }
        });
    }

    jQuery.each(["bind", "one"], function (i, name) {
        jQuery.fn[name] = function (type, data, fn) {
            var handler;

            // Handle object literals
            if (typeof type === "object") {
                for (var key in type) {
                    this[name](key, data, type[key], fn);
                }
                return this;
            }

            if (arguments.length === 2 || data === false) {
                fn = data;
                data = undefined;
            }

            if (name === "one") {
                handler = function (event) {
                    jQuery(this).unbind(event, handler);
                    return fn.apply(this, arguments);
                };
                handler.guid = fn.guid || jQuery.guid++;
            } else {
                handler = fn;
            }

            if (type === "unload" && name !== "one") {
                this.one(type, data, fn);

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.add(this[i], type, handler, data);
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: function (type, fn) {
            // Handle object literals
            if (typeof type === "object" && !type.preventDefault) {
                for (var key in type) {
                    this.unbind(key, type[key]);
                }

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.remove(this[i], type, fn);
                }
            }

            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.live(types, data, fn, selector);
        },

        undelegate: function (selector, types, fn) {
            if (arguments.length === 0) {
                return this.unbind("live");

            } else {
                return this.die(types, null, fn, selector);
            }
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },

        triggerHandler: function (type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function (event) {
			    // Figure out which function to execute
			    var lastToggle = (jQuery.data(this, "lastToggle" + fn.guid) || 0) % i;
			    jQuery.data(this, "lastToggle" + fn.guid, lastToggle + 1);

			    // Make sure that clicks stop
			    event.preventDefault();

			    // and execute the function
			    return args[lastToggle].apply(this, arguments) || false;
			};

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }

            return this.click(toggler);
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function (i, name) {
        jQuery.fn[name] = function (types, data, fn, origSelector /* Internal Use Only */) {
            var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery(this.context);

            if (typeof types === "object" && !types.preventDefault) {
                for (var key in types) {
                    context[name](key, data, types[key], selector);
                }

                return this;
            }

            if (name === "die" && !types &&
					origSelector && origSelector.charAt(0) === ".") {

                context.unbind(origSelector);

                return this;
            }

            if (data === false || jQuery.isFunction(data)) {
                fn = data || returnFalse;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ((type = types[i++]) != null) {
                match = rnamespaces.exec(type);
                namespaces = "";

                if (match) {
                    namespaces = match[0];
                    type = type.replace(rnamespaces, "");
                }

                if (type === "hover") {
                    types.push("mouseenter" + namespaces, "mouseleave" + namespaces);
                    continue;
                }

                preType = type;

                if (liveMap[type]) {
                    types.push(liveMap[type] + namespaces);
                    type = type + namespaces;

                } else {
                    type = (liveMap[type] || type) + namespaces;
                }

                if (name === "live") {
                    // bind live handler
                    for (var j = 0, l = context.length; j < l; j++) {
                        jQuery.event.add(context[j], "live." + liveConvert(type, selector),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType });
                    }

                } else {
                    // unbind live handler
                    context.unbind("live." + liveConvert(type, selector), fn);
                }
            }

            return this;
        };
    });

    function liveHandler(event) {
        var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery._data(this, "events");

        // Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
        if (event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click") {
            return;
        }

        if (event.namespace) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for (j = 0; j < live.length; j++) {
            handleObj = live[j];

            if (handleObj.origType.replace(rnamespaces, "") === event.type) {
                selectors.push(handleObj.selector);

            } else {
                live.splice(j--, 1);
            }
        }

        match = jQuery(event.target).closest(selectors, event.currentTarget);

        for (i = 0, l = match.length; i < l; i++) {
            close = match[i];

            for (j = 0; j < live.length; j++) {
                handleObj = live[j];

                if (close.selector === handleObj.selector && (!namespace || namespace.test(handleObj.namespace)) && !close.elem.disabled) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if (handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave") {
                        event.type = handleObj.preType;
                        related = jQuery(event.relatedTarget).closest(handleObj.selector)[0];

                        // Make sure not to accidentally match a child element with the same selector
                        if (related && jQuery.contains(elem, related)) {
                            related = elem;
                        }
                    }

                    if (!related || related !== elem) {
                        elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                    }
                }
            }
        }

        for (i = 0, l = elems.length; i < l; i++) {
            match = elems[i];

            if (maxLevel && match.level > maxLevel) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply(match.elem, arguments);

            if (ret === false || event.isPropagationStopped()) {
                maxLevel = match.level;

                if (ret === false) {
                    stop = false;
                }
                if (event.isImmediatePropagationStopped()) {
                    break;
                }
            }
        }

        return stop;
    }

    function liveConvert(type, selector) {
        return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
    }

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function (i, name) {

	    // Handle event binding
	    jQuery.fn[name] = function (data, fn) {
	        if (fn == null) {
	            fn = data;
	            data = null;
	        }

	        return arguments.length > 0 ?
			this.bind(name, data, fn) :
			this.trigger(name);
	    };

	    if (jQuery.attrFn) {
	        jQuery.attrFn[name] = true;
	    }
	});



    /*!
    * Sizzle CSS Selector Engine
    *  Copyright 2011, The Dojo Foundation
    *  Released under the MIT, BSD, and GPL Licenses.
    *  More information: http://sizzlejs.com/
    */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(function () {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function (selector, context, results, seed) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if (context.nodeType !== 1 && context.nodeType !== 9) {
                return [];
            }

            if (!selector || typeof selector !== "string") {
                return results;
            }

            var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML(context),
		parts = [],
		soFar = selector;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                    soFar = m[3];

                    parts.push(m[1]);

                    if (m[2]) {
                        extra = m[3];
                        break;
                    }
                }
            } while (m);

            if (parts.length > 1 && origPOS.exec(selector)) {

                if (parts.length === 2 && Expr.relative[parts[0]]) {
                    set = posProcess(parts[0] + parts[1], context);

                } else {
                    set = Expr.relative[parts[0]] ?
				[context] :
				Sizzle(parts.shift(), context);

                    while (parts.length) {
                        selector = parts.shift();

                        if (Expr.relative[selector]) {
                            selector += parts.shift();
                        }

                        set = posProcess(selector, set);
                    }
                }

            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {

                    ret = Sizzle.find(parts.shift(), context, contextXML);
                    context = ret.expr ?
				Sizzle.filter(ret.expr, ret.set)[0] :
				ret.set[0];
                }

                if (context) {
                    ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed)} :
				Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);

                    set = ret.expr ?
				Sizzle.filter(ret.expr, ret.set) :
				ret.set;

                    if (parts.length > 0) {
                        checkSet = makeArray(set);

                    } else {
                        prune = false;
                    }

                    while (parts.length) {
                        cur = parts.pop();
                        pop = cur;

                        if (!Expr.relative[cur]) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if (pop == null) {
                            pop = context;
                        }

                        Expr.relative[cur](checkSet, pop, contextXML);
                    }

                } else {
                    checkSet = parts = [];
                }
            }

            if (!checkSet) {
                checkSet = set;
            }

            if (!checkSet) {
                Sizzle.error(cur || selector);
            }

            if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                    results.push.apply(results, checkSet);

                } else if (context && context.nodeType === 1) {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                            results.push(set[i]);
                        }
                    }

                } else {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && checkSet[i].nodeType === 1) {
                            results.push(set[i]);
                        }
                    }
                }

            } else {
                makeArray(checkSet, results);
            }

            if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
            }

            return results;
        };

        Sizzle.uniqueSort = function (results) {
            if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                    for (var i = 1; i < results.length; i++) {
                        if (results[i] === results[i - 1]) {
                            results.splice(i--, 1);
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function (expr, set) {
            return Sizzle(expr, null, null, set);
        };

        Sizzle.matchesSelector = function (node, expr) {
            return Sizzle(expr, null, null, [node]).length > 0;
        };

        Sizzle.find = function (expr, context, isXML) {
            var set;

            if (!expr) {
                return [];
            }

            for (var i = 0, l = Expr.order.length; i < l; i++) {
                var match,
			type = Expr.order[i];

                if ((match = Expr.leftMatch[type].exec(expr))) {
                    var left = match[1];
                    match.splice(1, 1);

                    if (left.substr(left.length - 1) !== "\\") {
                        match[1] = (match[1] || "").replace(rBackslash, "");
                        set = Expr.find[type](match, context, isXML);

                        if (set != null) {
                            expr = expr.replace(Expr.match[type], "");
                            break;
                        }
                    }
                }
            }

            if (!set) {
                set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName("*") :
			[];
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function (expr, set, inplace, not) {
            var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

            while (expr && set.length) {
                for (var type in Expr.filter) {
                    if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                        var found, item,
					filter = Expr.filter[type],
					left = match[1];

                        anyFound = false;

                        match.splice(1, 1);

                        if (left.substr(left.length - 1) === "\\") {
                            continue;
                        }

                        if (curLoop === result) {
                            result = [];
                        }

                        if (Expr.preFilter[type]) {
                            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                            if (!match) {
                                anyFound = found = true;

                            } else if (match === true) {
                                continue;
                            }
                        }

                        if (match) {
                            for (var i = 0; (item = curLoop[i]) != null; i++) {
                                if (item) {
                                    found = filter(item, match, i, curLoop);
                                    var pass = not ^ !!found;

                                    if (inplace && found != null) {
                                        if (pass) {
                                            anyFound = true;

                                        } else {
                                            curLoop[i] = false;
                                        }

                                    } else if (pass) {
                                        result.push(item);
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if (found !== undefined) {
                            if (!inplace) {
                                curLoop = result;
                            }

                            expr = expr.replace(Expr.match[type], "");

                            if (!anyFound) {
                                return [];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if (expr === old) {
                    if (anyFound == null) {
                        Sizzle.error(expr);

                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function (msg) {
            throw "Syntax error, unrecognized expression: " + msg;
        };

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],

            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },

            leftMatch: {},

            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },

            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                },
                type: function (elem) {
                    return elem.getAttribute("type");
                }
            },

            relative: {
                "+": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test(part),
				isPartStrNotTag = isPartStr && !isTag;

                    if (isTag) {
                        part = part.toLowerCase();
                    }

                    for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                        if ((elem = checkSet[i])) {
                            while ((elem = elem.previousSibling) && elem.nodeType !== 1) { }

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
                        }
                    }

                    if (isPartStrNotTag) {
                        Sizzle.filter(part, checkSet, true);
                    }
                },

                ">": function (checkSet, part) {
                    var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

                    if (isPartStr && !rNonWord.test(part)) {
                        part = part.toLowerCase();

                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }

                    } else {
                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
                            }
                        }

                        if (isPartStr) {
                            Sizzle.filter(part, checkSet, true);
                        }
                    }
                },

                "": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },

                "~": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
            },

            find: {
                ID: function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },

                NAME: function (match, context) {
                    if (typeof context.getElementsByName !== "undefined") {
                        var ret = [],
					results = context.getElementsByName(match[1]);

                        for (var i = 0, l = results.length; i < l; i++) {
                            if (results[i].getAttribute("name") === match[1]) {
                                ret.push(results[i]);
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },

                TAG: function (match, context) {
                    if (typeof context.getElementsByTagName !== "undefined") {
                        return context.getElementsByTagName(match[1]);
                    }
                }
            },
            preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                    match = " " + match[1].replace(rBackslash, "") + " ";

                    if (isXML) {
                        return match;
                    }

                    for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                        if (elem) {
                            if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0)) {
                                if (!inplace) {
                                    result.push(elem);
                                }

                            } else if (inplace) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },

                ID: function (match) {
                    return match[1].replace(rBackslash, "");
                },

                TAG: function (match, curLoop) {
                    return match[1].replace(rBackslash, "").toLowerCase();
                },

                CHILD: function (match) {
                    if (match[1] === "nth") {
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }

                        match[2] = match[2].replace(/^\+|\s*/g, '');

                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }
                    else if (match[2]) {
                        Sizzle.error(match[0]);
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },

                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                    var name = match[1] = match[1].replace(rBackslash, "");

                    if (!isXML && Expr.attrMap[name]) {
                        match[1] = Expr.attrMap[name];
                    }

                    // Handle if an un-quoted value was used
                    match[4] = (match[4] || match[5] || "").replace(rBackslash, "");

                    if (match[2] === "~=") {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },

                PSEUDO: function (match, curLoop, inplace, result, not) {
                    if (match[1] === "not") {
                        // If we're dealing with a complex expression, or a simple one
                        if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                            match[3] = Sizzle(match[3], null, null, curLoop);

                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                            if (!inplace) {
                                result.push.apply(result, ret);
                            }

                            return false;
                        }

                    } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                        return true;
                    }

                    return match;
                },

                POS: function (match) {
                    match.unshift(true);

                    return match;
                }
            },

            filters: {
                enabled: function (elem) {
                    return elem.disabled === false && elem.type !== "hidden";
                },

                disabled: function (elem) {
                    return elem.disabled === true;
                },

                checked: function (elem) {
                    return elem.checked === true;
                },

                selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                parent: function (elem) {
                    return !!elem.firstChild;
                },

                empty: function (elem) {
                    return !elem.firstChild;
                },

                has: function (elem, i, match) {
                    return !!Sizzle(match[3], elem).length;
                },

                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },

                text: function (elem) {
                    var attr = elem.getAttribute("type"), type = elem.type;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" && "text" === type && (attr === type || attr === null);
                },

                radio: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                },

                reset: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "reset" === elem.type;
                },

                button: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && "button" === elem.type || name === "button";
                },

                input: function (elem) {
                    return (/input|select|textarea|button/i).test(elem.nodeName);
                },

                focus: function (elem) {
                    return elem === elem.ownerDocument.activeElement;
                }
            },
            setFilters: {
                first: function (elem, i) {
                    return i === 0;
                },

                last: function (elem, i, match, array) {
                    return i === array.length - 1;
                },

                even: function (elem, i) {
                    return i % 2 === 0;
                },

                odd: function (elem, i) {
                    return i % 2 === 1;
                },

                lt: function (elem, i, match) {
                    return i < match[3] - 0;
                },

                gt: function (elem, i, match) {
                    return i > match[3] - 0;
                },

                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },

                eq: function (elem, i, match) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function (elem, match, i, array) {
                    var name = match[1],
				filter = Expr.filters[name];

                    if (filter) {
                        return filter(elem, i, match, array);

                    } else if (name === "contains") {
                        return (elem.textContent || elem.innerText || Sizzle.getText([elem]) || "").indexOf(match[3]) >= 0;

                    } else if (name === "not") {
                        var not = match[3];

                        for (var j = 0, l = not.length; j < l; j++) {
                            if (not[j] === elem) {
                                return false;
                            }
                        }

                        return true;

                    } else {
                        Sizzle.error(name);
                    }
                },

                CHILD: function (elem, match) {
                    var type = match[1],
				node = elem;

                    switch (type) {
                        case "only":
                        case "first":
                            while ((node = node.previousSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            if (type === "first") {
                                return true;
                            }

                            node = elem;

                        case "last":
                            while ((node = node.nextSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            return true;

                        case "nth":
                            var first = match[2],
						last = match[3];

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            var doneName = match[0],
						parent = elem.parentNode;

                            if (parent && (parent.sizcache !== doneName || !elem.nodeIndex)) {
                                var count = 0;

                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        node.nodeIndex = ++count;
                                    }
                                }

                                parent.sizcache = doneName;
                            }

                            var diff = elem.nodeIndex - last;

                            if (first === 0) {
                                return diff === 0;

                            } else {
                                return (diff % first === 0 && diff / first >= 0);
                            }
                    }
                },

                ID: function (elem, match) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },

                TAG: function (elem, match) {
                    return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
                },

                CLASS: function (elem, match) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf(match) > -1;
                },

                ATTR: function (elem, match) {
                    var name = match[1],
				result = Expr.attrHandle[name] ?
					Expr.attrHandle[name](elem) :
					elem[name] != null ?
						elem[name] :
						elem.getAttribute(name),
				value = result + "",
				type = match[2],
				check = match[4];

                    return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
                },

                POS: function (elem, match, i, array) {
                    var name = match[2],
				filter = Expr.setFilters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
	fescape = function (all, num) {
	    return "\\" + (num - 0 + 1);
	};

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = function (array, results) {
            array = Array.prototype.slice.call(array, 0);

            if (results) {
                results.push.apply(results, array);
                return results;
            }

            return array;
        };

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = function (array, results) {
                var i = 0,
			ret = results || [];

                if (toString.call(array) === "[object Array]") {
                    Array.prototype.push.apply(ret, array);

                } else {
                    if (typeof array.length === "number") {
                        for (var l = array.length; i < l; i++) {
                            ret.push(array[i]);
                        }

                    } else {
                        for (; array[i]; i++) {
                            ret.push(array[i]);
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };

        } else {
            sortOrder = function (a, b) {
                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if (a.sourceIndex && b.sourceIndex) {
                    return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
			siblingCheck(a, bp[i], -1) :
			siblingCheck(ap[i], b, 1);
            };

            siblingCheck = function (a, b, ret) {
                if (a === b) {
                    return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                    if (cur === b) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

        // Utility function for retreiving the text value of an array of DOM nodes
        Sizzle.getText = function (elems) {
            var ret = "", elem;

            for (var i = 0; elems[i]; i++) {
                elem = elems[i];

                // Get the text from text nodes and CDATA nodes
                if (elem.nodeType === 3 || elem.nodeType === 4) {
                    ret += elem.nodeValue;

                    // Traverse everything else, except comment nodes
                } else if (elem.nodeType !== 8) {
                    ret += Sizzle.getText(elem.childNodes);
                }
            }

            return ret;
        };

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (function () {
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            root.insertBefore(form, root.firstChild);

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);

                        return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
                    }
                };

                Expr.filter.ID = function (elem, match) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild(form);

            // release memory in IE
            root = form = null;
        })();

        (function () {
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild(document.createComment(""));

            // Make sure no comments are found
            if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                    var results = context.getElementsByTagName(match[1]);

                    // Filter out possible comments
                    if (match[1] === "*") {
                        var tmp = [];

                        for (var i = 0; results[i]; i++) {
                            if (results[i].nodeType === 1) {
                                tmp.push(results[i]);
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";

            if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#") {

                Expr.attrHandle.href = function (elem) {
                    return elem.getAttribute("href", 2);
                };
            }

            // release memory in IE
            div = null;
        })();

        if (document.querySelectorAll) {
            (function () {
                var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                    return;
                }

                Sizzle = function (query, context, extra, seed) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if (!seed && !Sizzle.isXML(context)) {
                        // See if we find a selector to speed up
                        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(query);

                        if (match && (context.nodeType === 1 || context.nodeType === 9)) {
                            // Speed-up: Sizzle("TAG")
                            if (match[1]) {
                                return makeArray(context.getElementsByTagName(query), extra);

                                // Speed-up: Sizzle(".CLASS")
                            } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {
                                return makeArray(context.getElementsByClassName(match[2]), extra);
                            }
                        }

                        if (context.nodeType === 9) {
                            // Speed-up: Sizzle("body")
                            // The body element only exists once, optimize finding it
                            if (query === "body" && context.body) {
                                return makeArray([context.body], extra);

                                // Speed-up: Sizzle("#ID")
                            } else if (match && match[3]) {
                                var elem = context.getElementById(match[3]);

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if (elem.id === match[3]) {
                                        return makeArray([elem], extra);
                                    }

                                } else {
                                    return makeArray([], extra);
                                }
                            }

                            try {
                                return makeArray(context.querySelectorAll(query), extra);
                            } catch (qsaError) { }

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            var oldContext = context,
						old = context.getAttribute("id"),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test(query);

                            if (!old) {
                                context.setAttribute("id", nid);
                            } else {
                                nid = nid.replace(/'/g, "\\$&");
                            }
                            if (relativeHierarchySelector && hasParent) {
                                context = context.parentNode;
                            }

                            try {
                                if (!relativeHierarchySelector || hasParent) {
                                    return makeArray(context.querySelectorAll("[id='" + nid + "'] " + query), extra);
                                }

                            } catch (pseudoError) {
                            } finally {
                                if (!old) {
                                    oldContext.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                    Sizzle[prop] = oldSizzle[prop];
                }

                // release memory in IE
                div = null;
            })();
        }

        (function () {
            var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

            if (matches) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9 fails this)
                var disconnectedMatch = !matches.call(document.createElement("div"), "div"),
			pseudoWorks = false;

                try {
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(document.documentElement, "[test!='']:sizzle");

                } catch (pseudoError) {
                    pseudoWorks = true;
                }

                Sizzle.matchesSelector = function (node, expr) {
                    // Make sure that attribute selectors are quoted
                    expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                    if (!Sizzle.isXML(node)) {
                        try {
                            if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {
                                var ret = matches.call(node, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || !disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11) {
                                    return ret;
                                }
                            }
                        } catch (e) { }
                    }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function () {
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if (div.getElementsByClassName("e").length === 1) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            // release memory in IE
            div = null;
        })();

        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1 && !isXML) {
                            elem.sizcache = doneName;
                            elem.sizset = i;
                        }

                        if (elem.nodeName.toLowerCase() === cur) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1) {
                            if (!isXML) {
                                elem.sizcache = doneName;
                                elem.sizset = i;
                            }

                            if (typeof cur !== "string") {
                                if (elem === cur) {
                                    match = true;
                                    break;
                                }

                            } else if (Sizzle.filter(cur, [elem]).length > 0) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        if (document.documentElement.contains) {
            Sizzle.contains = function (a, b) {
                return a !== b && (a.contains ? a.contains(b) : true);
            };

        } else if (document.documentElement.compareDocumentPosition) {
            Sizzle.contains = function (a, b) {
                return !!(a.compareDocumentPosition(b) & 16);
            };

        } else {
            Sizzle.contains = function () {
                return false;
            };
        }

        Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833) 
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function (selector, context) {
            var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet);
            }

            return Sizzle.filter(later, tmpSet);
        };

        // EXPOSE
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
    // Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
    // methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
	    children: true,
	    contents: true,
	    next: true,
	    prev: true
	};

    jQuery.fn.extend({
        find: function (selector) {
            var self = this,
			i, l;

            if (typeof selector !== "string") {
                return jQuery(selector).filter(function () {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }

            var ret = this.pushStack("", "find", selector),
			length, n, r;

            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var targets = jQuery(target);
            return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && (typeof selector === "string" ?
			jQuery.filter(selector, this).length > 0 :
			this.filter(selector).length > 0);
        },

        closest: function (selectors, context) {
            var ret = [], i, l, cur = this[0];

            // Array
            if (jQuery.isArray(selectors)) {
                var match, selector,
				matches = {},
				level = 1;

                if (cur && selectors.length) {
                    for (i = 0, l = selectors.length; i < l; i++) {
                        selector = selectors[i];

                        if (!matches[selector]) {
                            matches[selector] = POS.test(selector) ?
							jQuery(selector, context || this.context) :
							selector;
                        }
                    }

                    while (cur && cur.ownerDocument && cur !== context) {
                        for (selector in matches) {
                            match = matches[selector];

                            if (match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match)) {
                                ret.push({ selector: selector, elem: cur, level: level });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            // String
            var pos = POS.test(selectors) || typeof selectors !== "string" ?
				jQuery(selectors, context || this.context) :
				0;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {
            if (!elem || typeof elem === "string") {
                return jQuery.inArray(this[0],
                // If it receives a string, the selector is used
                // If it receives nothing, the siblings are used
				elem ? jQuery(elem) : this.parent().children());
            }
            // Locate the position of the desired element
            return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
				jQuery(selector, context) :
				jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
			all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
			all :
			jQuery.unique(all));
        },

        andSelf: function () {
            return this.add(this.prevObject);
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: function (elem) {
            return jQuery.nth(elem, 2, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(elem.parentNode.firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray(elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until),
            // The variable 'args' was introduced in
            // https://github.com/jquery/jquery/commit/52a0238
            // to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
            // http://code.google.com/p/v8/issues/detail?id=1050
			args = slice.call(arguments);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

            if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, args.join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
			jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [],
			cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function (cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                    break;
                }
            }

            return cur;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }




    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
    // checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
	    option: [1, "<select multiple='multiple'>", "</select>"],
	    legend: [1, "<fieldset>", "</fieldset>"],
	    thead: [1, "<table>", "</table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
	    area: [1, "<map>", "</map>"],
	    _default: [0, "", ""]
	};

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (text) {
            if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                    var self = jQuery(this);

                    self.text(text.call(this, i, self.text()));
                });
            }

            if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
            }

            return jQuery.text(this);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
				contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            return this.each(function () {
                jQuery(this).wrapAll(html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            } else if (arguments.length) {
                var set = jQuery(arguments[0]);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
            }
        },

        after: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery(arguments[0]).toArray());
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

                // See if we can take a shortcut and just use innerHTML
            } else if (typeof value === "string" && !rnocache.test(value) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
			!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for (var i = 0, l = this.length; i < l; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (this[i].nodeType === 1) {
                            jQuery.cleanData(this[i].getElementsByTagName("*"));
                            this[i].innerHTML = value;
                        }
                    }

                    // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                    this.empty().append(value);
                }

            } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                    var self = jQuery(this);

                    self.html(value.call(this, i, self.html()));
                });

            } else {
                this.empty().append(value);
            }

            return this;
        },

        replaceWith: function (value) {
            if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling,
					parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            } else {
                return this.length ?
				this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
				this;
            }
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {
            var results, first, fragment, parent,
			value = args[0],
			scripts = [];

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback, true);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    for (var i = 0, l = this.length, lastIndex = l - 1; i < l; i++) {
                        callback.call(
						table ?
							root(this[i], first) :
							this[i],
                        // Make sure that we do not leak memory by inadvertently discarding
                        // the original fragment (which might have attached data) instead of
                        // using it; in addition, use the original fragment object for the last
                        // item instead of first because it can end up being emptied incorrectly
                        // in certain situations (Bug #8070).
                        // Fragments from the fragment cache must always be cloned and never used
                        // in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone(fragment, true, true) :
							fragment
					);
                    }
                }

                if (scripts.length) {
                    jQuery.each(scripts, evalScript);
                }
            }

            return this;
        }
    });

    function root(elem, cur) {
        return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
    }

    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var internalKey = jQuery.expando,
		oldData = jQuery.data(src),
		curData = jQuery.data(dest, oldData);

        // Switch to use the internal data object, if it exists, for the next
        // stage of data copying
        if ((oldData = oldData[internalKey])) {
            var events = oldData.events;
            curData = curData[internalKey] = jQuery.extend({}, oldData);

            if (events) {
                delete curData.handle;
                curData.events = {};

                for (var type in events) {
                    for (var i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type + (events[type][i].namespace ? "." : "") + events[type][i].namespace, events[type][i], events[type][i].data);
                    }
                }
            }
        }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if (nodeName === "object") {
            dest.outerHTML = src.outerHTML;

        } else if (nodeName === "input" && (src.type === "checkbox" || src.type === "radio")) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if (src.checked) {
                dest.defaultChecked = dest.checked = src.checked;
            }

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute(jQuery.expando);
    }

    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults, doc;

        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if (nodes && nodes[0]) {
            doc = nodes[0].ownerDocument || nodes[0];
        }

        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if (!doc.createDocumentFragment) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if (args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		args[0].charAt(0) === "<" && !rnocache.test(args[0]) && (jQuery.support.checkClone || !rchecked.test(args[0]))) {

            cacheable = true;

            cacheresults = jQuery.fragments[args[0]];
            if (cacheresults && cacheresults !== 1) {
                fragment = cacheresults;
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[args[0]] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var ret = [],
			insert = jQuery(selector),
			parent = this.length === 1 && this[0].parentNode;

            if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

            } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) {
        if ("getElementsByTagName" in elem) {
            return elem.getElementsByTagName("*");

        } else if ("querySelectorAll" in elem) {
            return elem.querySelectorAll("*");

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (elem.type === "checkbox" || elem.type === "radio") {
            elem.defaultChecked = elem.checked;
        }
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs(elem) {
        if (jQuery.nodeName(elem, "input")) {
            fixDefaultChecked(elem);
        } else if ("getElementsByTagName" in elem) {
            jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var clone = elem.cloneNode(true),
				srcElements,
				destElements,
				i;

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName
                // instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    cloneFixAttributes(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function (elems, context, fragment, scripts) {
            var checkScriptType;

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [], j;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
						wrap = wrapMap[tag] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

                            // String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if (!jQuery.support.appendChecked) {
                    if (elem[0] && typeof (len = elem.length) === "number") {
                        for (j = 0; j < len; j++) {
                            findInputs(elem[j]);
                        }
                    } else {
                        findInputs(elem);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                checkScriptType = function (elem) {
                    return !elem.type || rscriptType.test(elem.type);
                };
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id] && cache[id][internalKey];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                                // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if (data.handle) {
                            data.handle.elem = null;
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    function evalScript(i, elem) {
        if (elem.src) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, "/*$0*/"));
        }

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }



    var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
    // fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^[+\-]=/,
	rrelNumFilter = /[^+\-\.\de]+/g,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = ["Left", "Right"],
	cssHeight = ["Top", "Bottom"],
	curCSS,

	getComputedStyle,
	currentStyle;

    jQuery.fn.css = function (name, value) {
        // Setting 'undefined' is a no-op
        if (arguments.length === 2 && value === undefined) {
            return this;
        }

        return jQuery.access(this, name, value, true, function (elem, name, value) {
            return value !== undefined ?
			jQuery.style(elem, name, value) :
			jQuery.css(elem, name);
        });
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity", "opacity");
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase(name),
			style = elem.style, hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Make sure that NaN and null values aren't set. See: #7116
                if (type === "number" && isNaN(value) || value == null) {
                    return;
                }

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && rrelNum.test(value)) {
                    value = +value.replace(rrelNumFilter, "") + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra) {
            var ret, hooks;

            // Make sure that we're working with the right name
            name = jQuery.camelCase(name);
            hooks = jQuery.cssHooks[name];
            name = jQuery.cssProps[name] || name;

            // cssFloat needs a special treatment
            if (name === "cssFloat") {
                name = "float";
            }

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if (curCSS) {
                return curCSS(elem, name);
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var old = {};

            // Remember the old values, and insert the new ones
            for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                var val;

                if (computed) {
                    if (elem.offsetWidth !== 0) {
                        return getWH(elem, name, extra);
                    } else {
                        jQuery.swap(elem, cssShow, function () {
                            val = getWH(elem, name, extra);
                        });
                    }

                    return val;
                }
            },

            set: function (elem, value) {
                if (rnumpx.test(value)) {
                    // ignore negative width and height values #1599
                    value = parseFloat(value);

                    if (value >= 0) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style,
				currentStyle = elem.currentStyle;

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // Set the alpha filter to set the opacity
                var opacity = jQuery.isNaN(value) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = currentStyle && currentStyle.filter || style.filter || "";

                style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				filter + " " + opacity;
            }
        };
    }

    jQuery(function () {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    var ret;
                    jQuery.swap(elem, { "display": "inline-block" }, function () {
                        if (computed) {
                            ret = curCSS(elem, "margin-right", "marginRight");
                        } else {
                            ret = elem.style.marginRight;
                        }
                    });
                    return ret;
                }
            };
        }
    });

    if (document.defaultView && document.defaultView.getComputedStyle) {
        getComputedStyle = function (elem, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if (!(defaultView = elem.ownerDocument.defaultView)) {
                return undefined;
            }

            if ((computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };
    }

    if (document.documentElement.currentStyle) {
        currentStyle = function (elem, name) {
            var left,
			ret = elem.currentStyle && elem.currentStyle[name],
			rsLeft = elem.runtimeStyle && elem.runtimeStyle[name],
			style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {
                // Remember the original values
                left = style.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWH(elem, name, extra) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight;

        if (val > 0) {
            if (extra !== "border") {
                jQuery.each(which, function () {
                    if (!extra) {
                        val -= parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                    }
                    if (extra === "margin") {
                        val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                    } else {
                        val -= parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                    }
                });
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS(elem, name, name);
        if (val < 0 || val == null) {
            val = elem.style[name] || 0;
        }
        // Normalize "", auto, and prepare for extra
        val = parseFloat(val) || 0;

        // Add padding, border, margin
        if (extra) {
            jQuery.each(which, function () {
                val += parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                if (extra !== "padding") {
                    val += parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                }
                if (extra === "margin") {
                    val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                }
            });
        }

        return val + "px";
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            var width = elem.offsetWidth,
			height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }




    var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    // #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

    // Keep a copy of the old load method
	_load = jQuery.fn.load,

    /* Prefilters
    * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    * 2) These are called:
    *    - BEFORE asking for a transport
    *    - AFTER param serialization (s.data is a string if s.processData is true)
    * 3) key is the dataType
    * 4) the catchall symbol "*" can be used
    * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    */
	prefilters = {},

    /* Transports bindings
    * 1) key is the dataType
    * 2) the catchall symbol "*" can be used
    * 3) selection will start with transport dataType and THEN go to "*" if needed
    */
	transports = {},

    // Document location
	ajaxLocation,

    // Document location segments
	ajaxLocParts;

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            if (jQuery.isFunction(func)) {
                var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    // then we add to the structure accordingly
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */) {

        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};

        inspected[dataType] = true;

        var list = structure[dataType],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = (structure === prefilters),
		selection;

        for (; i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected);
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    jQuery.fn.extend({
        load: function (url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
            } else if (!this.length) {
                return this;
            }

            var off = url.indexOf(" ");
            if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (typeof params === "object") {
                    params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function (jqXHR, status, responseText) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if (jqXHR.isResolved()) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function (r) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html(selector ?
                        // Create a dummy div to hold the results
						jQuery("<div>")
                        // inject the contents of the document in, removing the scripts
                        // to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

                        // Locate the specified elements
							.find(selector) :

                        // If not, just inject the full result
						responseText);
                    }

                    if (callback) {
                        self.each(callback, [responseText, status, jqXHR]);
                    }
                }
            });

            return this;
        },

        serialize: function () {
            return jQuery.param(this.serializeArray());
        },

        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
		.filter(function () {
		    return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
		})
		.map(function (i, elem) {
		    var val = jQuery(this).val();

		    return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map(val, function (val, i) {
					    return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					}) :
					{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
		}).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.bind(o, f);
        };
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            if (!settings) {
                // Only one parameter, we extend ajaxSettings
                settings = target;
                target = jQuery.extend(true, jQuery.ajaxSettings, settings);
            } else {
                // target was provided, we extend into it
                jQuery.extend(true, target, jQuery.ajaxSettings, settings);
            }
            // Flatten fields we don't want deep extended
            for (var field in { context: 1, url: 1 }) {
                if (field in settings) {
                    target[field] = settings[field];
                } else if (field in jQuery.ajaxSettings) {
                    target[field] = jQuery.ajaxSettings[field];
                }
            }
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": "*/*"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
			s = jQuery.ajaxSetup({}, options),
            // Callbacks context
			callbackContext = s.context || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				(callbackContext.nodeType || callbackContext instanceof jQuery) ?
						jQuery(callbackContext) : jQuery.event,
            // Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery._Deferred(),
            // Status-dependent callbacks
			statusCode = s.statusCode || {},
            // ifModified key
			ifModifiedKey,
            // Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
            // Response headers
			responseHeadersString,
			responseHeaders,
            // transport
			transport,
            // timeout handle
			timeoutTimer,
            // Cross-domain detection vars
			parts,
            // The jqXHR state
			state = 0,
            // To know if global events are to be dispatched
			fireGlobals,
            // Loop variable
			i,
            // Fake xhr
			jqXHR = {

			    readyState: 0,

			    // Caches the header
			    setRequestHeader: function (name, value) {
			        if (!state) {
			            var lname = name.toLowerCase();
			            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
			            requestHeaders[name] = value;
			        }
			        return this;
			    },

			    // Raw string
			    getAllResponseHeaders: function () {
			        return state === 2 ? responseHeadersString : null;
			    },

			    // Builds headers hashtable if needed
			    getResponseHeader: function (key) {
			        var match;
			        if (state === 2) {
			            if (!responseHeaders) {
			                responseHeaders = {};
			                while ((match = rheaders.exec(responseHeadersString))) {
			                    responseHeaders[match[1].toLowerCase()] = match[2];
			                }
			            }
			            match = responseHeaders[key.toLowerCase()];
			        }
			        return match === undefined ? null : match;
			    },

			    // Overrides response content-type header
			    overrideMimeType: function (type) {
			        if (!state) {
			            s.mimeType = type;
			        }
			        return this;
			    },

			    // Cancel the request
			    abort: function (statusText) {
			        statusText = statusText || "abort";
			        if (transport) {
			            transport.abort(statusText);
			        }
			        done(0, statusText);
			        return this;
			    }
			};

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done(status, statusText, responses, headers) {

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status ? 4 : 0;

                var isSuccess,
				success,
				error,
				response = responses ? ajaxHandleResponses(s, jqXHR, responses) : undefined,
				lastModified,
				etag;

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {

                        if ((lastModified = jqXHR.getResponseHeader("Last-Modified"))) {
                            jQuery.lastModified[ifModifiedKey] = lastModified;
                        }
                        if ((etag = jqXHR.getResponseHeader("Etag"))) {
                            jQuery.etag[ifModifiedKey] = etag;
                        }
                    }

                    // If not modified
                    if (status === 304) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        try {
                            success = ajaxConvert(s, response);
                            statusText = "success";
                            isSuccess = true;
                        } catch (e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = statusText;

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"),
						[jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.resolveWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.done;

            // Status-dependent callbacks
            jqXHR.statusCode = function (map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [statusCode[tmp], map[tmp]];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.then(tmp, tmp);
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(rspacesAjax);

            // Determine if a cross-domain request is in order
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
				(parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] ||
					(parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
						(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
			);
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefiler, stop there
            if (state === 2) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                    // try replacing _= if it is there
					ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", */*; q=0.01" : "") :
				s.accepts["*"]
		);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already
                jqXHR.abort();
                return false;

            }

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (status < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        jQuery.error(e);
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function (a, traditional) {
            var s = [],
			add = function (key, value) {
			    // If value is a function, invoke it and return its value
			    value = jQuery.isFunction(value) ? value() : value;
			    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
			};

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }

            // Return the resulting serialization
            return s.join("&").replace(r20, "+");
        }
    });

    function buildParams(prefix, obj, traditional, add) {
        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && obj != null && typeof obj === "object") {
            // Serialize object item.
            for (var name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
    * - sets all responseXXX fields accordingly
    * - finds the right dataType (mediates between content-type and expected dataType)
    * - returns the corresponding response
    */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

        // Fill responseXXX fields
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert(s, response) {

        // Apply the dataFilter if provided
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }

        var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
        // Current and previous dataTypes
		current = dataTypes[0],
		prev,
        // Conversion expression
		conversion,
        // Conversion function
		conv,
        // Conversion functions (transitive conversion)
		conv1,
		conv2;

        // For each dataType in the chain
        for (i = 1; i < length; i++) {

            // Create converters map
            // with lowercased keys
            if (i === 1) {
                for (key in s.converters) {
                    if (typeof key === "string") {
                        converters[key.toLowerCase()] = s.converters[key];
                    }
                }
            }

            // Get the dataTypes
            prev = current;
            current = dataTypes[i];

            // If current is auto dataType, update it to prev
            if (current === "*") {
                current = prev;
                // If no auto and dataTypes are actually different
            } else if (prev !== "*" && prev !== current) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[conversion] || converters["* " + current];

                // If there is no direct converter, search transitively
                if (!conv) {
                    conv2 = undefined;
                    for (conv1 in converters) {
                        tmp = conv1.split(" ");
                        if (tmp[0] === prev || tmp[0] === "*") {
                            conv2 = converters[tmp[1] + " " + current];
                            if (conv2) {
                                conv1 = converters[conv1];
                                if (conv1 === true) {
                                    conv = conv2;
                                } else if (conv2 === true) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if (!(conv || conv2)) {
                    jQuery.error("No conversion from " + conversion.replace(" ", " to "));
                }
                // If found converter is not an equivalence
                if (conv !== true) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv(response) : conv2(conv1(response));
                }
            }
        }
        return response;
    }




    var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            return jQuery.expando + "_" + (jsc++);
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		(typeof s.data === "string");

        if (s.dataTypes[0] === "jsonp" ||
		s.jsonp !== false && (jsre.test(s.url) ||
				inspectData && jsre.test(s.data))) {

            var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[jsonpCallback],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

            if (s.jsonp !== false) {
                url = url.replace(jsre, replace);
                if (s.url === url) {
                    if (inspectData) {
                        data = data.replace(jsre, replace);
                    }
                    if (s.data === data) {
                        // Add callback manually
                        url += (/\?/.test(url) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }

            s.url = url;
            s.data = data;

            // Install callback
            window[jsonpCallback] = function (response) {
                responseContainer = [response];
            };

            // Clean-up function
            jqXHR.always(function () {
                // Set callback back to previous value
                window[jsonpCallback] = previous;
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(previous)) {
                    window[jsonpCallback](responseContainer[0]);
                }
            });

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(jsonpCallback + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Delegate to script
            return "script";
        }
    });




    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {

            var script,
			head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

            return {

                send: function (_, callback) {

                    script = document.createElement("script");

                    script.async = "async";

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function (_, isAbort) {

                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });




    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function () {
	    // Abort all pending requests
	    for (var key in xhrCallbacks) {
	        xhrCallbacks[key](0, 1);
	    }
	} : false,
	xhrId = 0,
	xhrCallbacks;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) { }
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
    * implement the XMLHttpRequest in IE7 (can't request local files),
    * so we use the ActiveXObject when it is available
    * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
    * we need a fallback.
    */
	function () {
	    return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
    // For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

    // Determine support properties
    (function (xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ("withCredentials" in xhr)
        });
    })(jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(function (s) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                    send: function (headers, complete) {

                        // Get a new xhr
                        var xhr = s.xhr(),
						handle,
						i;

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }

                        // Apply custom fields if provided
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) { }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((s.hasContent && s.data) || null);

                        // Listener
                        callback = function (_, isAbort) {

                            var status,
							statusText,
							responseHeaders,
							responses,
							xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if (callback && (isAbort || xhr.readyState === 4)) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }

                                    // If it's an abort
                                    if (isAbort) {
                                        // Abort it manually if needed
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if (xml && xml.documentElement /* #4958 */) {
                                            responses.xml = xml;
                                        }
                                        responses.text = xhr.responseText;

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };

                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if (!s.async || xhr.readyState === 4) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }




    var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
    // height animations
		["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
    // width animations
		["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
    // opacity animations
		["opacity"]
	],
	fxNow,
	requestAnimationFrame = window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame;

    jQuery.fn.extend({
        show: function (speed, easing, callback) {
            var elem, display;

            if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!jQuery._data(elem, "olddisplay") && display === "none") {
                            display = elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (display === "" && jQuery.css(elem, "display") === "none") {
                            jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        if (display === "" || display === "none") {
                            elem.style.display = jQuery._data(elem, "olddisplay") || "";
                        }
                    }
                }

                return this;
            }
        },

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    if (this[i].style) {
                        var display = jQuery.css(this[i], "display");

                        if (display !== "none" && !jQuery._data(this[i], "olddisplay")) {
                            jQuery._data(this[i], "olddisplay", display);
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    if (this[i].style) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function (fn, fn2, callback) {
            var bool = typeof fn === "boolean";

            if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

            } else if (fn == null || bool) {
                this.each(function () {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[state ? "show" : "hide"]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function (speed, to, easing, callback) {
            return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({ opacity: to }, speed, easing, callback);
        },

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete, [false]);
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend({}, prop);

            return this[optall.queue === false ? "each" : "queue"](function () {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if (optall.queue === false) {
                    jQuery._mark(this);
                }

                var opt = jQuery.extend({}, optall),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p,
				display, e,
				parts, start, end, unit;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for (p in prop) {

                    // property name normalization
                    name = jQuery.camelCase(p);
                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                    }

                    val = prop[name];

                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if (jQuery.isArray(val)) {
                        opt.animatedProperties[name] = val[1];
                        val = prop[name] = val[0];
                    } else {
                        opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';
                    }

                    if (val === "hide" && hidden || val === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (name === "height" || name === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if (jQuery.css(this, "display") === "inline" &&
							jQuery.css(this, "float") === "none") {
                            if (!jQuery.support.inlineBlockNeedsLayout) {
                                this.style.display = "inline-block";

                            } else {
                                display = defaultDisplay(this.nodeName);

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if (display === "inline") {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                for (p in prop) {
                    e = new jQuery.fx(this, opt, p);
                    val = prop[p];

                    if (rfxtypes.test(val)) {
                        e[val === "toggle" ? hidden ? "show" : "hide" : val]();

                    } else {
                        parts = rfxnum.exec(val);
                        start = e.cur();

                        if (parts) {
                            end = parseFloat(parts[2]);
                            unit = parts[3] || (jQuery.cssNumber[p] ? "" : "px");

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(this, p, (end || 1) + unit);
                                start = ((end || 1) / e.cur()) * start;
                                jQuery.style(this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                }

                // For JS strict compliance
                return true;
            });
        },

        stop: function (clearQueue, gotoEnd) {
            if (clearQueue) {
                this.queue([]);
            }

            this.each(function () {
                var timers = jQuery.timers,
				i = timers.length;
                // clear marker counters if we know they won't be
                if (!gotoEnd) {
                    jQuery._unmark(true, this);
                }
                while (i--) {
                    if (timers[i].elem === this) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if (!gotoEnd) {
                this.dequeue();
            }

            return this;
        }

    });

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(clearFxNow, 0);
        return (fxNow = jQuery.now());
    }

    function clearFxNow() {
        fxNow = undefined;
    }

    // Generate parameters to create a standard animation
    function genFx(type, num) {
        var obj = {};

        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
            obj[this] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
				jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function (noUnmark) {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }

                if (opt.queue !== false) {
                    jQuery.dequeue(this);
                } else if (noUnmark !== false) {
                    jQuery._unmark(this);
                }
            };

            return opt;
        },

        easing: {
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function (elem, options, prop) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            options.orig = options.orig || {};
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function () {
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
        },

        // Get the current size
        cur: function () {
            if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
            }

            var parsed,
			r = jQuery.css(this.elem, this.prop);
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN(parsed = parseFloat(r)) ? !r || r === "auto" ? 0 : r : parsed;
        },

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            var self = this,
			fx = jQuery.fx,
			raf;

            this.startTime = fxNow || createFxNow();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? "" : "px");
            this.now = this.start;
            this.pos = this.state = 0;

            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if (t() && jQuery.timers.push(t) && !timerId) {
                // Use requestAnimationFrame instead of setInterval if available
                if (requestAnimationFrame) {
                    timerId = true;
                    raf = function () {
                        // When timerId gets set to null at any point, this stops
                        if (timerId) {
                            requestAnimationFrame(raf);
                            fx.tick();
                        }
                    };
                    requestAnimationFrame(raf);
                } else {
                    timerId = setInterval(fx.tick, fx.interval);
                }
            }
        },

        // Simple 'show' function
        show: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any
            // flash of content
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

            // Start by showing the element
            jQuery(this.elem).show();
        },

        // Simple 'hide' function
        hide: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function (gotoEnd) {
            var t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options,
			i, n;

            if (gotoEnd || t >= options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[this.prop] = true;

                for (i in options.animatedProperties) {
                    if (options.animatedProperties[i] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {

                        jQuery.each(["", "X", "Y"], function (index, value) {
                            elem.style["overflow" + value] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if (options.hide) {
                        jQuery(elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (options.hide || options.show) {
                        for (var p in options.animatedProperties) {
                            jQuery.style(elem, p, options.orig[p]);
                        }
                    }

                    // Execute the complete function
                    options.complete.call(elem);
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if (options.duration == Infinity) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);
                    this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            for (var timers = jQuery.timers, i = 0; i < timers.length; ++i) {
                if (!timers[i]()) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function () {
            clearInterval(timerId);
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
            },

            _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                    fx.elem.style[fx.prop] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                } else {
                    fx.elem[fx.prop] = fx.now;
                }
            }
        }
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }

    // Try to restore the default display value of an element
    function defaultDisplay(nodeName) {

        if (!elemdisplay[nodeName]) {

            var body = document.body,
			elem = jQuery("<" + nodeName + ">").appendTo(body),
			display = elem.css("display");

            elem.remove();

            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if (display === "none" || display === "") {
                // No iframe to use yet, so create it
                if (!iframe) {
                    iframe = document.createElement("iframe");
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild(iframe);

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if (!iframeDoc || !iframe.createElement) {
                    iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                    iframeDoc.write((document.compatMode === "CSS1Compat" ? "<!doctype html>" : "") + "<html><body>");
                    iframeDoc.close();
                }

                elem = iframeDoc.createElement(nodeName);

                iframeDoc.body.appendChild(elem);

                display = jQuery.css(elem, "display");

                body.removeChild(iframe);
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return elemdisplay[nodeName];
    }




    var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = function (options) {
            var elem = this[0], box;

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            try {
                box = elem.getBoundingClientRect();
            } catch (e) { }

            var doc = elem.ownerDocument,
			docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if (!box || !jQuery.contains(docElem, elem)) {
                return box ? { top: box.top, left: box.left} : { top: 0, left: 0 };
            }

            var body = doc.body,
			win = getWindow(doc),
			clientTop = docElem.clientTop || body.clientTop || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top = box.top + scrollTop - clientTop,
			left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function (options) {
            var elem = this[0];

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            jQuery.offset.initialize();

            var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

            while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                    top += elem.offsetTop;
                    left += elem.offsetLeft;

                    if (jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                        top += parseFloat(computedStyle.borderTopWidth) || 0;
                        left += parseFloat(computedStyle.borderLeftWidth) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if (jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
            }

            if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {
        initialize: function () {
            var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat(jQuery.css(body, "marginTop")) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend(container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" });

            container.innerHTML = html;
            body.insertBefore(container, body.firstChild);
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: function (body) {
            var top = body.offsetTop,
			left = body.offsetLeft;

            jQuery.offset.initialize();

            if (jQuery.offset.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css(elem, "top"),
			curCSSLeft = jQuery.css(elem, "left"),
			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({
        position: function () {
            if (!this[0]) {
                return null;
            }

            var elem = this[0],

            // Get *real* offsetParent
		offsetParent = this.offsetParent(),

            // Get correct offsets
		offset = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0} : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], function (i, name) {
        var method = "scroll" + name;

        jQuery.fn[method] = function (val) {
            var elem, win;

            if (val === undefined) {
                elem = this[0];

                if (!elem) {
                    return null;
                }

                win = getWindow(elem);

                // Return the scroll offset
                /* original jQuery code - contradicts with "offset" method, where the document scroll top position is calculated differently
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
				jQuery.support.boxModel && win.document.documentElement[method] ||
					win.document.body[method] :
				elem[method];
                */
                
                return win 
                    ? 
                        win[ i ? "pageYOffset" : "pageXOffset" ] || jQuery.support.boxModel && win.document.documentElement[method] || win.document.body[method] 
                    :
                        elem[method];
            }

            // Set the scroll offset
            return this.each(function () {
                win = getWindow(this);

                if (win) {
                    win.scrollTo(
					!i ? val : jQuery(win).scrollLeft(),
					 i ? val : jQuery(win).scrollTop()
				);

                } else {
                    this[method] = val;
                }
            });
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
    }




    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = function () {
            var elem = this[0];
            return elem && elem.style ?
			parseFloat(jQuery.css(elem, type, "padding")) :
			null;
        };

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = function (margin) {
            var elem = this[0];
            return elem && elem.style ?
			parseFloat(jQuery.css(elem, type, margin ? "margin" : "border")) :
			null;
        };

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self[type](size.call(this, i, self[type]()));
                });
            }

            if (jQuery.isWindow(elem)) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement["client" + name];
                return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				elem.document.body["client" + name] || docElemProp;

                // Get document width or height
            } else if (elem.nodeType === 9) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

                // Get or set width or height on the element
            } else if (size === undefined) {
                var orig = jQuery.css(elem, type),
				ret = parseFloat(orig);

                return jQuery.isNaN(ret) ? orig : ret;

                // Set the width or height on the element (default to pixels if value is unitless)
            } else {
                return this.css(type, typeof size === "string" ? size : size + "px");
            }
        };

    });


    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;

    // @PATCH
    window.$.rebindWindowContext = function (win) {
        window = win;
        document = win.document;
        rootjQuery = $(document);
        return function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        }
    };
})(window);
jQuery.fn.center = function () {
    this.css("position","absolute");
    this.css("top", Math.max(0, (($(window).height() - this.outerHeight()) / 2) + 
                                                $(window).scrollTop()) + "px");
    this.css("left", Math.max(0, (($(window).width() - this.outerWidth()) / 2) + 
                                                $(window).scrollLeft()) + "px");
    return this;
};
/*
 * jQuery scrollintoview() plugin and :scrollable selector filter
 *
 * Version 1.8 (14 Jul 2011)
 * Requires jQuery 1.4 or newer
 *
 * Copyright (c) 2011 Robert Koritnik
 * Licensed under the terms of the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */
(function(f){var c={vertical:{x:false,y:true},horizontal:{x:true,y:false},both:{x:true,y:true},x:{x:true,y:false},y:{x:false,y:true}};var b={duration:"fast",direction:"both"};var e=/^(?:html)$/i;var g=function(k,j){j=j||(document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(k,null):k.currentStyle);var i=document.defaultView&&document.defaultView.getComputedStyle?true:false;var h={top:(parseFloat(i?j.borderTopWidth:f.css(k,"borderTopWidth"))||0),left:(parseFloat(i?j.borderLeftWidth:f.css(k,"borderLeftWidth"))||0),bottom:(parseFloat(i?j.borderBottomWidth:f.css(k,"borderBottomWidth"))||0),right:(parseFloat(i?j.borderRightWidth:f.css(k,"borderRightWidth"))||0)};return{top:h.top,left:h.left,bottom:h.bottom,right:h.right,vertical:h.top+h.bottom,horizontal:h.left+h.right}};var d=function(h){var j=f(window);var i=e.test(h[0].nodeName);return{border:i?{top:0,left:0,bottom:0,right:0}:g(h[0]),scroll:{top:(i?j:h).scrollTop(),left:(i?j:h).scrollLeft()},scrollbar:{right:i?0:h.innerWidth()-h[0].clientWidth,bottom:i?0:h.innerHeight()-h[0].clientHeight},rect:(function(){var k=h[0].getBoundingClientRect();return{top:i?0:k.top,left:i?0:k.left,bottom:i?h[0].clientHeight:k.bottom,right:i?h[0].clientWidth:k.right}})()}};f.fn.extend({scrollintoview:function(j){j=f.extend({},b,j);j.direction=c[typeof(j.direction)==="string"&&j.direction.toLowerCase()]||c.both;var n="";if(j.direction.x===true){n="horizontal"}if(j.direction.y===true){n=n?"both":"vertical"}var l=this.eq(0);var i=l.closest(":scrollable("+n+")");if(i.length>0){i=i.eq(0);var m={e:d(l),s:d(i)};var h={top:m.e.rect.top-(m.s.rect.top+m.s.border.top),bottom:m.s.rect.bottom-m.s.border.bottom-m.s.scrollbar.bottom-m.e.rect.bottom,left:m.e.rect.left-(m.s.rect.left+m.s.border.left),right:m.s.rect.right-m.s.border.right-m.s.scrollbar.right-m.e.rect.right};var k={};if(j.direction.y===true){if(h.top<0){k.scrollTop=m.s.scroll.top+h.top}else{if(h.top>0&&h.bottom<0){k.scrollTop=m.s.scroll.top+Math.min(h.top,-h.bottom)}}}if(j.direction.x===true){if(h.left<0){k.scrollLeft=m.s.scroll.left+h.left}else{if(h.left>0&&h.right<0){k.scrollLeft=m.s.scroll.left+Math.min(h.left,-h.right)}}}if(!f.isEmptyObject(k)){if(e.test(i[0].nodeName)){i=f("html,body")}i.animate(k,j.duration).eq(0).queue(function(o){f.isFunction(j.complete)&&j.complete.call(i[0]);o()})}else{f.isFunction(j.complete)&&j.complete.call(i[0])}}return this}});var a={auto:true,scroll:true,visible:false,hidden:false};f.extend(f.expr[":"],{scrollable:function(k,i,n,h){var m=c[typeof(n[3])==="string"&&n[3].toLowerCase()]||c.both;var l=(document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(k,null):k.currentStyle);var o={x:a[l.overflowX.toLowerCase()]||false,y:a[l.overflowY.toLowerCase()]||false,isRoot:e.test(k.nodeName)};if(!o.x&&!o.y&&!o.isRoot){return false}var j={height:{scroll:k.scrollHeight,client:k.clientHeight},width:{scroll:k.scrollWidth,client:k.clientWidth},scrollableX:function(){return(o.x||o.isRoot)&&this.width.scroll>this.width.client},scrollableY:function(){return(o.y||o.isRoot)&&this.height.scroll>this.height.client}};return m.y&&j.scrollableY()||m.x&&j.scrollableX()}})})(jQuery);;
if (typeof JooseX != "undefined" && !JooseX.SimpleRequest) {;
Class("JooseX.SimpleRequest", {

    have : {
    	req : null
	},

    
    methods: {
    	
        initialize: function () {
            if (window.XMLHttpRequest)
                this.req = new XMLHttpRequest()
            else
                this.req = new ActiveXObject("Microsoft.XMLHTTP")
        },
        
        
        getText: function (urlOrOptions, async, callback, scope) {
            var req = this.req
            
            var headers
            var url
            
            if (typeof urlOrOptions != 'string') {
                headers = urlOrOptions.headers
                url = urlOrOptions.url
                async = async || urlOrOptions.async
                callback = callback || urlOrOptions.callback
                scope = scope || urlOrOptions.scope
            } else url = urlOrOptions
            
            req.open('GET', url, async || false)
            
            if (headers) Joose.O.eachOwn(headers, function (value, name) {
                req.setRequestHeader(name, value)
            })
            
            try {
                req.onreadystatechange = function (event) {  
                    if (async && req.readyState == 4) {  
                        // status is set to 0 for failed cross-domain requests..
                        // but if the response text presents - we treat this as successfull request
                        // see https://www.assembla.com/spaces/bryntum/tickets/590
                        if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                            callback.call(scope || this, true, req.responseText)
                        else 
                            callback.call(scope || this, false, "File not found: " + url)
                    }  
                };  
                req.send(null)
            } catch (e) {
                throw "File not found: " + url
            }
            
            if (!async)
                if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                    return req.responseText; 
                else 
                    throw "File not found: " + url
            
            return null
        }
    }
})
;
};
/**
@class Siesta.Test.Action.Role.HasTarget

This is a mixin, allowing the action to have "target" attribute, also aliased as "el". Target will be also passed
further on chain, as the argument after "next":

    t.chain(
        {
            action      : 'click',
            target      : buttonComp        
        },
        function (next, buttonComp) {
            // target is available as 2nd argument
        
            next()
        },
        {
            action      : 'click',
            target      : '>>button',
            offset      : [10, 20]
        },
        function (next, buttonComp) {
            // various queries will be resolved down to Ext.Component instance or DOM element
        
            next()
        },
        ...
    )
    
If needed, this behavior can be disabled with {@link #passTargetToNext} option.

*/
Role('Siesta.Test.Action.Role.HasTarget', {
    
        
    has : {
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} [target=undefined] 
         * 
         * A target for action. See {@link Siesta.Test.ActionTarget} for various values that can be provided.
         * 
         * **Important.** If the function is provided for this config, it will be called and returning value used as actual target. 
         * This is useful, since sometimes target for the action depends from the previous step and 
         * is not yet available during `t.chain` call. 
         * 
         * For example, you want to click on the button which opens a window and then click on something in the window. Compare:
         * 

    t.chain(
        // clicking on button opens the window
        {
            action      : 'click',
            target      : buttonComp        
        },
        // FRAGILE: `windowComp` could not be rendered yet - `buttonComp` is not yet clicked!
        {
            action      : 'click',
            target      : windowComp.el.down('.clickArea')  
        }
        
        // MORE ROBUST: taking the "el" right before this action starts
        {
            action      : 'click',
            target      : function () {
                return windowComp.el.down('.clickArea')
            } 
        }
    )
         * 
         * Target will be available in the next step as the 2nd argument. See {@link Siesta.Test.Action.Role.HasTarget}
         * 
         * This config option can also be provided as "el" 
         */
        target              : { required : false },

        normalizedTarget    : null,
        cachedTarget        : null,
        
        /**
         * @cfg {Object} el 
         * 
         * An alias for {@link #target} 
         */
        
        /**
         * @cfg {Boolean} passTargetToNext Whether to pass the target further on chain as the first argument
         */
        passTargetToNext    : true,


        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        options             : null,

        /**
         * @cfg {Array} offset
         *
         * An offset in X, Y coordinates from the targeted element. The offset can be expressed in 3 different ways.
         * Integers             : [10, 20]       // offset 10px from left, 20px from top
         * Percent              : ["10%", 20]    // offset 10% from left, 20px from top
         * Percent + offset     : ["100%-2", 20] // offset -2px from right, 20px from top
         */
        offset              : null
    },
    
    
    after : {
        initialize : function () {
            if (!this.passTargetToNext) return
            
            var me          = this
            var prevNext    = this.next

//            // Needs to be 'resolved' at action instantiate time since the action may cause the selector not to be found 
//            // e.g. unchecking a checkbox
//            var realTarget  = me.test.normalizeActionTarget(me.getTarget());

            this.next       = function () {
                prevNext.call(this, me.normalizedTarget);
            }
        }
    },

    
    methods : {
        
        BUILD : function (config) {
            // allow "el" as synonym for "target"
            if (config.el && !config.target) config.target = config.el
            
            return config
        },
        

        getTarget : function () {
            if (this.cachedTarget) return this.cachedTarget
            
            var test        = this.test;
            var target      = this.target || test.currentPosition;

            if (test.typeOf(target) === 'Function') target = target.call(test, this);
            
            this.normalizedTarget   = test.normalizeActionTarget(target, true)

            return this.cachedTarget   = target
        }
    }
});
;
/**

@class Siesta.Test.Action.Swipe
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "swipe" shortcut:

    t.chain(
        {
            action      : 'swipe',
            target      : someDOMElement
        },
        // or
        {
            swipe       : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#swipe swipe} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Swipe', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod          : 'swipe',
         
        /**
         * @cfg {String} direction Either 'left', 'right', 'up' or 'down'
         */
        direction                  : 'left'
    },

    
    methods : {
        
        process : function () {
            this.test.swipe(this.getTarget(), this.direction, this.next)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('swipe', Siesta.Test.Action.Swipe)
;
/**

@class Siesta.Test.Action.LongPress
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "click" shortcut:

    t.chain(
        {
            action      : 'longpress',
            target      : someDOMElement
        },
        // or
        {
            longpress   : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#longpress longpress} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.LongPress', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'longpress'
    },

    
    methods : {
        
        process : function () {
            this.test.longpress(this.getTarget(), this.next, null, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('longpress', Siesta.Test.Action.LongPress)
;
/**

@class Siesta.Test.Action.Tap
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "tap" shortcut:

    t.chain(
        {
            action      : 'tap',
            target      : someDOMElement
        },
        // or
        {
            tap         : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.Browser#tap tap} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Tap', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'tap'
    },

    
    methods : {
        
        process : function () {
            this.test.tap(this.getTarget(), this.next)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('tap', Siesta.Test.Action.Tap);
/**

@class Siesta.Test.Action.DoubleTap
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#doubleClick double tap} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "doubletap" or "doubleTap" shortcuts:

    t.chain(
        {
            action      : 'doubletap',
            target      : someDOMElement
        },
        // or
        {
            doubletap   : someDOMElement,
            offset      : [20,20] // click 20px from the left/top corner of the element
        }
    )


*/
Class('Siesta.Test.Action.DoubleTap', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'doubleTap'
    },

    
    methods : {
        
        process : function () {
            this.test.doubleTap(this.getTarget(), this.next, null, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('doubletap', Siesta.Test.Action.DoubleTap)
;
/**

@class Siesta.Test.Action.MouseDown
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "mouseDown" shortcut:

    t.chain(
        {
            action      : 'mouseDown',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            mousedown   : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#MouseDown MouseDown} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MouseDown', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'mouseDown'
    },

    
    methods : {
        
        process : function () {
            // This method is synchronous
            this.test.mouseDown(this.getTarget(), this.options, this.offset);

            setTimeout(this.next, 100);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('mouseDown', Siesta.Test.Action.MouseDown)
Siesta.Test.ActionRegistry().registerAction('fingerDown', Siesta.Test.Action.MouseDown)
;
/**

@class Siesta.Test.Action.MouseUp
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "mouseUp" shortcut:

    t.chain(
        {
            action      : 'mouseUp',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            mouseup     : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#mouseUp mouseUp} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MouseUp', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'mouseUp'
    },

    
    methods : {
        
        process : function () {
            // This method is synchronous
            this.test.mouseUp(this.getTarget(), this.options, this.offset);

            setTimeout(this.next, 100);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('mouseUp', Siesta.Test.Action.MouseUp)
Siesta.Test.ActionRegistry().registerAction('fingerUp', Siesta.Test.Action.MouseUp)
;
/**

@class Siesta.Test.Action.Click
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "click" shortcut:

    t.chain(
        {
            action      : 'click',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            click       : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#click click} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Click', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'click'
    },

    methods : {
        
        process : function () {
            this.test.click(this.getTarget(), this.next, null, this.options, this.offset);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('click', Siesta.Test.Action.Click);
;
/**

@class Siesta.Test.Action.DoubleClick
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#doubleClick double click} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "doubleclick" or "doubleClick" shortcuts:

    t.chain(
        {
            action      : 'doubleclick',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            doubleclick : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
        
    )


*/
Class('Siesta.Test.Action.DoubleClick', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'doubleClick'
    },

    
    methods : {
        
        process : function () {
            this.test.doubleClick(this.getTarget(), this.next, null, this.options, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('doubleclick', Siesta.Test.Action.DoubleClick)
Siesta.Test.ActionRegistry().registerAction('dblclick', Siesta.Test.Action.DoubleClick)
;
/**

@class Siesta.Test.Action.RightClick
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#rightClick right click} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "rightclick" or "rightClick" shortcuts:

    t.chain(
        {
            action      : 'rightclick',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            rightclick  : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )


*/
Class('Siesta.Test.Action.RightClick', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'rightClick'
    },

    
    methods : {
        
        process : function () {
            this.test.rightClick(this.getTarget(), this.next, null, this.options, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('rightclick', Siesta.Test.Action.RightClick)
Siesta.Test.ActionRegistry().registerAction('contextmenu', Siesta.Test.Action.RightClick)
;
/**

@class Siesta.Test.Action.Type
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will {@link Siesta.Test.Browser#type type} the provided {@link #text} into the provided {@link #target}. For more
 information about how you can type special characters and hold special keys such as ALT or SHIFT, please see the docs for the {@link Siesta.Test.Browser#type type} method.
 The target can be a DOM element or, in case you are using the Siesta.Test.ExtJS class - an instance of a Ext.Component (field component for example).

This action can be included in a `t.chain` call with the "type" shortcut. **Note** that unlike other actions, in its compact
form the value of the "type" property should contain the text to type, not the target of action.

    t.chain(
         {
             // "type" into the currently focused DOM element
             type        : 'Some text[ENTER]'
         },
         // or
         {
             action      : 'type',
             target      : someDOMElement,
             text        : 'Some text',
             options     : { shiftKey : true }
         },
         // or
         {
            // NOTE: "type" contains text to type, not the action target as in other actions
            type        : 'Some text',
            target      : someDOMElement
         }
    );

*/
Class('Siesta.Test.Action.Type', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'type',

        /**
         * @cfg {String} text
         *
         * The text to type into the target
         */
        text                : '',

        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        options             : null
    },


    methods : {

        process : function () {
            // By default use the current focused element as target
            this.target = this.target || this.test.activeElement();

            // additional "getTarget" to allow functions as "target" value
            this.test.type(this.getTarget(), this.text, this.next, null, this.options);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('type', Siesta.Test.Action.Type);
/**

@class Siesta.Test.Action.Drag
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with the "drag" shortcut:

    t.chain(
        {
            action      : 'drag',
            target      : someDOMElementOrArray,
            to          : someDOMElementOrArray
        },
        {
            action      : 'drag',
            target      : someDOMElementOrArray,
            by          : [ 10, 10 ]
        },
        // or
        {
            drag        : someDOMElementOrArray,
            to          : someDOMElementOrArray
        }
    )

This action will perform a {@link Siesta.Test.Browser#dragTo dragTo} or {@link Siesta.Test.Browser#dragBy dragBy} actions on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Drag', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
    
    has : {
        requiredTestMethod  : 'dragTo',
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} target
         * 
         * The initial point of dragging operation. Can be provided as Siesta.Test.ActionTarget or the function returning it. 
         * Will also be passed further to the next step.
         */
         
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} source
         * 
         * Alias for {@link #target}. This may sound confusing, but "target" of "drag" action is its "source" in the same time.   
         */
         
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to 
         * 
         * The target point of dragging operation. Can be provided as the DOM element, the array with screen coordinates: `[ x, y ]`, or the function
         * returning one of those.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,

        /**
         * @cfg {Array} fromOffset
         *
         * An offset in X, Y coordinates from the source element. Can be also specified as `offset` config.
         */
        fromOffset          : null,

        /**
         * @cfg {Array} toOffset
         *
         * An offset in X, Y coordinates from the targeted element
         */
        toOffset            : null,

        /**
         * @cfg {Array/Function} by 
         * 
         * The delta for dragging operation. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,
        
        
        /**
         * @cfg {Boolean} dragOnly
         * 
         * True to skip the mouseup and not finish the drop operation (one can start another drag operation, emulating the pause during drag-n-drop).
         */
        dragOnly            : false
    },

    
    override : {
        BUILD : function (config) {
            // allow "source" as synonym for "target"
            // sounds weird, but "target" in action domain means source point for dragging 
            if (config.source && !config.target) config.target = config.source
            
            return this.SUPER(config)
        }
    },
    
    
    methods : {
        
        initialize : function () {
            this.SUPER()
            
            if (!this.to && !this.by)   throw 'Either "to" or "by" configuration option is required for "drag" step' 
            if (this.to && this.by)     throw 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
        },
        
        
        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },
        
        
        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },

        
        process : function () {
            var next                = this.next;
            var test                = this.test
            var target              = this.getTarget();
            var normalizedTarget    = test.normalizeActionTarget(target, true)
            
            if (this.to) {
                test.dragTo(target, this.getTo(), function() { next(normalizedTarget || test.normalizeActionTarget(target)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset, this.toOffset)
            } else {
                test.dragBy(target, this.getBy(), function() { next(normalizedTarget || test.normalizeActionTarget(target)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset)
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('drag', Siesta.Test.Action.Drag);
/**

@class Siesta.Test.Action.MoveCursor
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "moveCursor" shortcut:

    t.chain(
        {
            action      : 'moveCursor',
            to          : 'div.someClass'   // A div with class='someClass'
        },
        {
            action      : 'moveCursor',
            to          : [400, 300]        // Target pixel coordinates
        },
        {
            action      : 'moveCursor',
            by          : [20, 10]  // 20 px right, 10 px down
        }
    )

This action will perform a {@link Siesta.Test.Simulate.Mouse#moveCursorTo moveCursorTo} to the provided 'to' destination or the relative 'by' offset.

*/
Class('Siesta.Test.Action.MoveCursor', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        requiredTestMethod  : 'moveMouseTo',
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to 
         * 
         * The target point the cursor should be moved to. Can be provided as a DOM element, an array with client coordinates: `[ x, y ]`, or a function
         * returning one of those. You can additionally pass an 'offset' array to click at a point relative to the XY position of the target.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,
        
        
        /**
         * @cfg {Array/Function} by 
         * 
         * The delta for moving cursor. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,

        /**
         * @cfg {Array} offset
         *
         * An offset in X, Y coordinates from the targeted element (only applicable when using the 'to' target option.
         */
        offset : null
    },

    
    methods : {
        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },
        
        
        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },

        process : function () {
            var test = this.test;
            var next = this.next;

            if (this.to) {
                var to                  = this.getTo()
                
                var normalizedTarget    = test.normalizeActionTarget(to, false)
                
                test.moveMouseTo(to, function() { next(normalizedTarget); }, null, this.offset)
            } else {
                var by                  = this.getBy()
                var currentXY           = test.currentPosition
                
                var normalizedTarget    = test.normalizeActionTarget([ currentXY[ 0 ] + by[ 0 ], currentXY[ 1 ] + by[ 1 ] ]);

                test.moveMouseBy(by, function() { next(normalizedTarget); })
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveCursor', Siesta.Test.Action.MoveCursor)
Siesta.Test.ActionRegistry().registerAction('moveMouse', Siesta.Test.Action.MoveCursor)
Siesta.Test.ActionRegistry().registerAction('moveFinger', Siesta.Test.Action.MoveCursor)
;
/**

@class Siesta.Test.Action.MoveCursorTo
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "moveCursorTo" shortcut:

    t.chain(
        {
            action          : 'moveCursorTo',
            target          : someDOMElement
        },
        // or
        {
            moveCursorTo    : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.Simulate.Mouse#moveCursorTo moveCursorTo} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.MoveCursorTo', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'moveMouseTo',
        target              : { required : true }
    },

    
    methods : {
        
        process : function () {
            this.test.moveMouseTo(this.getTarget(), this.next, null, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveCursorTo', Siesta.Test.Action.MoveCursorTo)
Siesta.Test.ActionRegistry().registerAction('moveMouseTo', Siesta.Test.Action.MoveCursorTo)
Siesta.Test.ActionRegistry().registerAction('moveFingerTo', Siesta.Test.Action.MoveCursorTo)
;
/**
@class Siesta.Test.Simulate.Mouse

This is a mixin, providing the mouse events simulation functionality.
*/

//        Copyright (c) 2011 John Resig, http://jquery.com/

//        Permission is hereby granted, free of charge, to any person obtaining
//        a copy of this software and associated documentation files (the
//        "Software"), to deal in the Software without restriction, including
//        without limitation the rights to use, copy, modify, merge, publish,
//        distribute, sublicense, and/or sell copies of the Software, and to
//        permit persons to whom the Software is furnished to do so, subject to
//        the following conditions:

//        The above copyright notice and this permission notice shall be
//        included in all copies or substantial portions of the Software.

//        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//        LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//        OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
//        WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Role('Siesta.Test.Simulate.Mouse', {
    
    requires        : [ 'simulateEvent', 'getSimulateEventsWith', 'normalizeElement', 'isTextInput' ],    
    
    has: {
        /**
         *  @cfg {Int} dragDelay The delay between individual drag events (mousemove)
         */
        dragDelay               : 25,

        /**
         *  @cfg {Boolean} moveCursorBetweenPoints True to move the mouse cursor between for example two clicks on separate elements (for better visual experience)
         */
        moveCursorBetweenPoints : true,

        /**
         *  @cfg {Int} dragPrecision Defines how precisely to follow the path between two points when simulating a drag. 2 indicates every other point will be used.
                                     (low value = slow dragging, high value = fast dragging)
        */
        dragPrecision           : $.browser.msie ? 10 : 5,

        autoScrollElementsIntoView : true,

        overEls                 : Joose.I.Array
    },
    
    
    after : {
        cleanup : function () {
            this.overEls        = null
        }
    },


    methods: {
        // private
        createMouseEvent: function (type, options, el) {
            var event;
            var global      = this.global
            
            options         = $.extend({
                bubbles     : type !== 'mouseenter' && type !== 'mouseleave', 
                cancelable  : type != "mousemove", 
                view        : global, 
                detail      : 0,

                screenX     : 0,
                screenY     : 0,

                ctrlKey     : false,
                altKey      : false,
                shiftKey    : false,
                metaKey     : false,

                button          : 0,
                relatedTarget   : undefined

            }, options);

            if (!("clientX" in options) || !("clientY" in options)) {
                var center  = this.findCenter(el);

                options     = $.extend({
                    clientX: center[0],
                    clientY: center[1]
                }, options);
            }

            // Not supported in IE
            if ("screenX" in window) {
                options = $.extend(options, {
                    screenX: global.screenX + options.clientX,
                    screenY: global.screenY + options.clientY
                });
            }

            var doc         = el.ownerDocument;

            // use W3C standard when available and allowed by "simulateEventsWith" option
            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                event       = doc.createEvent("MouseEvents");

                event.initMouseEvent(
                    type, options.bubbles, options.cancelable, options.view, options.detail,
                    options.screenX, options.screenY, options.clientX, options.clientY,
                    options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
                    options.button, options.relatedTarget || doc.body.parentNode
                );
                
                
            } else if (doc.createEventObject) {
                event       = doc.createEventObject();

                $.extend(event, options);

                event.button = { 0: 1, 1: 4, 2: 2 }[ event.button ] || event.button;
            }

            // Mouse over is used in some certain edge cases which interfer with this tracking
            if (type !== 'mouseover' && type !== 'mouseout') {
                var elWindow    = doc.defaultView || doc.parentWindow;
                var cursorX     = options.clientX;
                var cursorY     = options.clientY;

                // Potentially we're interacting with an element inside a nested frame, which means the coordinates are local to that frame
                if (elWindow !== global) {
                    var offsets = this.$(elWindow.frameElement).offset();
                    
                    cursorX     += offsets.left;
                    cursorY     += offsets.top;
                }
                
                if (!options.doNotUpdateCurrentPosition) {
                    this.currentPosition[ 0 ]   = cursorX;
                    this.currentPosition[ 1 ]   = cursorY;
                }
            }

            return event;
        },
        
        /**
        * This method will simulate a mouse move to an xy-coordinate or an element (the center of it)
        * 
        * @param {Siesta.Test.ActionTarget} target Target point to move the mouse to.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveMouseTo : function(target, callback, scope, offset) {
            if (!target) {
                throw 'Trying to call moveMouseTo without a target';
            }

            var context = this.getNormalizedTopElementInfo(target, true, 'moveMouseTo', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.moveMouseTo(target, callback, scope, offset);
                }, this);

                return;
            }

            // TODO this method should also accept an options object, so user can for example hold CTRL key during mouse operation
//            options.clientX = options.clientX != null ? options.clientX : data.xy[0];
//            options.clientY = options.clientY != null ? options.clientY : data.xy[1];

            this.moveMouse(this.currentPosition, context.globalXY, callback, scope);
        },

        /**
        * This method will simulate a mouse move from current position relative by the x and y distances provided.
        * 
        * @param {Array} delta The array from 2 elements: [ dx, dy ], indicating the offset. 
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        */
        moveMouseBy : function(delta, callback, scope) {
            if (!delta) {
                throw 'Trying to call moveMouseBy without relative distances';
            }

            var targetXY = [ this.currentPosition[0] + delta[0], this.currentPosition[1] + delta[1] ];

            this.moveMouseTo(targetXY, callback, scope);
        },

        /**
        * Alias for moveMouseTo, this method will simulate a mouse move to an xy-coordinate or an element (the center of it)
        * @param {Siesta.Test.ActionTarget} target Target point to move the mouse to.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveCursorTo : function(target, callback, scope, offset) {
            this.moveMouseTo.apply(this, arguments);
        },

        /**
        * This method will simulate a mouse move by an x a y delta amount
        * @param {Array} delta The delta x and y distance to move, e.g. [20, 20] for 20px down/right, or [0, 10] for just 10px down.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        */
        moveMouseBy : function(delta, callback, scope) {
            this.moveCursorBy.apply(this, arguments);
        },

        /**
         * This method will simulate a mouse move by an x a y delta amount
         * @param {Array} delta The delta x and y distance to move, e.g. [20, 20] for 20px down/right, or [0, 10] for just 10px down.
         * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         */
        moveCursorBy : function(delta, callback, scope) {
            // Normalize target
            var target = [this.currentPosition[0] + delta[0], this.currentPosition[1] + delta[1]];

            this.moveMouse(this.currentPosition, target, callback, scope);
        },

        // private
        moveMouse : function(xy, xy2, callback, scope, precision, async, options) {
            var document    = this.global.document,
                me          = this,
                overEls     = this.overEls,
                // Remember last visited element, since a previous action may have changed the DOM
                // which possibly should trigger a mouseout event
                lastOverEl  = overEls[ overEls.length - 1 ];
                
            try {
                lastOverEl && lastOverEl.tagName
            } catch (e) {
                // exception here probably means the "lastOverEl" is from freed context (unloaded page)
                // access to such elements throws exceptions in IE
                lastOverEl      = null
                this.overEls    = overEls = []
            }
            
            precision       = precision || me.dragPrecision;
            options         = options || {};

            var path        = this.getPathBetweenPoints(xy, xy2);

            var supports    = Siesta.Harness.Browser.FeatureSupport().supports

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : async !== false ? this.dragDelay : 0,
                callbackDelay   : async !== false ? 50 : 0,
                
                observeTest     : this,
                
                processor       : function (data, index) {
                    var fromIndex = data.sourceIndex,
                        toIndex = data.targetIndex;

                    for (var j = fromIndex; j <= toIndex; j++) {
                        var point       = path[j].slice();
                        var targetEl    = me.elementFromPoint(point[0], point[1]);

                        if (targetEl.ownerDocument !== document) {
                            var win     = targetEl.ownerDocument.defaultView || targetEl.ownerDocument.parentWindow;
                            
                            var offsetsToTopWindow = me.$(win.frameElement).offset();

                            point[0]    -= offsetsToTopWindow.left,
                            point[1]    -= offsetsToTopWindow.top;
                        }

                        if (targetEl !== lastOverEl) {
                            for (var i = overEls.length - 1; i >= 0; i--) {
                                var el = overEls[i];
                                if (el !== targetEl && me.$(el).has(targetEl).length === 0) {
                                    if (supports.mouseEnterLeave) {
                                        me.simulateEvent(el, "mouseleave", $.extend({ clientX: point[0], clientY: point[1], relatedTarget : targetEl}, options));
                                    }
                                    overEls.splice(i, 1);
                                }
                            }

                            if (lastOverEl) {
                                me.simulateEvent(lastOverEl, "mouseout", $.extend({ clientX: point[0], clientY: point[1], relatedTarget : targetEl}, options));
                            }
                            if (jQuery.inArray(targetEl, overEls) < 0) {
                                if (supports.mouseEnterLeave) {
                                    me.simulateEvent(targetEl, "mouseenter", $.extend({ clientX: point[0], clientY: point[1], relatedTarget : lastOverEl}, options));
                                }
                                overEls.push(targetEl);
                            }

                            me.simulateEvent(targetEl, "mouseover", $.extend({ clientX: point[0], clientY: point[1], relatedTarget : lastOverEl}, options));
                            lastOverEl = targetEl;
                        }
                     
                        me.simulateEvent(targetEl, "mousemove", $.extend({ clientX: point[0], clientY: point[1]}, options), j < toIndex);
                    }
                }
            });
            
            for (var i = 0, l = path.length; i < l; i += precision) {
                queue.addStep({
                    sourceIndex       : i,
                    targetIndex       : Math.min(i + precision - 1, path.length - 1)
                });
            }

            var async       = this.beginAsync()
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },
        
        
        focusOnClick : function (el) {
            // if we've clicked text input element just do regular focus
            if (this.isTextInput(el)) {
                this.focus(el)
                return
            }
            
            var doc         = el.ownerDocument
            var win         = doc.defaultView || doc.parentWindow
            var body        = doc.body
            
            // otherwise focus the nearest parent with non-null `tabIndex` attribute
            // as an edge case an "<html> element can be clicked
            while (el && el != body && el != doc) {
                // don't look up the parent nodes when clicked on the on with "unselectable" attribute
                // and do not focus the body
                if (el.getAttribute('unselectable') == 'on') return
                
                var userSelect
                
                if (win.getComputedStyle) {
                    var computedStyle   = win.getComputedStyle(el)
                    userSelect          = computedStyle.msUserSelect || computedStyle.webkitUserSelect || computedStyle.MozUserFocus
                } else
                    // if there's no `getComputedStyle` we are in IE8 probably, using `currentStyle`
                    userSelect          = el.currentStyle.msUserSelect
                
                if (el.getAttribute('tabIndex') != null && userSelect != 'none') {
                    this.focus(el)
                    return
                }
                
                el          = el.parentNode
            }
            
            // focus body as the last resort to trigger the "blur" event on the currently focused element
            this.focus(body)
        },
        
        
        
        genericMouseClick : function (el, callback, scope, options, method, offset) {
            if (jQuery.isFunction(el)) {
                scope       = callback;
                callback    = el; 
                el          = null;
            }

            el              = el || this.currentPosition

            var normalized  = this.normalizeElement(el, true);

            if (!normalized) {
                this.waitForTarget(el, function() {
                    this.genericMouseClick(el, callback, scope, options, method, offset);
                }, this);

                return;
            }

            options         = options || {};

            if (!this.valueIsArray(el) && this.autoScrollElementsIntoView) {
                this.scrollTargetIntoView(normalized, offset)
            }

            var data        = this.getNormalizedTopElementInfo(el, false, method, offset);
            
            if (!data) {
                // No point in continuing
                callback && callback.call(scope || this);
                return;
            }
            
            options.clientX = options.clientX != null ? options.clientX : data.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : data.localXY[1];

            // the asynchronous case
            if (this.moveCursorBetweenPoints && callback) {
                this.syncCursor(data.globalXY, this[ method ], [ data, callback, scope, options ]);
            } else {
                this[ method ](data, callback, scope, options);
            }
            
        },

        /**
         * This method will simulate a mouse click in the center of the specified DOM/Ext element.
         * 
         * Note, that it will first calculate the centeral point of the specified element and then 
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.  
         * 
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mouseup`, `click`
         * 
         * Example:
         * 
         *      t.click(t.getFirstRow(grid), function () { ... })
         * 
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         * 
         *      t.click(function () { ... })
         *   
         * @param {Siesta.Test.ActionTarget} (optional) el One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element 
         * @param {Function} callback (optional) A function to call after click.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any options to use for the simulated DOM event
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        click: function (el, callback, scope, options, offset) {
            this.genericMouseClick(el, callback, scope, options, 'simulateMouseClick', offset)
        },

        
        /**
         * This method will simulate a mouse right click in the center of the specified DOM/Ext element.
         * 
         * Note, that it will first calculate the centeral point of the specified element and then 
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.  
         * 
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mouseup`, `contextmenu`
         * 
         * Example:
         * 
         *      t.click(t.getFirstRow(grid), function () { ... })
         * 
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         * 
         *      t.click(function () { ... })
         *   
         * @param {Siesta.Test.ActionTarget} (optional) el One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element 
         * @param {Function} callback (optional) A function to call after click.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any options to use for the simulated DOM event
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        rightClick: function (el, callback, scope, options, offset) {
            this.genericMouseClick(el, callback, scope, options, 'simulateRightClick', offset)
        },

        
        /**
         * This method will simulate a mouse double click in the center of the specified DOM/Ext element.
         * 
         * Note, that it will first calculate the centeral point of the specified element and then 
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.  
         * 
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mouseup`, `click`, `mousedown`, `mouseup`, `click`, `dblclick`
         * 
         * Example:
         * 
         *      t.click(t.getFirstRow(grid), function () { ... })
         * 
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         * 
         *      t.click(function () { ... })
         *   
         * @param {Siesta.Test.ActionTarget} (optional) el One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element 
         * @param {Function} callback (optional) A function to call after click.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any options to use for the simulated DOM event
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        doubleClick: function (el, callback, scope, options, offset) {
            this.genericMouseClick(el, callback, scope, options, 'simulateDoubleClick', offset)
        },

        /**
         * This method will simulate a mousedown event in the center of the specified DOM element.
         * 
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        mouseDown: function (el, options, offset) {
            var info        = this.getNormalizedTopElementInfo(el, false, 'mouseDown', offset);

            if (!info) return;
            
            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];
            
            el              = el || info.el;

            this.simulateEvent(el, 'mousedown', options);
        },

         /**
         * This method will simulate a mousedown event in the center of the specified DOM element.
         * 
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        mouseUp: function (el, options, offset) {
            var info        = this.getNormalizedTopElementInfo(el, false, 'mouseUp', offset);

            if (!info) return;
            
            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];
            
            el              = el || info.el;

            this.simulateEvent(el, 'mouseup', options);
        },

        /**
         * This method will simulate a mouseover event in the center of the specified DOM element.
         * 
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         */
        mouseOver: function (el, options) {
            var info        = this.getNormalizedTopElementInfo(el);

            if (!info) return;
            
            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            this.simulateEvent(el, 'mouseover', options);
        },

        /**
         * This method will simulate a mouseout event in the center of the specified DOM element.
         * 
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         */        
        mouseOut: function (el, options) {
            var info        = this.getNormalizedTopElementInfo(el);

            if (!info) return;
            
            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            this.simulateEvent(el, 'mouseout', options);
        },

        
        processMouseClickSteps : function (clickInfo, callback, scope, options, steps) {
            var me          = this
            
            var x           = clickInfo.globalXY[ 0 ]
            var y           = clickInfo.globalXY[ 1 ]
            
            // re-evaluate the target el - it might have changed while we were syncing the cursor position
            var target      = me.elementFromPoint(x, y, false, clickInfo.el)
            
            var targetHasChanged    = false
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 10 : 0,
                callbackDelay   : me.afterActionDelay,
                
                observeTest     : this,
                
                processor       : function (data) {
                    var el          = me.elementFromPoint(x, y, false, target)
                    
                    if (data.reCaptureTheTarget) { target = el; targetHasChanged = false }
                    
                    if (el != target) targetHasChanged = true
                    
                    if (targetHasChanged && data.cancelIfTargetChanged) return
                    
                    me.simulateEvent(el, data.event, options, data.suppressLog);
                    
                    if (data.focus) me.focusOnClick(el)
                }
            })
            
            Joose.A.each(steps, function (step) { queue.addStep(step) })
            
            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);

                me.processCallbackFromTest(callback, null, scope || me)
            })
        },
        

        // private
        simulateMouseClick: function (clickInfo, callback, scope, options) {
            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", suppressLog : true, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "click", suppressLog : false, cancelIfTargetChanged : true }
                ]
            )
        },

        // private
        simulateRightClick: function (clickInfo, callback, scope, options) {
            options         = options || {};
            options.button  = 2;
            
            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", suppressLog : false, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "contextmenu", suppressLog : false }
                ]
            )
        },
        
        // private
        simulateDoubleClick: function (clickInfo, callback, scope, options) {
            this.processMouseClickSteps(
                clickInfo,
                callback,
                scope,
                options,
                [
                    { event : "mousedown", suppressLog : false, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "click", suppressLog : false, cancelIfTargetChanged : true },
                    { event : "mousedown", suppressLog : false, reCaptureTheTarget : true, focus : true },
                    { event : "mouseup", suppressLog : true },
                    { event : "click", suppressLog : true, cancelIfTargetChanged : true },
                    { event : "dblclick", suppressLog : false, cancelIfTargetChanged : true }
                ]
            )
        }, 

        // private
        syncCursor : function(toXY, callback, args) {
            var me          = this
            var fromXY      = this.currentPosition;
            
            if (toXY[0] !== fromXY[0] || toXY[1] !== fromXY[1]) {

                this.moveMouse(fromXY, toXY, function() { 
                    callback && callback.apply(me, args);
                });
            } else 
                // already aligned
                callback && callback.apply(this, args);
        },


        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mousemove` (along the mouse path), `mouseup`
         * 
         * @deprecated This method is deprecated in favor of {@link #dragTo} and {@link #dragBy} methods
         * @param {Siesta.Test.ActionTarget} source Either an element, or [x,y] as the drag starting point
         * @param {Siesta.Test.ActionTarget} target (optional) Either an element, or [x,y] as the drag end point
         * @param {Array} delta (optional) the amount to drag from the source coordinate, expressed as [x,y]. [50, 10] will drag 50px to the right and 10px down.
         * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         */
        drag: function (source, target, delta, callback, scope, options) {
            if (!source) {
                throw 'No drag source defined';
            }

            if (target) {
                this.dragTo(source, target, callback, scope, options);
            } else {
                this.dragBy(source, delta, callback, scope, options);
            }
        },

        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mousemove` (along the mouse path), `mouseup`
         *   
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value for the drag starting point
         * @param {Siesta.Test.ActionTarget} target {@link Siesta.Test.ActionTarget} value for the drag end point
         * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} sourceOffset (optional) An X,Y offset relative to the source. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @param {Array} targetOffset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        dragTo : function (source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset) {
            if (!target) throw 'No drag target defined';
            
            source              = source || this.currentPosition;
            options             = options || {};
            
            if (this.typeOf(source) != 'Array') {
                var normalized  = this.normalizeElement(source, true, sourceOffset)
                
                if (normalized) this.scrollTargetIntoView(normalized, sourceOffset)
            }

            // normalize source and target
            var sourceContext   = this.getNormalizedTopElementInfo(source, true, 'dragTo: Source', sourceOffset);
            var targetContext   = this.getNormalizedTopElementInfo(target, false, 'dragTo: Target', targetOffset);
            
            if (!sourceContext) {
                // No point in continuing
                this.waitForTarget(source, function() {
                    this.dragTo(source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset);
                }, this);

                return;
            }

            if (!targetContext) {
                this.processCallbackFromTest(callback, null, scope || this);
                return;
            }

            var args = [ sourceContext.globalXY, targetContext.globalXY, callback, scope, options, dragOnly ];
            
            if (this.moveCursorBetweenPoints && callback) {
                this.syncCursor(sourceContext.globalXY, this.simulateDrag, args);
            } else {
                this.simulateDrag.apply(this, args)
            }
        },

        /**
         * This method will simulate a drag and drop operation from a point (or DOM element) and move by a delta.
         * The following events will be fired, in order:  `mouseover`, `mousedown`, `mousemove` (along the mouse path), `mouseup`
         *   
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value as the drag starting point
         * @param {Array} delta The amount to drag from the source coordinate, expressed as [x,y]. E.g. [50, 10] will drag 50px to the right and 10px down.
         * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        dragBy : function (source, delta, callback, scope, options, dragOnly, offset) {
            if (!delta) throw 'No drag delta defined';
            
            source              = source || this.currentPosition;

            if (this.typeOf(source) != 'Array') {
                var normalized  = this.normalizeElement(source, true, offset)
                
                if (normalized) this.scrollTargetIntoView(normalized, offset)
            }

            var sourceContext   = this.getNormalizedTopElementInfo(source, true, 'dragBy: Source', offset);

            if (!sourceContext) {
                this.waitForTarget(source, function() {
                    this.dragBy(source, delta, callback, scope, options, dragOnly, offset);
                }, this);

                return;
            }
            
            var sourceXY        = sourceContext.globalXY;
            var targetXY        = [ sourceXY[0] + delta[0], sourceXY[1] + delta[1] ];
            
            var args            = [ sourceXY, targetXY, callback, scope, options, dragOnly ];
            
            if (this.moveCursorBetweenPoints && callback) {
                this.syncCursor(sourceXY, this.simulateDrag, args);
            } else {
                this.simulateDrag.apply(this, args)
            }
        },
        
        // private
        simulateDrag: function (sourceXY, targetXY, callback, scope, options, dragOnly) {
            var me          = this
            options         = options || {};

            // For drag operations we should always use the top level document.elementFromPoint
            var source      = me.elementFromPoint(sourceXY[0], sourceXY[1], true);
            var target      = me.elementFromPoint(targetXY[0], targetXY[1], true);
            
            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,
                
                observeTest     : this
            });
            
            queue.addStep({
                processor : function () {
                    me.simulateEvent(source, "mouseover", $.extend({ clientX: sourceXY[0], clientY: sourceXY[1]}, options));
                }
            });
            
            queue.addStep({
                processor : function () {
                    // Fetch source el again since the mouseover might trigger another element to go visible.
                    source  = me.elementFromPoint(sourceXY[0], sourceXY[1], true, source);
                    me.simulateEvent(source, "mouseover", $.extend({ clientX: sourceXY[0], clientY: sourceXY[1]}, options));
                }
            });
            
            queue.addStep({
                processor : function () {
                    me.simulateEvent(source, "mousedown", $.extend({ clientX: sourceXY[0], clientY: sourceXY[1]}, options));
                }
            });
            
            queue.addStep({
                isAsync     : true,
                
                processor   : function (data) {
                    me.moveMouse(sourceXY, targetXY, data.next, this, null, true, options);
                }
            });
            
            var el;
            
            queue.addStep({
                processor : function () {
                    el      = me.elementFromPoint(targetXY[0], targetXY[1], true);
                    me.simulateEvent(el, 'mouseover', $.extend({ clientX: targetXY[0], clientY: targetXY[1] }, options)); 
                }
            });
            
            if (!dragOnly) {
                queue.addStep({
                    processor : function () {
                        me.simulateEvent(el, 'mouseup', $.extend({ clientX: targetXY[0], clientY: targetXY[1] }, options)); 
                    }
                });
            
                queue.addStep({
                    processor : function () {
                        if (el === source) {
                            me.simulateEvent(el, 'click', $.extend({ clientX: targetXY[0], clientY: targetXY[1] }, options));
                        }
                    }
                });
            }
            
            
            var async       = this.beginAsync();
            
            queue.run(function () {
                me.endAsync(async)
                
                me.processCallbackFromTest(callback, null, scope || me)
            });
        }
    }
});

;
/**
 @class Siesta.Test.Simulate.KeyCodes
 @singleton

 This is a singleton class, containing the mnemonical names for various advanced key codes. You can use this names in the {@link Siesta.Test.Browser#type} method, like this:

 t.type(el, 'Foo bar[ENTER]', function () {
            ...
        })

 Below is the full list:

 - `BACKSPACE`

 - `TAB`

 - `RETURN`
 - `ENTER`

 - `SHIFT`
 - `CTRL`
 - `ALT`

 - `PAUSE-BREAK`
 - `CAPS`
 - `ESCAPE`
 - `NUM-LOCK`
 - `SCROLL-LOCK`
 - `PRINT`

 - `PAGE-UP`
 - `PAGE-DOWN`
 - `END`
 - `HOME`
 - `LEFT`
 - `UP`
 - `RIGHT`
 - `DOWN`
 - `INSERT`
 - `DELETE`


 - `NUM0`
 - `NUM1`
 - `NUM2`
 - `NUM3`
 - `NUM4`
 - `NUM5`
 - `NUM6`
 - `NUM7`
 - `NUM8`
 - `NUM9`

 - `F1`
 - `F2`
 - `F3`
 - `F4`
 - `F5`
 - `F6`
 - `F7`
 - `F8`
 - `F9`
 - `F10`
 - `F11`
 - `F12`

 */
Singleton('Siesta.Test.Simulate.KeyCodes', {

    methods : {
        isNav : function (k) {
            var keys = this.keys

            return (k >= 33 && k <= 40) ||
                k == keys.RETURN ||
                k == keys.TAB ||
                k == keys.ESCAPE;
        },

        isSpecial : function (k) {

            return (k === this.keys.BACKSPACE) ||
                (k >= 16 && k <= 20) ||
                (k >= 44 && k <= 46);
        },

        fromCharCode : function(code) {
            for (var o in this.keys) {
                if (this.keys[o] === code) return o;
            }
        }
    },

    has : {
        // FROM Syn library by JupiterJS, MIT License. www.jupiterjs.com

        // key codes
        keys : {

            init : {
                //backspace
                '\b'          : 8,
                'BACKSPACE'   : 8,

                //tab
                '\t'          : 9,
                'TAB'         : 9,

                //enter
                '\r'          : 13,
                'RETURN'      : 13,
                'ENTER'       : 13,

                //special
                'SHIFT'       : 16,
                'CTRL'        : 17,
                'ALT'         : 18,

                //weird
                'PAUSE-BREAK' : 19,
                'CAPS'        : 20,
                'ESCAPE'      : 27,
                'NUM-LOCK'    : 144,
                'SCROLL-LOCK' : 145,
                'PRINT'       : 44,

                //navigation
                'PAGE-UP'     : 33,
                'PAGE-DOWN'   : 34,
                'END'         : 35,
                'HOME'        : 36,
                'LEFT'        : 37,
                'UP'          : 38,
                'RIGHT'       : 39,
                'DOWN'        : 40,
                'INSERT'      : 45,
                'DELETE'      : 46,

                //normal characters
                ' '           : 32,
                '0'           : 48,
                '1'           : 49,
                '2'           : 50,
                '3'           : 51,
                '4'           : 52,
                '5'           : 53,
                '6'           : 54,
                '7'           : 55,
                '8'           : 56,
                '9'           : 57,
                'A'           : 65,
                'B'           : 66,
                'C'           : 67,
                'D'           : 68,
                'E'           : 69,
                'F'           : 70,
                'G'           : 71,
                'H'           : 72,
                'I'           : 73,
                'J'           : 74,
                'K'           : 75,
                'L'           : 76,
                'M'           : 77,
                'N'           : 78,
                'O'           : 79,
                'P'           : 80,
                'Q'           : 81,
                'R'           : 82,
                'S'           : 83,
                'T'           : 84,
                'U'           : 85,
                'V'           : 86,
                'W'           : 87,
                'X'           : 88,
                'Y'           : 89,
                'Z'           : 90,

                //NORMAL-CHARACTERS, NUMPAD
                'NUM0'        : 96,
                'NUM1'        : 97,
                'NUM2'        : 98,
                'NUM3'        : 99,
                'NUM4'        : 100,
                'NUM5'        : 101,
                'NUM6'        : 102,
                'NUM7'        : 103,
                'NUM8'        : 104,
                'NUM9'        : 105,
                '*'           : 106,
                '+'           : 107,
                '-'           : 109,
                '.'           : 110,

                //normal-characters, others
                '/'           : 111,
                ';'           : 186,
                '='           : 187,
                ','           : 188,
                '-'           : 189,
                '.'           : 190,
                '/'           : 191,
                '`'           : 192,
                '['           : 219,
                '\\'          : 220,
                ']'           : 221,
                "'"           : 222,

                'F1'  : 112,
                'F2'  : 113,
                'F3'  : 114,
                'F4'  : 115,
                'F5'  : 116,
                'F6'  : 117,
                'F7'  : 118,
                'F8'  : 119,
                'F9'  : 120,
                'F10' : 121,
                'F11' : 122,
                'F12' : 123
            }
        }
        // eof key codes
    }
});;
/**
@class Siesta.Test.Simulate.Keyboard

This is a mixin, providing the keyboard events simulation functionality.


*/

//        Copyright (c) 2011 John Resig, http://jquery.com/

//        Permission is hereby granted, free of charge, to any person obtaining
//        a copy of this software and associated documentation files (the
//        "Software"), to deal in the Software without restriction, including
//        without limitation the rights to use, copy, modify, merge, publish,
//        distribute, sublicense, and/or sell copies of the Software, and to
//        permit persons to whom the Software is furnished to do so, subject to
//        the following conditions:

//        The above copyright notice and this permission notice shall be
//        included in all copies or substantial portions of the Software.

//        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//        LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//        OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
//        WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Role('Siesta.Test.Simulate.Keyboard', {

    requires        : [ 'simulateEvent', 'getSimulateEventsWith', 'getElementAtCursor' ],

    methods: {
        // private
        createKeyboardEvent: function (type, options, el) {
            var evt;

            var e = $.extend({ bubbles: true, cancelable: true, view: this.global,
                ctrlKey: false, altKey: false, shiftKey: false, metaKey: false,
                keyCode: 0, charCode: 0
            }, options);

            var doc = el.ownerDocument;

            // use W3C standard when available and allowed by "simulateEventsWith" option
            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                try {
                    evt = doc.createEvent("KeyEvents");
                    evt.initKeyEvent(type, e.bubbles, e.cancelable, e.view, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.keyCode, e.charCode);
                } catch (err) {
                    evt = doc.createEvent("Events");
                    evt.initEvent(type, e.bubbles, e.cancelable);
                    $.extend(evt, { view: e.view,
                        ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey, metaKey: e.metaKey,
                        keyCode: e.keyCode, charCode: e.charCode
                    });
                }
            } else if (doc.createEventObject) {
                evt = doc.createEventObject();
                $.extend(evt, e);
            }
            if ($.browser.msie || $.browser.opera) {
                evt.keyCode = (e.charCode > 0) ? e.charCode : e.keyCode;
                evt.charCode = undefined;
            }
            
            // IE10 somehow reports that "defaultPrevented" property of the event object is `false`
            // even that "preventDefault()" has been called on the object
            // more over, immediately after call to "preventDefault()" the property is updated
            // but down in stack it is replaced with "false" again somehow
            // we setup our own, additional property, indicating that event has been prevented
            if ($.browser.msie && $.browser.version == '10.0') {
                var prev    = evt.preventDefault
                
                if (prev) evt.preventDefault = function () {
                    this.$defaultPrevented  = true                    
                    return prev.apply(this, arguments)
                }
            }
            
            return evt;
        },

        // private
        createTextEvent: function (type, options, el) {
            var doc         = el.ownerDocument;
            var event       = null;

            // only for Webkit for now
            if (doc.createEvent && !$.browser.msie) {
                try {
                    event = doc.createEvent('TextEvent');

                    if (event && event.initTextEvent) {
                        event.initTextEvent('textInput', true, true, this.global, options.text, 0);
                        return event;
                    }
                }
                catch(e) {}
            }

            return null;
        },
        
        
        /*!
         * Based on:
         * 
         * @license EmulateTab
         * Copyright (c) 2011, 2012 The Swedish Post and Telecom Authority (PTS)
         * Developed for PTS by Joel Purra <http://joelpurra.se/>
         * Released under the BSD license.
         *
         * A jQuery plugin to emulate tabbing between elements on a page.
         */
        findNextFocusable : function (el, offset) {
            var $el         = this.$(el)
            
            var $focusable  = this.$(":input, a[href]", el.ownerDocument)
                .not(":disabled")
                .not(":hidden")
                .not("a[href]:empty");
                
            var escapeSelectorName  = function (str) {
                // Based on http://api.jquery.com/category/selectors/
                // Still untested
                return str.replace(/(!"#$%&'\(\)\*\+,\.\/:;<=>\?@\[\]^`\{\|\}~)/g, "\\\\$1");
            }

            if (
                el.tagName === "INPUT"
                && el.type === "radio"
                && el.name !== ""
            ) {
                var name    = escapeSelectorName(el.name);

                $focusable  = $focusable
                    .not("input[type=radio][name=" + name + "]")
                    .add($el);
            }

            // Sort the inputs, by tabIndex if it is set
            var elsWithTabIndex = $focusable.filter('[tabindex]');

            elsWithTabIndex.sort(function(a, b) {
                return a.tabIndex < b.tabIndex ? -1 : 1;
            });

            elsWithTabIndex     = $(elsWithTabIndex.toArray().concat($focusable.filter(':not([tabindex])').toArray()));

            var currentIndex    = $(elsWithTabIndex).index($el);

            var nextIndex       = (currentIndex + offset) % elsWithTabIndex.length;
            var $next;

            // If we're at the last focusable element, focus the body el
            if (nextIndex > 0) {
                $next           = elsWithTabIndex.eq(nextIndex);
            }

            return $next && $next[ 0 ] || null;
        },
        
        
        emulateTab : function (el, offset) {
            var next        = this.findNextFocusable(el, offset || 1)
            
            if (next)  
                this.focus(next)
            else
                el.blur()
                
            return next
        },


        /**
        * This method will simulate keyboard typing on either a provided DOM element, or if omitted on the currently focuced DOM element.
        * Simulation of certain special keys such as ENTER, ESC, LEFT etc is supported.
        * You can type these special keys by using the all uppercase name the key inside square brackets. See {@link Siesta.Test.Simulate.KeyCodes} for a list
        * of key names.
        *
        * For example:
        *

    t.type(el, 'Foo bar[ENTER]', function () {
        ...
    })

    // With extra options as the last argument
    t.type(el, 'Foo bar[ENTER]', callback, scope, { shiftKey : true, altKey : true });
        *
        * The following events will be fired, in order: `keydown`, `keypress`, `keyup`
        *
        * @param {Siesta.Test.ActionTarget} el The element to type into
        * @param {String} text The text to type, including any names of special keys in square brackets.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the type operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Object} options (optional) any extra options used to configure the DOM key events (like holding shiftKey, ctrlKey, altKey etc).
        */
        type: function (el, text, callback, scope, options) {
            el              = this.normalizeElement(el || this.activeElement());

            // Some browsers (IE/FF) do not overwrite selected text, do it manually.
            var selText     = this.getSelectedText(el);

            if (selText) {
                el.value    = el.value.replace(selText, '');
            }

            var me          = this

            if (el.readOnly || el.disabled) {
                me.processCallbackFromTest(callback, null, scope || me)

                return;
            }

            // Extract normal chars, or special keys in brackets such as [TAB], [RIGHT] or [ENTER]			
            var keys        = (text + '').match(/(\[(?:\w|-)+\])|([\s\S])/g) || [];

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : this.actionDelay,
                callbackDelay   : this.afterActionDelay,

                observeTest     : this,

                processor       : function (data, index) {
                    // 1. In IE10, it seems activeElement cannot be trusted as it sometimes returns an empty object with no properties.
                    // Try to detect this case and simply use the original el 
                    // 2. If user clicks around in the harness during ongoing test, the activeElement will be reset to BODY
                    // If this happens, reuse the original el and hope all is well
                    var focusedEl   = me.activeElement(true, el, el)
                    
                    me.keyPress(focusedEl, data.key, options)
                }
            })

            // Manually focus event to be typed into first
            queue.addStep({
                processor       : function () {
                    me.focus(el)
                }
            })

            jQuery.each(keys, function (index, key) {
                queue.addStep({
                    key     : key.length == 1 ? key : key.substring(1, key.length - 1)
                })
            });

            var async       = this.beginAsync();

            queue.run(function () {
                me.endAsync(async)

                me.processCallbackFromTest(callback, null, scope || me)
            })
        },

        /**
        * @param {Siesta.Test.ActionTarget} el
        * @param {String} key
        * @param {Object} options any extra options used to configure the DOM event
        *
        * This method will simluate the key press, translated to the specified DOM element.
        * The following events will be fired, in order: `keydown`, `keypress`, `textInput`(webkit only currently), `keyup`
        */
        keyPress: function (el, key, options) {
            el                  = this.normalizeElement(el);

            var KeyCodes        = Siesta.Test.Simulate.KeyCodes().keys
            var keyCode         = KeyCodes[ key.toUpperCase() ] || 0;

            options             = options || {};

            options.readableKey = key;

            var isReadableKey   = this.isReadableKey(keyCode)

            var charCode        = isReadableKey ? key.charCodeAt(0) : 0

            var me              = this,
                isTextInput     = me.isTextInput(el),
                isEditableNode  = me.isEditableNode(el),
                acceptsTextInput = isTextInput || isEditableNode;

            var keyDownEvent    = me.simulateEvent(el, 'keydown', $.extend({ charCode : 0, keyCode : keyCode }, options), true);
            var keyDownPrevented    = this.isEventPrevented(keyDownEvent)

            var event           = me.simulateEvent(el, 'keypress', $.extend({ charCode : charCode, keyCode : isReadableKey ? 0 : keyCode }, options), false);
            var prevented       = this.isEventPrevented(event)

            var supports        = Siesta.Harness.Browser.FeatureSupport().supports

            if (!keyDownPrevented && !prevented && keyCode === KeyCodes.TAB) {
                el              = this.emulateTab(el, options.shiftKey ? -1 : 1) || el;
            }
            
            if (!prevented && acceptsTextInput && keyCode != KeyCodes.TAB) {
                var isPhantomJS = this.harness.isPhantomJS
                var textValueProp = "value" in el ? "value" : "innerHTML";

                if (isReadableKey) {
                    // PhantomJS does not simulate the "textInput" event correctly if target element is inside an iframe
                    // (at least not as of 1.6), only the last character is shown.
                    if (!isPhantomJS) {

                        // IE10 tries to be 'helpful' by inserting an empty space, clean it
                        if (isEditableNode && $.browser.msie && el.innerHTML.indexOf('&nbsp;') === 0) {
                            el.innerHTML = el.innerHTML.substring(6);
                        }

                        // IE won't do execCommand with insertText
                        if (isEditableNode && !$.browser.msie) {
                            if (el.innerHTML.charCodeAt(el.innerHTML.length-1) === 8203) {
                                el.innerHTML = el.innerHTML.substring(0, el.innerHTML.length-1);
                            }
                            el.ownerDocument.execCommand('insertText', false, options.readableKey);
                        } else {
                            // TODO should check first if textInput event is supported
                            me.simulateEvent(el, 'textInput', { text: options.readableKey }, true);
                        }
                    }
                    
                    var originalLength  = el[textValueProp].length;
                    var maxLength       = el.getAttribute('maxlength')
                    
                    if (maxLength != null) maxLength    = Number(maxLength)

                    // If the entered char had no impact on the textfield - manually put it there
                    if ((isTextInput || $.browser.msie) && (!supports.canSimulateKeyCharacters || isPhantomJS) && originalLength === el[textValueProp].length && originalLength !== maxLength) {
                        el[textValueProp] = el[textValueProp] + options.readableKey;
                    }
                }

                // Manually delete one char off the end if backspace simulation is not supported by the browser
                if (keyCode === KeyCodes.BACKSPACE && !supports.canSimulateBackspace && el[textValueProp].length > 0) {
                    // IE won't do execCommand with insertText
                    if (isTextInput || $.browser.msie) {
                        el[textValueProp]    = el[textValueProp].substring(0, el[textValueProp].length - 1);
                    } else {
                        el.ownerDocument.execCommand('delete');
                    }
                }

                if (textValueProp === 'value' && keyCode === KeyCodes.ENTER && !supports.enterSubmitsForm) {
                    var form    = this.$(el).closest('form');

                    if (form.length) form.submit();
                }
            }

            // somehow "node.nodeName" is empty sometimes in IE10
            var nodeName        = el.nodeName && el.nodeName.toLowerCase()

            if ((nodeName == 'a' || nodeName == 'button') && keyCode === KeyCodes.ENTER && !supports.enterOnAnchorTriggersClick) {
                // this "click" should not update the current cursor position its merely for activating "click" listeners
                me.simulateEvent(el, 'click', { doNotUpdateCurrentPosition : true }, true);
            }
            me.simulateEvent(el, 'keyup', $.extend({ charCode : 0, keyCode : keyCode }, options), true);
        },
        

        isTextInput : function(node) {
            // somehow "node.nodeName" is empty sometimes in IE10
            var name    = node.nodeName && node.nodeName.toLowerCase(),
                type    = node.type && node.type.toLowerCase();

            return  name === 'textarea' ||
                    // Various INPUT types
                    (name === 'input' && (type === 'password'    ||
                                         type === 'number'      ||
                                         type === 'search'      ||
                                         type === 'text'        ||
                                         type === 'email'));
        },

        isEditableNode : function(node) {
            return node.ownerDocument.designMode.toLowerCase() === 'on' ||
                   node.contentEditable.toLowerCase() === 'true';
        },

        // private
        isReadableKey: function (keyCode) {
            var KC = Siesta.Test.Simulate.KeyCodes();

            return !KC.isNav(keyCode) && !KC.isSpecial(keyCode);
        }
    }
});


;
/**
@class Siesta.Test.Simulate.Event

This is a mixin providing events simulation functionality.

*/

Role('Siesta.Test.Simulate.Event', {
    
    requires        : [ 
        'createTextEvent', 
        'createMouseEvent', 
        'createKeyboardEvent'
    ],
    
    has: {
        actionDelay             : 100,
        afterActionDelay        : 100,
        
        /**
         * @cfg {String} simulateEventsWith
         * 
         * This option is IE9-strict mode (and probably above) specific. It specifies, which events simulation function Siesta should use. 
         * The choice is between 'dispatchEvent' (W3C standard) and 'fireEvent' (MS interface) - both are available in IE9 strict mode
         * and both activates different event listeners. See this blog post for detailed explanations: 
         * <http://www.digitalenginesoftware.com/blog/archives/76-DOM-Event-Model-Compatibility-or-Why-fireEvent-Doesnt-Trigger-addEventListener.html>
         * 
         * Valid values are "dispatchEvent" and "fireEvent".
         * 
         * The framework specific adapters choose the most appropriate value automatically (unless explicitly configured).
         */
        simulateEventsWith      : {
            is          : 'rw',
            init        : 'dispatchEvent'
        }
    },

    methods: {
        
        /**
         * This method will simulate an event triggered by the passed element. If no coordinates are supplied in the options object, the center of the element
         * will be used. 
         * @param {Siesta.Test.ActionTarget} el
         * @param {String} type The type of event (e.g. 'mouseover', 'click', 'keypress')
         * @param {Object} the options for the event. See http://developer.mozilla.org/en/DOM/event for reference.
         * @param {Boolean} suppressLog true to not include this simulated event in the assertion grid.
         */
        simulateEvent: function (el, type, options, suppressLog) {
            var global      = this.global;
            options         = options || {};

            if (this.valueIsArray(el)) {
                if (!('clientX' in options)) {
                    options.clientX = el[0];
                }

                if (!('clientY' in options)) {
                    options.clientY = el[1];
                }
            }

            el              = this.normalizeElement(el);
            var evt         = this.createEvent(type, options, el);


            if (evt) {
                evt.synthetic = true;
                this.dispatchEvent(el, type, evt);

                // Let the outside world know that an event was simulated
                if (!suppressLog) {
                    this.fireEvent('eventsimulated', this, el, type, evt);
                }
            }

            return evt;
        },

        createEvent: function (type, options, el) {
            if (/^text(Input)$/.test(type)) {
                return this.createTextEvent(type, options, el);
            }
            if (/^mouse(over|out|down|up|move|enter|leave)|contextmenu|(dbl)?click$/.test(type)) {
                return this.createMouseEvent(type, options, el);
            }
            if (/^key(up|down|press)$/.test(type)) {
                return this.createKeyboardEvent(type, options, el);
            }

//            XXX should be implemented in the Mobile (SenchaTouch) test class
//            if (/^touch/.test(type)) {
//                return this.createTouchEvent(type, options, el);
//            }
            // use W3C standard when available and allowed by "simulateEventsWith" option

            return this.createHtmlEvent(type, options, el);
        },


        createHtmlEvent : function(type, options, el) {

            var doc = el.ownerDocument;

            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                var evt = doc.createEvent("HTMLEvents");
                evt.initEvent(type, false, false);
                return evt;
            } else if (doc.createEventObject) {
                return doc.createEventObject();
            }
        },
        
        dispatchEvent: function (el, type, evt) {
            // use W3C standard when available and allowed by "simulateEventsWith" option            
            if (el.dispatchEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                el.dispatchEvent(evt);
            } else if (el.fireEvent) {
                // IE 6,7,8 can't dispatch many events cleanly - throws exceptions
                try {
                    // this is the serios nominant to the best-IE-bug-ever prize and its IE7 specific
                    // accessing the "scrollLeft" property on document or body triggers the synchronous(!) "resize" event on window
                    // ExtJS uses singleton for Ext.EventObj and its "target" property gets overwritten with "null"
                    // thus consequent event handlers fails
                    // doing an access to that property to cache it
                    var doc     = this.global.document.documentElement;
                    var body    = this.global.document.body;
                    
                    var xxx     = doc && doc.scrollLeft || body && body.scrollLeft || 0;
                    
                    el.fireEvent('on' + type, evt);
                } catch (e) {
                }
            } else
                throw "Can't dispatch event: " + type
            
            return evt;
        }

    }
});
;
/**
 * 
@class Siesta.Test.ExtJSCore

A base mixin for testing ExtJS and SenchaTouch applications. 

Contains testing functionality that is common for both frameworks.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Role('Siesta.Test.ExtJSCore', {
    
    has : {
        waitForExtReady         : true,
        waitForAppReady         : false,
        loaderPath              : null,
        
        simulateEventsWith      : {
            is      : 'rw',
            lazy    : function () {
                var isIE9           = navigator.userAgent.match(/MSIE 9.0;/)
                var Ext             = this.getExt()
                // the "Ext.getVersion('extjs')" is just "true" in Ext3? (when testing SA)
                var isBelowExt421   = Boolean(Ext && (!Ext.getVersion || Ext.getVersion('extjs') && Ext.getVersion('extjs').isLessThan && Ext.getVersion('extjs').isLessThan('4.2.1.883')))
                
                var div             = document.createElement('div')
                
                return div.attachEvent && (isIE9 || isBelowExt421) ? 'fireEvent' : 'dispatchEvent'
            }
        },
        
        isExtOnReadyDone        : false,
        onReadyWaitingStarted   : false,
        isAppReadyDone          : false
    },

    override : {
        
        processSubTestConfig : function () {
            var res                 = this.SUPERARG(arguments)
            
            // sub tests should not wait for Ext.onReady or for application launch
            res.waitForAppReady     = false
            res.waitForExtReady     = false 
            
            return res
        },
        
        
        isReady : function() {
            var result      = this.SUPERARG(arguments);

            if (!result.ready) return result;
            
            var Ext         = this.getExt();
            
            if (this.waitForExtReady && !this.onReadyWaitingStarted && Ext && Ext.onReady) {
                this.onReadyWaitingStarted  = true
                
                var me      = this
                
                Ext.onReady(function () {
                    me.isExtOnReadyDone     = true
                })
            }
            

            if (this.waitForExtReady && !this.isExtOnReadyDone) return {
                ready       : false,
                reason      : "Waiting for Ext.onReady took too long - some dependency can't be loaded? \nCheck the `Net` tab in Firebug"
            }
            
            if (this.waitForAppReady && !this.isAppReadyDone) return {
                ready       : false,
                reason      : "Waiting for MVC application launch took too long - no MVC application on test page? \nYou may need to disable the `waitForAppReady` config option."
            }
            
            return {
                ready       : true
            }
        },

        // Overridden to deal with the different event firing mechanisms in Ext JS 3 vs 4
        // This code is required because in IE events are simulated using fireEvent instead of dispatchEvent and it seems fireEvent will
        // will not update a checkbox 'checked' state properly so we're forcing the toggle to solve this situation. 
        // This issue is only relevant in IE + Ext. 
        //
        // Test case: 507_form_checkbox.t.js
        simulateMouseClick: function (clickInfo, callback, scope, options) {
            var el      = clickInfo.el
            
            // Force check toggle for input checkboxes
            if (this.getSimulateEventsWith() === 'fireEvent' && (el.type === 'checkbox' || el.type === 'radio') && !el.disabled && !el.readOnly) {
                var oldState = el.checked;

                if (callback) {
                    this.SUPER(el, function (finalClickTarget) { 
                        if (finalClickTarget == el && el.checked === oldState) {
                            el.checked = !oldState;
                        }
                        callback.call(scope || this, finalClickTarget);
                    });
                } else {
                    this.SUPERARG(arguments);

                    if (el.checked === oldState) {
                        el.checked = !oldState;
                    }
                }
            } else {
                this.SUPERARG(arguments);
            }
        }
    },

    methods : {
        
        initialize : function() {
            // Since this test is preloading Ext JS, we should let Siesta know what to 'expect'
            this.expectGlobals('Ext', 'id');
            this.SUPER();
        },
        
        
        start : function (alreadyFailedWithException) {
            var me      = this;
            var Ext     = this.getExt();
            
            if (!Ext) {
                // proceed to parent implementation disabling our "can start" checkers 
                this.waitForAppReady    = false
                this.waitForExtReady    = false
                
                this.SUPERARG(arguments)
                
                return
            }

            // install a "loader path hook" 
            this.harness.generateLoaderPathHook()(this.global.StartTest, Ext, this.loaderPath)
            
            // the actual waiting for Ext.onReady will happen inside of `isReady` method
            // this is because in microloaded touch apps, Ext.onReady may appear with some arbitrary delay

            
            // this flag will explain to Ext, that DOM ready event has already happened
            // Ext fails to set this flag if it was loaded dynamically, already after DOM ready
            // the test will start only after DOM ready anyway, so we just set this flag  
            Ext.isReady         = true

            var canWaitForApp   = Ext.ClassManager && Boolean(Ext.ClassManager.get('Ext.app.Application'))
            
            if (!canWaitForApp) this.waitForAppReady = false
                
            if (this.waitForAppReady && canWaitForApp)
                Ext.util.Observable.observe(Ext.app.Application, {
                    launch      : function () {
                        me.isAppReadyDone   = true
                    },
                    
                    single      : true,
                    delay       : 100
                })
            
            this.SUPERARG(arguments)
        },

        /**
         * This method returns the `Ext` object from the scope of the test. When creating your own assertions for Ext JS code, you need
         * to make sure you are using this method to get the `Ext` instance. Otherwise, you'll be using the same "top-level" `Ext`
         * instance, used by the harness for its UI. 
         * 
         * For example:
         * 
         *      elementHasProvidedCssClass : function (el, cls, desc) {
         *          var Ext     = this.getExt();
         *          
         *          if (Ext.fly(el).hasCls(cls)) {
         *              this.pass(desc);
         *          } else {
         *              this.fail(desc);
         *          }
         *      }
         *   
         * @return {Object} The `Ext` object from the scope of test
         */
        getExt : function () {
            return this.global.Ext
        },
        
        
        /**
         * The alias for {@link #getExt}
         * @method
         */
        Ext : function () {
            return this.global.Ext
        },
        
        
        isExtJSComponent : function (obj) {
            var Ext     = this.getExt()
            
            return Boolean(Ext && Ext.Component && obj instanceof Ext.Component)
        },
        
        // Accepts Ext.Component or ComponentQuery
        normalizeComponent : function(component, allowEmpty) {
            var Ext = this.Ext();

            if (typeof component === 'string') {
                var result = Ext.ComponentQuery.query(component);
                
                if (!allowEmpty && result.length < 1)   this.warn('Your component query: ' + component + ' returned no components.');
                if (result.length > 1)   this.warn('Your component query: ' + component + ' returned more than 1 component.');
                
                component = result[ 0 ];
            }            

            return component;
        },

        /**
         * @private
         * @param {Ext.Component} comp the Ext.Component
         * @param {Boolean} locateInputEl For form fields, try to find the inner input element by default.
         *                  If you want to target the containing Component element, pass false instead.
         * @return {*}
         */
        compToEl : function (comp, locateInputEl) {
            var Ext = this.Ext();

            if (!comp) return null

            locateInputEl = locateInputEl !== false;

            // Ext JS
            if (Ext && Ext.form && Ext.form.Field && locateInputEl) {
                if (comp instanceof Ext.form.Field && comp.inputEl) {
                    return comp.inputEl.dom || comp.inputEl;
                }

                if (Ext.form.HtmlEditor && comp instanceof Ext.form.HtmlEditor) {
                    //     Ext JS 3       Ext JS 4
                    return comp.iframe || comp.inputEl;
                }
            }

            // Sencha Touch: Form fields can have a child input component
            if (Ext && Ext.field && Ext.field.Field && comp instanceof Ext.field.Field && locateInputEl) {
                comp = comp.getComponent();
            }

            //     Ext JS                             vs Sencha Touch
            return comp.getEl ? comp.getEl() : comp.el || comp.element;
        },

        // Accept Ext.Element and Ext.Component
        // If the 'shallow' flag is true we should not 'reevaluate' the target element - stop at the component element.
        normalizeElement : function(el, allowMissing, shallow) {
            if (!el) return null
            
            var Ext     = this.getExt();

            var origEl  = el;

            if (typeof el === 'string') {
                if (el.match(/=>/))
                    // Composite query
                    el      = this.compositeQuery(el, null, allowMissing)[ 0 ]
                else if (el.match(/^\s*>>/)) {
                    // Component query
                    el      = this.cq1(el.substring(2))
                } else {
                    // string in  unknown format, guessing its a DOM query
                    return this.SUPER(el, allowMissing)
                }

                if (!allowMissing && !el) {
                    this.warn('No component found for CQ: ' + origEl)
                    throw 'No component found for CQ: ' + origEl;
                }
            }

            if (this.isExtJSComponent(el)) {
                el          = this.compToEl(el);

                if (!shallow && this.isElementVisible(el) && this.elementIsTop(el, true)) {
                    var center  = this.findCenter(el);

                    el          = this.elementFromPoint(center[0], center[1], false, el.dom);
                }
            }

            // ExtJS Element
            if (el && el.dom) return el.dom
                
            // will also handle the case of conversion of array with coordinates to el 
            return this.SUPER(el, allowMissing, shallow);
        },
        
        
        // this method generally has the same semantic as the "normalizeElement", it's being used in
        // Siesta.Test.Action.Role.HasTarget to determine what to pass to the next step
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the 
        // component instance
        normalizeActionTarget : function (el, allowMissing) {
            if (typeof el === 'string') {
                if (el.match(/^\s*>>/)) {
                    // Component query
                    var result = this.cq1(el.substring(2));

                    if (!result && !allowMissing) {
                        this.warn('No component found for CQ: ' + el)
                        throw 'No component found found for CQ: ' + el;
                    }
                    return result;
                }
            }
            
            var Ext = this.getExt();
            
            // if user has passed ExtJS Component, return it as is
            if (this.isExtJSComponent(el)) return el
            
            // if user has passed ExtJS Element, return it as is
            if (el && el.dom) return el

            return this.SUPER(el, allowMissing)
        },

         /**
         * This method allow assertions to fail silently for tests executed in versions of Ext JS up to a certain release. When you try to run this test on a newer
         * version of Ext JS and it fails, it will fail properly and force you to re-investigate. If it passes in the newer version, you should remove the 
         * use of this method.
         * 
         * See also {@link Siesta.Test#todo}
         *   
         * @param {String} frameworkVersion The Ext JS framework version, e.g. '4.0.7'
         * @param {Function} fn The method covering the broken functionality
         * @param {String} reason The reason or explanation of the bug
        */
        knownBugIn : function(frameworkVersion, fn, reason) {
            var Ext = this.getExt();
            var version = Ext.versions.extjs || Ext.versions.touch;

            if (this.harness.failKnownBugIn || version.isGreaterThan(frameworkVersion)) {
                fn.call(this.global, this);
            } else {
                this.todo('Known bug in ' + frameworkVersion + ': ' + (reason || ''), fn);
            }
        },
        
        
         /**
         * This method will load the specified classes with `Ext.require()` and call the provided callback. Additionally it will check that all classes have been loaded.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.requireOk('Some.Class1', 'Some.Class2', function () { ... })
         * or array of class names:
         * 
         *      t.requireOk([ 'Some.Class1', 'Some.Class2' ], function () { ... })
         * 
         * @param {String} className1 The name of the class to `require`
         * @param {String} className2 The name of the class to `require`
         * @param {String} classNameN The name of the class to `require`
         * @param {Function} fn The callback. Will be called even if the loading of some classes have failed.
        */
        requireOk : function () {
            var me                  = this
            var global              = this.global
            var Ext                 = this.getExt()
            var args                = Array.prototype.concat.apply([], arguments)
            
            var callback
            
            if (this.typeOf(args[ args.length - 1 ]) == 'Function') callback = args.pop()
            
            
            // what to do when loading completed or timed-out
            var continuation    = function () {
                me.endAsync(async)
                
                Joose.A.each(args, function (className) {
                    var cls     = Ext.ClassManager.get(className)
                    
                    //                       normal class                         singleton
                    if (cls && (me.typeOf(cls) == 'Function' || me.typeOf(cls.self) == 'Function'))
                        me.pass("Class: " + className + " was loaded")
                    else
                        me.fail("Class: " + className + " was loaded")
                })
                
                callback && me.processCallbackFromTest(callback)
            }
            
            var timeout         = Ext.isIE ? 120000 : 30000,
                async           = this.beginAsync(timeout + 100)
            
            var hasTimedOut     = false
            
            var timeoutId       = global.setTimeout(function () {
                hasTimedOut     = true
                continuation()
            }, timeout)
            
            Ext.Loader.setConfig({ enabled : true });

            Ext.require(args, function () {
                global.clearTimeout(timeoutId)
                
                if (!hasTimedOut) continuation() 
            })
        },
        
        /**
         * This method is a simple wrapper around the {@link #chainClick} - it performs a component query for provided `selector` starting from the `root` container
         * and then clicks on all found components, in order:
         * 

    // click all buttons in the `panel`
    t.clickComponentQuery('button', panel, function () {})
    
         * 
         * The 2nd argument for this method can be omitted and method can be called with 2 arguments only. In this case a global component query will be performed:
         *

    // click all buttons in the application
    t.clickComponentQuery('button', function () {})
    
         * 
         * @param {String} selector The selector to perform a component query with
         * @param {Ext.Container} root The optional root container to start a query from.
         * @param {Function} callback The callback to call, after clicking all the found components
         */
        clickComponentQuery : function (selector, root, callback) {
            
            if (arguments.length == 2 && this.typeOf(arguments[ 1 ]) == 'Function') {
                callback    = root
                root        = this.Ext().ComponentQuery
            }
            
            if (arguments.length == 1) {
                root        = this.Ext().ComponentQuery
            }
            
            var result      = root.query(selector)
            
            this.chainClick(result, function () { callback && callback.call(this, result) })
        },
        
        
        /**
         * An alias for {@link #clickComponentQuery}.
         * 
         * @param {String} selector The selector to perform a component query with
         * @param {Ext.Container} root The optional root container to start a query from.
         * @param {Function} callback The callback to call, after clicking all the found components
         */
        clickCQ : function () {
            this.clickComponentQuery.apply(this, arguments)
        },

        /**
         * This method performs a combination of `Ext.ComponentQuery` and DOM query, allowing to easily find the DOM elements, 
         * matching a css selector, inside of some Ext.Component.
         * 
         * Both queries should be combined with the `=>` separator: 
         *      
         *      gridpanel[title=Accounts] => .x-grid-row
         *       
         * On the left side of such "composite" query should be a component query, on the right - DOM query (CSS selector)
         * 
         * In case when component query returns more than one component, this method iterate through all of them and will try to
         * resolve the 2nd part of the query. The results from the 1st component with matching DOM nodes is returned. 
         * 
         * E.g. the composite query `gridpanel[title=Accounts] => .x-grid-row` will give you the grid row elements inside a grid panel
         * with `title` config matching "Accounts". 
         * 
         * @param {String} selector The CompositeQuery selector
         * @param {Ext.Component} root The optional root component to start the component query from. If omitted, a global component query will be performed.
         * @param {Boolean} allowEmpty False to throw the exception from this method if no matching DOM element is found. Default is `true`.
         * 
         * @return {HTMLElement[]} The array of DOM elements 
         */
        compositeQuery : function (selector, root, allowEmpty) {
            allowEmpty  = allowEmpty !== false
            
            var Ext     = this.Ext();
            // Try to find magic => selector for nested ComponentQuery and CSS selector
            var mainParts  = selector.split('=>');
            var result, i, cmp;

            root        = root || Ext.ComponentQuery;

            if (mainParts.length < 2) throw "Invalid composite query selector: " + selector

            // TODO NICK, AMEND
            var components;

            if (mainParts[0].match(/\./)) {
                // complex case
                var cqParts = mainParts[0].trim().split(' ');

                for (i = 0; i < cqParts.length; i++) {
                    var query = cqParts[i].trim().split('.');

                    // TODO assuming query is specific, targeting just one target
                    root = root.query(query[0])[0];

                    if (query.length > 1) {
                        var fn = query[1].substr(0, query[1].length-2);
                        root = root[fn]();
                    }
                }

                components     = [root];
            } else {
                components     = root.query(mainParts[0]);
            }


            if (!components.length)
                if (allowEmpty) 
                    return []
                else
                    throw 'ComponentQuery ' + mainParts[0] + ' matched no Ext.Component';
            
            for (i = 0; i < components.length; i++) {
                cmp         = components[i];

                if (cmp.rendered) {
                    result = this.compToEl(cmp, false).query(mainParts[1]);

                    if (result.length > 0) {
                        return result;
                    }
                }
            }

            if (allowEmpty) {
                return [];
            }
            throw 'Composite query ' + selector + ' matched no Ext.Component';
        },
        
        /**
         * An alias for Ext.ComponentQuery.query
         * 
         * @param {String} selector The selector to perform a component query with
         */
        cq : function (selector) {
            return this.Ext().ComponentQuery.query(selector);
        },

        /**
         * An shorthand method to get the first result of any Ext.ComponentQuery.query
         * 
         * @param {String} selector The selector to perform a component query with
         */
        cq1 : function (selector) {
            return this.Ext().ComponentQuery.query(selector)[0];
        },

        /**
         * Waits until the passed action target is detected and no ongoing animations are found. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout) {
            this.SUPER(target, function() {
                this.waitForAnimations(callback, scope, timeout);
            }, this, timeout);
        },

        /**
         * This assertion passes if the singleton MessageBox instance is currently visible.
         * The assertion is relevant if you use one of the following methods Ext.Msg.alert, Ext.Msg.confirm, Ext.Msg.prompt.
         *
         * @param {String} [description] The description for the assertion
         */
        messageBoxIsVisible : function(desc) {
            return this.notOk(this.Ext().Msg.isHidden(), desc || 'Message box is visible');
        },

        /**
         * This assertion passes if the singleton MessageBox instance is currently hidden.
         * The assertion is relevant if you use one of the following methods Ext.Msg.alert, Ext.Msg.confirm, Ext.Msg.prompt.
         *
         * @param {String} [description] The description for the assertion
         */
        messageBoxIsHidden : function(desc) {
            return this.ok(this.Ext().Msg.isHidden(), desc || 'Message box is hidden');
        },

        /**
         * This assertion passes if the passed component query matches at least one component.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        cqExists : function(query, description) {
            this.ok(this.cq1(query), description);
        },

        /**
         * This assertion passes if the passed component query matches no components.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        cqNotExists : function(query, description) {
            this.notOk(this.cq1(query), description);
        },

        /**
         * This assertion passes if the passed component query matches at least one component.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        componentQueryExists : function() {
            this.cqExists.apply(this, arguments);
        }
    }
})
;
/**
@class Siesta.Test.ExtJS.Ajax

This is a mixin, with helper methods for mocking Ajax functionality in Ext JS. This mixin is consumed by {@link Siesta.Test.ExtJS}. 
This is only supported when testing Ext JS 4.
*/
Role('Siesta.Test.ExtJS.Ajax', {
    has : {
        responses : Joose.I.Array,
        urlMatchers : Joose.I.Array
    },

    methods: {

        /**
         * This assertion passes if there is at least one ongoing ajax call.
         * 
         * @param {Object} object (optional) The options object passed to Ext.Ajax.request
         * @param {String} [description] The description for the assertion
         */
        isAjaxLoading: function (obj, description) {
            var Ext = this.Ext();
            this.ok(Ext.Ajax.isLoading(obj), description || 'An Ajax call is currently loading');
        },

        /**
         * This method calls the supplied URL using Ext.Ajax.request and then calls the provided callback. The callback will be called with the 
         * same parameters as the normal Ext.Ajax.request callback is called with ("options", "success" and "response"). To get the response text,
         * use response.responseText.
         * 
         * @param {String/Object} url The url or the options to pass to Ext.Ajax.request
         * @param {Function} callback The callback to call after the ajax request is completed
         * @param {Object} scope The scope for the callback
         */
        ajaxRequestAndThen: function (url, callback, scope) {
            var Ext = this.Ext();
            var options = url;

            if (typeof(url) === 'string') {
                options = {
                    url : url,
                    callback : callback,
                    scope : scope
                };
            }

            Ext.Ajax.request(options);
        },

        /**
         * Waits until the 
         * 
         * @param {Object} object (optional) The options object passed to Ext.Ajax.request
         * @param {Function} callback The callback to call after the ajax request is completed
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForAjaxRequest: function (obj, callback, scope, timeout) {
            var Ext = this.Ext();
            var msg;

            if (typeof obj === 'function') {
                msg = ' all ajax requests to complete';
                timeout = scope;
                scope = callback;
                callback = obj;
                obj = undefined;
            } else {
                msg = ' ajax request to "' + obj.options.url + '" to complete';
            }

            this.waitFor({
                method          : function() { 
                    if (obj) {
                        return !Ext.Ajax.isLoading(obj) && obj;
                    }
                    return !Ext.Ajax.isLoading(obj);
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForAjaxRequest',
                description     : msg
            });
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Store

This is a mixin, with helper methods for testing functionality relating to Ext.data.Store class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Store', {
    
    methods : {
        
        /**
         * Waits until all the passed stores have been loaded (fires the "load" event) and calls the provided callback.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.waitForStoresToLoad(store1, store2, function () { ... })
         * or array of stores:
         * 
         *      t.waitForStoresToLoad([ store1, store2 ], function () { ... })
         * 
         * @param {Ext.data.AbstractStore} store1 The store to load.
         * @param {Ext.data.AbstractStore} store2 The store to load.
         * @param {Ext.data.AbstractStore} storeN The store to load.
         * @param {Function} callback A function to call when the condition has been met.
         */        
        waitForStoresToLoad: function () {
            var Ext         = this.getExt();
            var args        = Array.prototype.concat.apply([], arguments)
            var me          = this;
                                                         // Ext 3
            var baseStoreCls = Ext.data.AbstractStore || Ext.data.Store;
            var callback
            var storesNum;
            
            // First locate the callback
            Joose.A.each(args, function (arg, index) {
                if (me.typeOf(arg) == 'Function') {
                    callback = arg;
                    storesNum = index;
                    return false;
                }
            });

            var loaded      = 0;
            
            me.waitFor({
                method      : function() { return loaded == storesNum; },
                callback    : callback,
                name        : 'waitForStoresToLoad',
                description : storesNum + ' stores to load'
            });

            Joose.A.each(args, function (store) {               
                             // Ext 3       // Ext 4 && ST
                var proxy = (store.proxy || store.getProxy && store.getProxy());
                
                if (!(store instanceof baseStoreCls)) {
                    return false;
                }

                if (!proxy) {
                    storesNum--;
                    return;
                }

                store.on('load', function () {
                    loaded++;
                    proxy.un('exception', exceptionFailure);
                }, null, { single : true });

                var exceptionFailure = function (proxy, response, operation) {
                    var url     = proxy.api && proxy.api.read || proxy.url
                    
                    me.fail("Failed to load the store", "Store [READ] URL: " + url);
                };

                proxy.on('exception', exceptionFailure);
            });
        },

        /**
         * This method is a wrapper around {@link #waitForStoresToLoad} method - it waits for the provided stores to fire the "load" event.
         * In addition to {@link #waitForStoresToLoad} this method also calls the `load` method of each passed store.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.loadStoresAndThen(store1, store2, function () { ... })
         * or array of stores:
         * 
         *      t.loadStoresAndThen([ store1, store2 ], function () { ... })
         * 
         * @param {Ext.data.AbstractStore} store1 The store to load.
         * @param {Ext.data.AbstractStore} store2 The store to load.
         * @param {Ext.data.AbstractStore} storeN The store to load.
         * @param {Function} callback A function to call when the condition has been met.
         */  
        loadStoresAndThen: function () {
            var Ext = this.getExt();
            this.waitForStoresToLoad.apply(this, arguments);
            
            var args                =  Array.prototype.concat.apply([], arguments)
            
            if (this.typeOf(args[ args.length - 1 ]) == 'Function') args.pop()

            Joose.A.each(args, function (store) {
                var proxy = (store.proxy || store.getProxy && store.getProxy());
                if (proxy && store.load) {
                    store.load();
                }
            });
        },

        /**
         * Passes if the passed store has no data.
         * 
         * @param {Ext.data.AbstractStore} store
         * @param {String} [description] The description of the assertion
         */
        isStoreEmpty : function(store, description) {
            this.is(store.getCount(), 0, description);
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Observable

This is a mixin, with helper methods for testing functionality relating to Ext.util.Observable class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Observable', {
    
    methods : {
        
        addListenerToObservable : function (observable, event, listener) {
            // The way events are fired is slightly different for Ext vs raw DOM tests
            if (observable.nodeName && observable.tagName) {
                observable = this.Ext().get(observable);
            }

            if (observable.on && observable.un)
                observable.on(event, listener)
            else
                this.SUPERARG(arguments)
        },
        
        
        removeListenerFromObservable : function (observable, event, listener) {
            // The way events are fired is slightly different for Ext vs raw DOM tests
            if (observable.nodeName && observable.tagName) {
                observable = this.Ext().get(observable);
            }

            if (observable.on && observable.un)
                observable.un(event, listener)
            else
                this.SUPERARG(arguments)
        },

        /**
         * This assertion passes if the observable does not fire the specified event(s) after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Mixed} observable Ext.util.Observable instance or any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} desc The description of the assertion.
         * 
         * @method wontFire
         */
        

        /**
         * This assertion passes if the observable fires the specified event exactly once after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Mixed} observable Ext.util.Observable instance or any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} desc The description of the assertion.
         * 
         * @method firesOnce
         */

        /**
         * This assertion passes if the observable fires the specified event at least `n` times after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Mixed} observable Ext.util.Observable instance or any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of event
         * @param {Number} n The minimum number of events to be fired
         * @param {String} desc The description of the assertion.
         * 
         * @method firesAtLeastNTimes
         */
        
        
        /**
         * This method will wait for the first `event`, fired by the provided Ext JS `observable` and will then call the provided callback.
         * 
         * @param {Ext.util.Observable/String/Ext.Element} observable The observable to wait on, or a ComponentQuery matching a component
         * @param {String} event The name of the event to wait for
         * @param {Function} callback The callback to call 
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForEvent : function (observable, event, callback, scope, timeout) {
            var Ext         = this.Ext();
            observable      = this.normalizeComponent(observable);
            
            if (observable && observable.un && observable.on) {
                var eventFired      = false
            
                observable.on(event, function () { eventFired = true }, null, { single : true })
            
                return this.waitFor({
                    method          : function() { return eventFired; }, 
                    callback        : callback,
                    scope           : scope,
                    timeout         : timeout,
                    assertionName   : 'waitForEvent',
                    description     : ' observable to fire its "' + event + '" event'
                });
            } else {
                return this.SUPERARG(arguments);
            }
        },
        
        
        /**
         * This method passes if the provided `observable` has a listener for the `eventName`
         * 
         * @param {Ext.util.Observable} The observable
         * @param {String} eventName The name of the event
         * @param {String} [description] The description of the assertion.
         */
        hasListener : function (observable, eventName, description) {
            if (!observable || !observable.hasListener) {
                this.fail(description, {
                    assertionName       : 'hasListener',
                    annotation          : '1st argument for `t.hasListener` should be an observable instance'
                })
                
                return
            }
            
            if (observable.hasListener(eventName))
                this.pass(description, {
                    descTpl             : 'Observable has listener for {eventName}',
                    eventName           : eventName
                })
            else
                this.fail(description, {
                    assertionName       : 'hasListener',
                    annotation          : 'Provided observable has no listeners for event: ' + eventName
                })
        },


        /**
         * This assertion will verify that the observable fires the specified event and supplies the correct parameters to the listener function.
         * A checker method should be supplied that verifies the arguments passed to the listener function, and then returns true or false depending on the result.
         * If the event was never fired, this assertion fails. If the event is fired multiple times, all events will be checked, but 
         * only one pass/fail message will be reported.
         * 
         * For example:
         * 

    t.isFiredWithSignature(store, 'add', function (store, records, index) {
        return (store instanceof Ext.data.Store) && (records instanceof Array) && t.typeOf(index) == 'Number'
    })
 
         * @param {Ext.util.Observable} observable The observable instance  
         * @param {String} event The name of event
         * @param {Function} checkerFn A method that should verify each argument, and return true or false depending on the result.
         * @param {String} desc The description of the assertion.
         */
        isFiredWithSignature : function(observable, event, checkerFn, description) {
            var eventFired;
            var me              = this;
            var sourceLine      = me.getSourceLine();
            
            var verifyFiredFn = function () {
                observable.un(event, listener);

                if (!eventFired) {
                    me.fail(event + " event was not fired during the test");
                }
            };
            
            me.on('beforetestfinalizeearly', verifyFiredFn);

            var listener = function () { 
                me.un('beforetestfinalizeearly', verifyFiredFn);
                
                var result = checkerFn.apply(me, arguments);

                if (!eventFired && result) {
                    me.pass(description || 'Observable fired ' + event + ' with correct signature', {
                        sourceLine  : sourceLine
                    });
                }

                if (!result) {
                    me.fail(description || 'Observable fired ' + event + ' with incorrect signature', {
                        sourceLine  : sourceLine
                    });
                    
                    // Don't spam the assertion grid with failure, one failure is enough
                    observable.un(event, listener);
                }
                eventFired = true 
            };

            observable.on(event, listener);
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Component

This is a mixin, with helper methods for testing functionality relating to Ext.Component. This mixin is being consumed by {@link Siesta.Test.ExtJS}. 

*/
Role('Siesta.Test.ExtJS.Component', {

    requires: ['waitFor'],

    methods: {

        /**
        * Waits until the main element of the passed component is the 'top' element in the DOM. The callback will receive the passed component instance.
        * 
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery 
        * @param {Function} callback The callback to call after the component becomes visible
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForComponentVisible: function (component, callback, scope, timeout) {
            component = this.normalizeComponent(component);
            
            if (!this.isExtJSComponent(component)) {
                throw 'Expected an Ext.Component, got: ' + component;
            }

            var me = this;

            this.waitFor({
                method          : function () { var el = me.compToEl(component); return el && me.elementIsTop(el, true) && component; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentVisible',
                description     : ' component ' + component.id + ' to be visible'
            });
        },


        /**
        * Waits until the main element of the passed component is not visible. The callback will receive the passed component instance.
        * 
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery 
        * @param {Function} callback The callback to call after the component becomes not visible
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForComponentNotVisible: function (component, callback, scope, timeout) {
            component = this.normalizeComponent(component);

            if (!this.isExtJSComponent(component)) {
                throw 'Expected an Ext.Component, got: ' + component;
            }

            var me = this;

            this.waitFor({
                method          : function () { return component.el && !me.isElementVisible(component.el) && component; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentNotVisible',
                description     : ' component ' + component.id + ' to not be visible'
            });
        },


        /**
        * Waits until Ext.ComponentQuery detects some results from the passed query parameter. The callback will receive the result of the query.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} query The component query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForComponentQuery: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout = scope
                scope = callback
                callback = root
                root = this.getExt().ComponentQuery
            }

            this.waitFor({
                method      : function () {
                    var result = root.query(query);
                    return result.length > 0 ? result : false;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForComponentQuery',
                description     : ' component query "' + query + '"'
            });
        },

        /**
        * Waits until {@link Siesta.Test.ExtJSCore#compositeQuery} detects some results from the passed query parameter. The callback will receive the result of the query.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} query The composite query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback 
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForCompositeQuery: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            var me = this;

            me.waitFor({
                method      : function () {
                    var result = me.compositeQuery(query, root, true);
                    
                    return result.length > 0 ? result : false;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                
                assertionName   : 'waitForCompositeQuery',
                description     : ' composite query "' + query + '"'
            });
        },
        
        
        /**
        * Waits until {@link Siesta.Test.ExtJSCore#compositeQuery} does not detects any results from the passed query parameter.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} query The composite query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback 
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForCompositeQueryNotFound: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            var me = this;

            me.waitFor({
                method      : function () {
                    var result = me.compositeQuery(query, root, true);
                    
                    return result.length > 0 ? false : true;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                
                assertionName   : 'waitForCompositeQueryNotFound',
                description     : ' composite query "' + query + '" to return empty array'
            });
        },
        


        /**
        * Shorthand alias for {@link #waitForComponentQuery}
        * 
        * @param {String} query The component query phrase
        * @param {Ext.Container} root The container to start a component query from
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForCQ: function () {
            this.waitForComponentQuery.apply(this, arguments);
        },


        /**
        * Alias for {@link #waitForComponentQueryNotFound}
        * 
        * @param {String} query
        * @param {Function} callback
        * @param {Object} scope
        * @param {Number} timeout
        */
        waitForCQNotFound: function () {
            this.waitForComponentQueryNotFound.apply(this, arguments);
        },


        /**
        * Waits until Ext.ComponentQuery from the passed query parameter is no longer found, and then calls the callback supplied.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The component query selector
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQueryNotFound: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            this.waitFor({
                method      : function () {
                    var result = root.query(query);
                    return result.length === 0 && result;
                },
                callback    : callback,
                scope       : scope, 
                timeout     : timeout,
                assertionName   : 'waitForComponentQueryNotFound',
                description     : ' component query: ' + query + ' to return empty'
            });
        },


        /**
        * Alias for {@link #waitForComponentQueryVisible}
        * 
        * @param {String} query
        * @param {Function} callback
        * @param {Object} scope
        * @param {Number} timeout
        */
        waitForCQVisible: function () {
            this.waitForComponentQueryVisible.apply(this, arguments);
        },

        /**
         * Alias for {@link #waitForComponentQueryNotVisible}
         *
         * @param {String} query
         * @param {Function} callback
         * @param {Object} scope
         * @param {Number} timeout
         */
        waitForCQNotVisible: function () {
            this.waitForComponentQueryNotVisible.apply(this, arguments);
        },

        /**
        * Waits until all results of the Ext.ComponentQuery are detected and visible.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The component query selector
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQueryVisible: function (query, root, callback, scope, timeout) {
            var me  = this,
                Ext = me.getExt();

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = Ext.ComponentQuery
            }

            this.waitFor({
                method      : function () {
                    var result = root.query(query),
                        allVisible = true;

                    if (result.length > 0) {
                        Joose.A.each(result, function (c) {
                            if (!c.rendered || !me.isElementVisible(c)) {
                                allVisible = false;
                                return false;
                            }
                        });
                        return allVisible && result;
                    } else {
                        return false;
                    }
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForComponentQueryVisible',
                description     : ' component query: ' + query + ' to return a visible component'
            });
        },

        /**
         * Waits until the result of the Ext.ComponentQuery is either empty, or the found component(s) is hidden.
         *
         * The "root" argument of this method can be omitted.
         *
         * @param {String} query The component query selector
         * @param {Ext.Container} root The container to start a component query from. Optional
         * @param {Function} callback The callback to call after the xtype has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForComponentQueryNotVisible: function (query, root, callback, scope, timeout) {
            var me  = this,
                Ext = me.getExt();

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = Ext.ComponentQuery
            }

            this.waitFor({
                method          : function () {
                    var result = root.query(query),
                        allHidden = true;

                    if (result.length > 0) {
                        Joose.A.each(result, function (c) {
                            if (c.rendered && c.isVisible()) {
                                allHidden = false;
                                return false;
                            }
                        });
                        return allHidden && result;
                    } else {
                        return true;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentQueryVisible',
                description     : ' component query: ' + query + ' to return a hidden/missing component'
            });
        },

        /**
        * Waits until the a component with the specified xtype can be detected by a simple ComponentQuery.
        * 
        * The "root" argument of this method can be omitted.
        * 
        * @param {String} xtype The component xtype to look for.
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForXType: function (xtype, root, callback, scope, timeout) {
            this.waitForComponentQuery(xtype, root, callback, scope, timeout);
        },

        /**
        * Waits until the a component with the specified xtype can be detected by a simple ComponentQuery.
        * 
        * @param {String} component The class name to wait for.
        * @param {Boolean} rendered true to also wait for the component to be rendered
        * @param {Function} callback The callback to call after the component has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
        */
        waitForComponent: function (component, rendered, callback, scope, timeout) {
            var Ext         = this.getExt();
            var xtype
            
            if (Ext.isString(component)) {
                xtype = Ext.ClassManager.get(component).xtype;
            } else {
                xtype = component.xtype;
            }

            if (rendered) {
                xtype = xtype + '[rendered]';
            }

            this.waitForXType(xtype, callback, scope, timeout);
        },

        /**
        * This assertion passes when the passed width and height matches the result of component.getSize()
        * 
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery 
        * @param {Int} width
        * @param {Int} height
        * @param {String} [description] The description of the assertion
        */
        hasSize: function (component, width, height, description) {
            component = this.normalizeComponent(component);
            this.isDeeply(component.getSize(), { width: width, height: height }, description);
        },

        /**
        * This assertion passes when the passed x and y matches the result of component.getPosition()
        * 
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery 
        * @param {Int} x
        * @param {Int} y
        * @param {String} [description] The description of the assertion
        */
        hasPosition: function (component, x, y, description) {
            component = this.normalizeComponent(component);
            this.isDeeply(component.getPosition(), [x, y], description);
        },
        
        
        /**
         * This assertion accepts variable number of Ext.Component instances (can be also provided as component query string).
         * Then it calls their "destroy" method and verifies that:
         * - there were no exceptions during destroy
         * - that each component was actually destoyed (since destroy can be canceled in the "beforedestroy" event listener)  
         * 
         * @param {Ext.Component/Array[Ext.Component]/String} components A single instance of Ext.Component, an array of such or a string with component query 
         * @param {String} [description] The description of the assertion
         */
        destroysOk : function (components, description) {
            var Ext     = this.Ext();
            
            if (this.typeOf(components) != 'Array') {
                if (this.typeOf(components) == 'String') 
                    components  = this.Ext().ComponentQuery.query(components);
                else
                    components  = [ components ]
            }
            
            if (!components.length) {
                this.fail(description, {
                    assertionName       : 'destroysOk',
                    annotation          : 'No components provided, or component query returned empty result'
                })
                
                return
            }
            
            var currentComp
            
            var e       = this.getExceptionCatcher()(function () {
                Joose.A.each(components, function (component) {
                    currentComp = component
                    
                    component.destroy() 
                })
            })
            
            if (e !== undefined) {
                this.fail(description, {
                    assertionName       : 'destroysOk',
                    got                 : e,
                    gotDesc             : 'Exception',
                    annotation          : 'Exception thrown while calling "destroy" method of ' + currentComp.id
                })
                
                return
            }
            
            var me      = this
            
            var allDestroyed = Joose.A.each(components, function (component) {
                //          ExtJS                             ST
                if (!(component.isDestroyed || component.destroy == Ext.emptyFn)) {
                    me.fail(description, {
                        assertionName       : 'destroysOk',
                        annotation          : 'Component [' + component.id + '] was not destroyed (probably destroy was canceled in the `beforedestroy` listener)'
                    })
                    
                    return false
                } 
            })
            
            if (allDestroyed === false) return
            
            this.pass(description, {
                descTpl     : 'All passed components were destroyed ok'
            })
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Grid

This is a mixin, with helper methods for testing functionality relating to ExtJS grids. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Grid', {
    
    requires        : [ 'waitFor', 'pass', 'fail', 'typeOf' ],
    
    
    methods : {
        /**
         * Waits for the rows of a gridpanel or tree panel to render and then calls the supplied callback. Please note, that if the store of the grid has no records,
         * the condition for this waiter will never be fullfilled.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Function} callback A function to call when the condition has been met.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForRowsVisible : function(panel, callback, scope, timeout) {
            if (typeof panel === 'function') {
                timeout = scope;
                scope = callback;
                callback = panel;
                panel = this.cq1('tablepanel');
            }

            var cmp = this.normalizeComponent(panel, true);
            var me = this;

            if (!cmp && typeof panel === 'string') {
                // Make sure CQ returns a result first
                this.waitForCQ(panel, function(result) { this.waitForRowsVisible(result[0], callback, scope, timeout); }, this);
            } else {
                var checkerFn;

                // Handle case of locking grid
                if(cmp.normalGrid) {
                    var selector = cmp.normalGrid.getView().itemSelector;
                    checkerFn = function() {
                        if (!cmp.rendered || !cmp.normalGrid.rendered || !cmp.lockedGrid.rendered) return;
                         
                        var lockedResult = this.$(selector, cmp.lockedGrid.el.dom); 
                        var normalResult = this.$(selector, cmp.normalGrid.el.dom); 
                        
                        if (lockedResult.length > 0 && normalResult.length > 0) {
                            return {
                                lockedRows : lockedResult,
                                normalRows : normalResult
                            };
                        }
                    }
                } else {
                    var selector = cmp.getView().itemSelector;
                    checkerFn = function() {
                        if (!cmp.rendered) return;
                         
                        var result = this.$(selector, cmp.el.dom); 
                        
                        if (result.length > 0) {
                            return result;
                        }
                    }
                }


                this.waitFor({
                    method          : checkerFn, 
                    callback        : callback,
                    scope           : scope,
                    timeout         : timeout,
                    assertionName   : 'waitForRowsVisible',
                    description     : ' rows to show for panel with id "' + cmp.id + '"'
                });
            }
        },

        /**
         * Utility method which returns the first grid row element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @return {Ext.Element} The element of first row of grid.
         */
        getFirstRow : function(grid) {
            grid = this.normalizeComponent(grid);
            var Ext = this.getExt();
            return grid.el.select(grid.getView().itemSelector).item(0);
        },

        /**
         * Utility method which returns the first grid cell element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * 
         * @return {HTMLElement} The element of first cell of grid.
         */
        getFirstCell : function(panel) {
            panel = this.normalizeComponent(panel);
            return this.getCell(panel, 0, 0);
        },

        /**
         * Utility method which returns a grid row element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} index The row index
         */
        getRow : function(grid, index) {
            grid = this.normalizeComponent(grid);
            
            return grid.el.select(grid.getView().itemSelector).item(index);
        },

        /**
         * Utility method which returns the cell at the supplied row and col position.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * @param {Int} column The column index
         * 
         * @return {HTMLElement} The element of the grid cell at specified position.
         */
        getCell : function(grid, row, col) {
            grid = this.normalizeComponent(grid);
            var rowEl = this.getRow(grid, row);
            return rowEl.child('td:nth-child(' + String(col+1) + ')');
        },

        /**
         * Utility method which returns the last cell for the supplied row.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * 
         * @return {HTMLElement} The element of the grid cell at specified position.
         */
        getLastCellInRow : function(grid, row) {
            grid = this.normalizeComponent(grid);
            return this.getCell(grid, row, grid.headerCt.getColumnCount() - 1);
        },

        /**
         * This assertion passes if the passed string is found in the passed grid's cell element.
         * 
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * @param {Int} column The column index
         * @param {String/RegExp} string The string to find or RegExp to match
         * @param {String} [description] The description for the assertion
         */
        matchGridCellContent : function(grid, rowIndex, colIndex, string, description) {
            grid = this.normalizeComponent(grid);
            
            var view = grid.getView(),
                cell = this.getCell(grid, rowIndex, colIndex).child('div');

            var isRegExp    = this.typeOf(string) == 'RegExp';
            var content     = cell.dom.innerHTML;
                
            if (isRegExp ? string.test(content) : content.indexOf(string) != -1) {
                this.pass(description, {
                    descTpl     : isRegExp ? 'Cell content {content} matches regexp {string}' : 'Cell content {content} has a string {string}',
                    content     : content,
                    string      : string
                });
            } else {
                this.fail(description, {
                    assertionName   : 'matchGridCellContent',
                    
                    got         : cell.dom.innerHTML,
                    gotDesc     : 'Cell content',
                    
                    need        : string,
                    needDesc    : 'String matching',
                    
                    annotation  : 'Row index: ' + rowIndex + ', column index: ' + colIndex
                });
            }
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.DataView

This is a mixin, with helper methods for testing functionality relating to ExtJS dataviews. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.DataView', {
    
    requires        : [ 'waitFor', 'getExt' ],
    
    
    methods : {
        /**
         * Waits for the items of a dataview to render and then calls the supplied callback.
         * @param {Ext.view.View/String} view An Ext.view.View instance or a ComponentQuery 
         * @param {Function} callback A function to call when the condition has been met.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForViewRendered : function(view, callback, scope, timeout) {
            view = this.normalizeComponent(view);
            var hasItems    = view.store.getCount() > 0

            this.waitFor({
                method      : function() { return hasItems ? !!view.getNode(0) : view.rendered }, 
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForViewRendered',
                description     : ' view ' + view.id + ' to render'
            });
        },

        /**
         * Utility method which returns the first view element.
         * 
         * @param {Ext.view.View/String} view An Ext.view.View instance or a ComponentQuery 
         * @return {Ext.Element} The first element of the view
         */
        getFirstItem : function(view) {
            view = this.normalizeComponent(view);

            var Ext = this.getExt();
            return Ext.get(view.getNode(0));
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Element

This is a mixin, with helper methods for testing functionality relating to DOM elements. This mixin is consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Element', {
    
    methods : {
        /**
         * Passes if the passed element has the expected region.
         * 
         * @param {Ext.Element} el The element
         * @param {Ext.util.Region} region The region to compare to.
         * @param {String} [description] The description of the assertion
         */
        hasRegion : function(el, region, description) {
            var elRegion = el.getRegion();

            this.is(elRegion["top"], region["top"], description + ' (top)');
            this.is(elRegion["right"], region["right"], description + ' (right)');
            this.is(elRegion["bottom"], region["bottom"], description + ' (bottom)');
            this.is(elRegion["left"], region["left"], description + ' (left)');
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.FormField

This is a mixin, with helper methods for testing functionality relating to Ext.form.Field class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.FormField', {
    
    methods : {
        /**
         * Passes if the passed Field has the expected value.
         * 
         * @param {Ext.form.field.Field/String} field A form field or a ComponentQuery
         * @param {Mixed} value The value to compare to.
         * @param {String} [description] The description of the assertion
         */
        fieldHasValue : function(field, value, description) {
            field = this.normalizeComponent(field);
            this.is(field.getValue(), value, description);
        },

        /*
         * @deprecated Use fieldHasValue instead.
         */
        hasValue : function() { this.fieldHasValue.apply(this, arguments); },

        /**
         * Passes if the passed Field has no value ("" or null).
         * 
         * @param {Ext.form.field.Field/String} field A form field or a ComponentQuery
         * @param {String} [description] The description of the assertion
         */
        isFieldEmpty : function(field, description) {
            field = this.normalizeComponent(field);
            var val = field.getValue();
            this.ok(val === null || val === "", description);
        },

        /*
         * @deprecated Use isFieldEmpty instead.
        */
        isEmpty : function() { this.isFieldEmpty.apply(this, arguments); }
    }
});
;
/**

@class Siesta.Test.TextSelection

This is a mixin providing text selection functionality.

*/
Role('Siesta.Test.TextSelection', {
    
    methods : {
        /**
         * Utility method which returns the selected text in the passed element or in the document
         * @param {Siesta.Test.ActionTarget} The element
         * @return {String} The selected text
         */
        getSelectedText : function (el){
            el = this.normalizeElement(el);
            
            if ('selectionStart' in el) {
                return el.value.substring(el.selectionStart, el.selectionEnd);
            }

            var win = this.global,
                doc = win.document;
            
            if(win.getSelection){ 
		        return win.getSelection().toString(); 
            } 
            else if(doc.getSelection){ 
                return doc.getSelection(); 
            } 
            else if(doc.selection){ 
                return doc.selection.createRange().text; 
            } 
        },

        /**
         * Utility method which selects text in the passed element (should be an input element).
         * @param {Siesta.Test.ActionTarget} The element
         * @param {Int} start (optional) The selection start index
         * @param {Int} end (optional) The selection end index
         */
        selectText : function(el, start, end){
            el = this.normalizeElement(el);

            var v = el.value || el.innerHTML,
                doFocus = true;

            if (v.length > 0) {
                start = start === undefined ? 0 : start;
                end = end === undefined ? v.length : end;
                if (el.setSelectionRange) {
                    el.setSelectionRange(start, end);
                }
                else if(el.createTextRange) {
                    var R = el.createTextRange();
                    R.moveStart('character', start);
                    R.moveEnd('character', end - v.length);
                    R.select();
                }
                doFocus = $.browser.mozilla || $.browser.opera;
            }
            if (doFocus) {
                this.focus(el);
            }
        }
    }
})
;
/**
@class Siesta.Test.Element

This is a mixin, with helper methods for testing functionality relating to DOM elements. This mixin is consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Element', {
    
    requires    : [
        'typeOf',
        'chain',
        'normalizeElement'
    ],
    
    methods : {
        
        /**
         * Utility method which returns the center of a passed element. The coordinates are by default relative to the
         * containing document of the element (so for example if the element is inside of the nested iframe, coordinates
         * will be "local" to that iframe element). To get coordinates relative to the test iframe ("global" coordinates), 
         * pass `local` as `false`.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to find the center of.
         * @param {Boolean} [local] Pass `true` means coordinates are relative to the containing document. This is the default value. 
         * Pass `false` to make sure the coordinates are global to the test window.
         * 
         * @return {Array} The array first element of which is the `x` coordinate and 2nd - `y` 
         */
        findCenter : function (target, local) {
            return this.getTargetCoordinate(target, local);
        },


        normalizeOffset : function (offset, $el) {
            var parts;
            
            if (this.typeOf(offset) == 'Function') offset = offset.call(this)

            offset              = offset || [ '50%', '50%' ];

            if (typeof (offset[ 0 ]) === 'string') {
                parts = offset[ 0 ].split('%');
                offset[ 0 ]     = parseInt(offset[ 0 ].match(/\d+/)[ 0 ], 10) * $el.outerWidth() / 100;

                if (parts[1]) {
                    offset[ 0 ]     += parseInt(parts[ 1 ]);
                }
            }

            if (typeof (offset[ 1 ]) === 'string') {
                parts = offset[ 1 ].split('%');
                offset[ 1 ]     = parseInt(offset[ 1 ].match(/\d+/)[ 0 ], 10) * $el.outerHeight() / 100;

                if (parts[1]) {
                    offset[ 1 ]     += parseInt(parts[ 1 ]);
                }
            }

            return offset
        },

        
        getTargetCoordinate : function (target, local, offset) {
            var normalizedEl    = this.normalizeElement(target),
                $normalizedEl   = this.$(normalizedEl),
                bodyOffset      = $normalizedEl.offset(),
                elDoc           = normalizedEl.ownerDocument,
                $doc            = this.$(elDoc),
                xy              = [ bodyOffset.left - $doc.scrollLeft(), bodyOffset.top - $doc.scrollTop() ];

            offset              = this.normalizeOffset(offset, $normalizedEl)

            xy[ 0 ]             += offset[ 0 ];
            xy[ 1 ]             += offset[ 1 ];

            if (local === false) {
                var elWindow    = elDoc.defaultView || elDoc.parentWindow;

                // Potentially we're interacting with an element inside a nested frame, which means the coordinates are local to that frame
                if (elWindow !== this.global) {
                    var offsetsToTop    = this.$(elWindow.frameElement).offset();

                    xy[ 0 ]     += offsetsToTop.left;
                    xy[ 1 ]     += offsetsToTop.top;
                }
            }

            return xy;
        },

        /**
         * Returns true if the element is visible, checking jQuery :visible selector + style visibility value.
         * 
         * @param {Siesta.Test.ActionTarget} el The element 
         * @return {Boolean}
         */
        isElementVisible : function(el) {
            el          = this.normalizeElement(el);
            
            if (el) {
                // Jquery :visible doesn't handle SVG/VML, so manual check
                if (window.SVGElement && el instanceof this.global.SVGElement) return el.style.display !== 'none' && el.style.visibility !== 'hidden'
                
                // Jquery :visible doesn't take visibility into account
                return this.$(el).is(':visible') && (!el.style || el.style.visibility !== 'hidden')
            }
            
            return false
        },

        /**
         * Passes if the innerHTML of the passed element contains the text passed
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match 
         * @param {String} [description] The description for the assertion
         */
        contentLike : function(el, text, description) {
            el = this.normalizeElement(el);

            this.like(el.innerHTML, text, description);
        },

        /**
         * Passes if the innerHTML of the passed element does not contain the text passed
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match 
         * @param {String} [description] The description for the assertion
         */
        contentNotLike : function(el, text, description) {
            el = this.normalizeElement(el);

            this.unlike(el.innerHTML, text, description);
        },

        /**
         * Waits until the innerHTML of the passed element contains the text passed
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match 
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForContentLike : function(el, text, callback, scope, timeout) {
            el = this.normalizeElement(el);

            this.waitFor({
                method      : function() { return el.innerHTML.match(text); }, 
                callback    : callback,
                scope       : scope, 
                timeout     : timeout,
                assertionName   : 'waitForContentLike',
                description     : ' element content "' + text + '" to appear'
            });
        },

        /**
         * Waits until the innerHTML of the passed element does not contain the text passed
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match 
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForContentNotLike : function(el, text, callback, scope, timeout) {
            el = this.normalizeElement(el);

            this.waitFor({
                method          : function() { return !el.innerHTML.match(text); }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForContentNotLike',
                description     : ' element content "' + text + '" to disappear'
            });
        },

        /**
         * Performs clicks, double clicks, right clicks and drags at random coordinates within the passed element.
         * While doing all these random actions it also tracks the number of exceptions thrown and reports a failure
         * if there were some. Otherwise reports a passed assertion.
         * 
         * Use this assertion to "stress-test" your component, making sure it will work correctly in various unexpected 
         * interaction scenarious.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to upon which to unleash the "monkey".
         * @param {Int} nbrInteractions The number of random interactions to perform. 
         * @param {String} [description] The description for the assertion
         * @param {Function} callback The callback to call after all actions were completed
         * @param {Object} scope The scope for the callback
         */
        monkeyTest : function(el, nbrInteractions, description, callback, scope) {
            el              = this.normalizeElement(el) || this.global.document.body;
            nbrInteractions = nbrInteractions || 30;

            var me          = this,
                offset      = me.$(el).offset(),
                right       = offset.left + me.$(el).width(),
                bottom      = offset.top + me.$(el).height();
                
            var actionLog   = []

            var queue       = new Siesta.Util.Queue({
                deferer         : me.originalSetTimeout,
                deferClearer    : me.originalClearTimeout,
                
                interval        : 50,
                
                observeTest     : this,
                
                processor   : function (data) {
                    if (me.nbrExceptions || me.failed) {
                        me.warn("Monkey action log:" + JSON2.stringify(actionLog))
                        // do not continue if the test has detected an exception thrown
                        queue.abort()
                    } else {
                        var async       = me.beginAsync(null, function (test) {
                            test.fail("Monkey testing action did not complete properly - probably some exception was thrown")
                            me.warn("Monkey action log:" + JSON.stringify(actionLog))
                            
                            return true
                        });
                        
                        var next        = data.next
                        
                        data.next       = function () {
                            me.endAsync(async)
                            
                            next()
                        }
                        
                        data.action(data)
                    }
                }
            });
            
            for (var i = 0; i < nbrInteractions; i++) {
                var xy = [ me.randomBetween(offset.left, right), me.randomBetween(offset.top, bottom) ];

                switch (Math.floor(Math.random() * 4)) {
                    case 0:
                        actionLog.push({
                            'click' : xy
                        })
                        
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.click(data.xy, data.next)
                            },
                            xy              : xy
                        });
                    break;

                    case 1:
                        actionLog.push({
                            'doubleclick'   : xy
                        })
                        
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.doubleClick(data.xy, data.next)
                            },
                            xy              : xy
                        });
                    break;

                    case 2:
                        // Make sure right-clicking can be done on this platform (just do 'click' on mobile devices)
                        if ("oncontextmenu" in window) {
                            actionLog.push({
                                'rightclick'    : xy
                            })
                        } else {
                            actionLog.push({
                                'click'    : xy
                            })
                        }

                        queue.addAsyncStep({
                            action          : function (data) {
                                if ("oncontextmenu" in window) {
                                    me.rightClick(data.xy, data.next)
                                } else {
                                    me.click(data.xy, data.next)
                                }
                            },
                            xy              : xy
                        });
                    break;

                    case 3:
                        var dragTo      = [ me.randomBetween(offset.left, right), me.randomBetween(offset.top, bottom) ]
                        
                        actionLog.push({
                            action  : 'drag',
                            target  : xy,
                            to      : dragTo
                        })
                        
                        queue.addAsyncStep({
                            action          : function (data) {
                                me.drag(data.dragFrom, data.dragTo, null, data.next)
                            },
                            dragFrom        : xy,
                            dragTo          : dragTo
                        });
                    break;
                }
            }
            
            var checkerActivated    = false
            
            var assertionChecker    = function () {
                checkerActivated    = true
                
                if (me.nbrExceptions) me.warn("Monkey action log:" + JSON.stringify(actionLog))
                
                me.is(me.nbrExceptions, 0, description || '0 exceptions thrown during monkey test');
            }
            
            this.on('beforetestfinalizeearly', assertionChecker) 

            queue.run(function () {
                if (!checkerActivated) {
                    me.un('beforetestfinalizeearly', assertionChecker)
                    
                    assertionChecker()
                }
                
                me.processCallbackFromTest(callback, null, scope || me)
            });
        },

        /**
         * Passes if the element has the supplied CSS classname 
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} cls The class name to check for
         * @param {String} [description] The description for the assertion
         */
        hasCls : function (el, cls, description) {
            el = this.normalizeElement(el);
            
            if (this.$(el).hasClass(cls)) {
                this.pass(description, {
                    descTpl     : 'Element has CSS class {cls}',
                    cls         : cls
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasCls',
                    
                    got         : el.className,
                    gotDesc     : 'Classes of element',
                    need        : cls,
                    needDesc    : 'Need CSS class'
                })
            }
        },
        
        
        /**
         * Passes if the element does not have the supplied CSS classname 
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} cls The class name to check for
         * @param {String} [description] The description for the assertion
         */
        hasNotCls : function (el, cls, description) {
            el = this.normalizeElement(el);
            
            if (!this.$(el).hasClass(cls)) {
                this.pass(description, {
                    descTpl         : 'Element has no CSS class {cls}',
                    cls             : cls
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasNotCls',
                    got             : el.className,
                    gotDesc         : 'Classes of element',
                    annotation      : 'Element has the class [' + cls + ']'
                })
            }
        },

        /**
         * Passes if the element has the supplied style value
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} property The style property to check for
         * @param {String} value The style value to check for
         * @param {String} [description] The description for the assertion
         */
        hasStyle : function (el, property, value, description) {
            el = this.normalizeElement(el);
            
            if (this.$(el).css(property) === value) {
                this.pass(description, {
                    descTpl         : 'Element has correct {value} for CSS style {property}',
                    value           : value,
                    property        : property
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasStyle',
                    got             : this.$(el).css(property),
                    gotDesc         : 'Styles of element',
                    need            : value,
                    needDesc        : 'Need style'
                });
            }
        },
        
        
        /**
         * Passes if the element does not have the supplied style value
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} property The style property to check for
         * @param {String} value The style value to check for
         * @param {String} [description] The description for the assertion
         */
        hasNotStyle : function (el, property, value, description) {
            el = this.normalizeElement(el);
            
            if (this.$(el).css(property) !== value) {
                this.pass(description, {
                    descTpl         : 'Element has no value {value} for CSS style {property}',
                    value           : value,
                    property        : property
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasNotStyle',
                    got         : el.style.toString(),
                    gotDesc     : 'Style of element',
                    annotation  : 'Element has the style [' + property + ']'
                });
            }
        },
        
        /**
         * Waits for a certain CSS selector to be found at the passed XY coordinate, and calls the callback when found. 
         * The callback will receive the element from the passed XY coordinates.
         * 
         * @param {Array} xy The x and y coordinates to query
         * @param {String} selector The CSS selector to check for
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForSelectorAt : function(xy, selector, callback, scope, timeout) {
            if (!selector) throw 'A CSS selector must be supplied';
            
            var me      = this
            
            this.waitFor({
                method          : function() { 
                    var el = me.elementFromPoint(xy[0], xy[1], true);
                    
                    if (el && this.$(el).is(selector)) return el; 
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForSelectorAt',
                description     : ' selector "' + selector + '" to appear at: [' + xy.toString() + ']'
            });
        },

        /**
         * Waits for a certain CSS selector to be found at current cursor position, and calls the callback when found. 
         * The callback will receive the element found.
         * 
         * @param {String} selector The CSS selector to check for
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForSelectorAtCursor : function(selector, callback, scope, timeout) {
            this.waitForSelectorAt(this.currentPosition, selector, callback, scope, timeout);
        },

        /**
         * Waits for a certain CSS selector to be found in the DOM, and then calls the callback supplied.
         * The callback will receive the results of jQuery selector.
         * 
         * @param {String} selector The CSS selector to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForSelector : function(selector, root, callback, scope, timeout) {
            
            if (!selector) throw 'A CSS selector must be supplied';

            if (jQuery.isFunction(root)) {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            } 

            if (root) root  = this.normalizeElement(root);

            this.waitFor({
                method          : function() { 
                    var result = this.$(selector, root); 
                    if (result.length > 0) return result;
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForSelector',
                description     : ' selector "' + selector + '" to appear'
            });
        },
        
        
        /**
         * Waits till all the CSS selectors from the provided array to be found in the DOM, and then calls the callback supplied.
         * 
         * @param {String[]} selectors The array of CSS selectors to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForSelectors : function(selectors, root, callback, scope, timeout) {
            if (selectors.length < 1) throw 'An array of CSS selectors must be supplied';

            if (jQuery.isFunction(root)) {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            } 

            if (root) root  = this.normalizeElement(root);
            
            var me          = this

            this.waitFor({
                method      :  function () {
                    var allPresent  = true
                    
                    Joose.A.each(selectors, function (selector) {
                        if (me.$(selector, root).length == 0) {
                            allPresent = false
                            // stop iteration
                            return false
                        }
                    })
                    
                    return allPresent
                }, 
                callback    : callback,
                scope       : scope, 
                timeout     : timeout,
                assertionName   : 'waitForSelectors',
                description     : ' selectors "' + selectors + '" to appear'
            });
        },
        
        

        /**
         * Waits for a certain CSS selector to not be found in the DOM, and then calls the callback supplied.
         * 
         * @param {String} selector The CSS selector to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForSelectorNotFound : function(selector, root, callback, scope, timeout) {
            if (!selector) throw 'A CSS selector must be supplied';

            if (jQuery.isFunction(root)) {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            } 

            if (root) root  = this.normalizeElement(root);

            this.waitFor({
                method          : function() { return this.$(selector, root).length === 0; }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForSelectorNotFound',
                description     : ' selector "' + selector + '" to disappear'
            });
        },
        
        
        /**
         * Waits until the passed element becomes "visible" in the DOM and calls the provided callback.
         * Please note, that "visible" means element will just have a DOM node, and still may be hidden by another visible element.
         * 
         * The callback will receive the passed element as the 1st argument.
         * 
         * See also {@link #waitForElementTop} method.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForElementVisible : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);
            var me      = this;

            this.waitFor({
                method          : function() { return me.isElementVisible(el) && el; }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForElementVisible',
                description     : ' element "' + el.toString() + '" to appear'
            });
        },

        /**
         * Waits until the passed element is becomes not "visible" in the DOM and call the provided callback.
         * Please note, that "visible" means element will just have a DOM node, and still may be hidden by another visible element.
         * 
         * The callback will receive the passed element as the 1st argument.
         * 
         * See also {@link #waitForElementNotTop} method.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForElementNotVisible : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);
            var me      = this;

            this.waitFor({
                method          : function() { return !me.isElementVisible(el) && el; }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForElementNotVisible',
                description     : ' element "' + el.toString() + '" to disappear'
            });
        },
        
        
        /**
         * Waits until the passed element is the 'top' element in the DOM and call the provided callback.
         * 
         * The callback will receive the passed element as the 1st argument.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call 
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForElementTop : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);
            var me      = this;

            this.waitFor({
                method          : function() { return me.elementIsTop(el, true) && el; }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForElementTop',
                description     : ' element "' + el.toString() + '" to be the top element at its position'
            });
        },

        /**
         * Waits until the passed element is not the 'top' element in the DOM and calls the provided callback with the element found.
         * 
         * The callback will receive the actual top element.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForElementNotTop : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);
            
            var me      = this

            this.waitFor({
                method          : function() {    
                    if (!me.elementIsTop(el, true)) {
                        var center = me.findCenter(el);
                        return me.elementFromPoint(center[0], center[1], true);
                    }        
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForElementNotTop',
                description     : ' element "' + el.toString() + '" to not be the top element at its position'
            });
        },

        /**
         * Passes if the element is visible.
         * @param {Siesta.Test.ActionTarget} el The element 
         * @param {String} [description] The description for the assertion
         */
        elementIsVisible : function(el, description) {
            el = this.normalizeElement(el);
            this.ok(this.isElementVisible(el), description);
        },

        /**
         * Passes if the element is not visible.
         * @param {Siesta.Test.ActionTarget} el The element 
         * @param {String} [description] The description for the assertion
         */
        elementIsNotVisible : function(el, description) {
            el = this.normalizeElement(el);
            this.notOk(this.isElementVisible(el), description);
        },

        /**
         * Utility method which checks if the passed method is the 'top' element at its position. "Top" element means,
         * that element is not covered with any other elements. 
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @return {Boolean} true if the element is the top element.
         */
        elementIsTop : function(el, allowChildren) {
            el              = this.normalizeElement(el);

            var elDoc       = el.ownerDocument,
                center      = this.findCenter(el),
                foundEl     = elDoc.elementFromPoint(center[0], center[1]);
            
            return foundEl && (foundEl === el || (allowChildren && this.$(foundEl).closest(el).length > 0));
        },
        
        /**
         * Passes if the element is found at the supplied xy coordinates.
         * 
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Array} xy The xy coordinate to query.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        elementIsAt : function(el, xy, allowChildren, description) {
            el              = this.normalizeElement(el);
            
            var foundEl     = this.elementFromPoint(xy[0], xy[1], true);
            
            if (!foundEl) {
                this.fail(description, {
                    assertionName       : 'elementIsAt',
                    got                 : { x: xy[0], y : xy[1] },
                    gotDesc             : 'Position',
                    annotation          : 'No element found at the specified position'
                });
            } else if (allowChildren) {
                if (foundEl === el || this.$(foundEl).closest(el).length > 0) {
                    this.pass(description, {
                        descTpl         : 'DOM element or its child is at [ {x}, {y} ] coordinates',
                        x               : xy[ 0 ],
                        y               : xy[ 1 ]
                    });
                } else {
                    this.fail(description, {
                        assertionName   : 'elementIsAt',
                        got             : foundEl,
                        gotDesc         : 'Top element',
                        need            : el,
                        needDesc        : 'Need exactly this or its child',
                        annotation      : 'Passed element is not the top-most one and not the child of one'
                    });
                }
            } else {
                if (foundEl === el) {
                    this.pass(description, {
                        descTpl         : 'DOM element is at [ {x}, {y} ] coordinates',
                        x               : xy[ 0 ],
                        y               : xy[ 1 ]
                    });
                } else {
                    this.fail(description, {
                        assertionName   : 'elementIsAt',
                        got             : foundEl,
                        gotDesc         : 'Top element',
                        need            : el,
                        needDesc        : 'Should be',
                        annotation      : 'Passed element is not the top-most one'
                    });
                }
            }
        },

        /**
         * Passes if the element is the top element (using its center xy coordinates). "Top" element means,
         * that element is not covered with any other elements. 
         * 
         * This assertion can be used for example to test, that some element, that appears only when mouse hovers some other element is accessible by user
         * with mouse (which is not always true because of various z-index issues). 
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         * @param {Boolean} strict true to check all four corners of the element. False to only check at element center.
         */
        elementIsTopElement : function(el, allowChildren, description, strict) {
            el = this.normalizeElement(el);

            if (strict) {
                var o           = this.$(el).offset();
                var region      = { 
                    top     : o.top,
                    right   : o.left + this.$(el).outerWidth(),
                    bottom  : o.top + this.$(el).outerHeight(),
                    left    : o.left
                };

                this.elementIsAt(el, [region.left+1, region.top+1], allowChildren, description + ' (t-l)');
                this.elementIsAt(el, [region.left+1, region.bottom-1], allowChildren, description + ' (b-l)');
                this.elementIsAt(el, [region.right-1, region.top+1], allowChildren, description + ' (t-r)');
                this.elementIsAt(el, [region.right-1, region.bottom-1], allowChildren, description + ' (b-r)');
            } else {
                this.elementIsAt(el, this.findCenter(el), allowChildren, description);
            }
        },
        
        /**
         * Passes if the element is not the top element (using its center xy coordinates).
         * 
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        elementIsNotTopElement : function(el, allowChildren, description) {
            el              = this.normalizeElement(el);
            var center      = this.findCenter(el);
            
            var foundEl     = this.elementFromPoint(center[ 0 ], center[ 1 ], true);
            
            if (!foundEl) {
                this.pass(description, {
                    descTpl         : 'Element is not the top element on the screen'   
                });
                
                return
            }
            
            if (allowChildren) {
                this.ok(foundEl !== el && this.$(foundEl).closest(el).length === 0, description);
            } else {
                this.isnt(foundEl, el, description);
            }
        },

        /**
         * Passes if the element is found at the supplied xy coordinates.
         * 
         * @param {String} selector The selector to query for
         * @param {Array} xy The xy coordinate to query.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        selectorIsAt : function(selector, xy, description) {
            if (!selector) throw 'A CSS selector must be supplied';

            var foundEl = this.$(this.elementFromPoint(xy[0], xy[1], true));
            
            if (foundEl.has(selector).length > 0 || foundEl.closest(selector).length > 0) {
                this.pass(description, {
                    descTpl         : 'Found element matching CSS selector {selector} at [ {xy} ]',
                    selector        : selector,
                    xy              : xy
                });
            } else {
                this.fail(description, {
                    got             : foundEl[0].outerHTML ? foundEl[0].outerHTML : foundEl[0].innerHTML,
                    need            : 'Element matching ' + selector,
                    assertionName   : 'selectorIsAt',
                    annotation      : 'Passed selector does not match any selector at [' + xy + ']'
                });
            }
        },

        /**
         * Passes if the selector is found in the DOM
         * 
         * @param {String} selector The selector to query for
         * @param {String} [description] The description for the assertion
         */
        selectorExists : function(selector, description) {
            if (!selector) throw 'A CSS selector must be supplied';

            if (this.$(selector).length <= 0) {
                this.fail(description, 'No element matching the passed selector found: ' + selector);
            } else {
                this.pass(description, {
                    descTpl         : 'Found DOM element(s) matching CSS selector {selector}',
                    selector        : selector
                });
            } 
        },

        /**
         * Passes if the selector is not found in the DOM
         * 
         * @param {String} selector The selector to query for
         * @param {String} [description] The description for the assertion
         */
        selectorNotExists : function(selector, description) {
            if (this.$(selector).length > 0) {
                this.fail(description, 'Elements found matching the passed selector: ' + selector);
            } else {
                this.pass(description, {
                    descTpl         : 'Not found any DOM element(s) matching CSS selector {selector}',
                    selector        : selector
                });
            } 
        },

        /**
         * Waits until the passed scroll property of the element has changed. 
         * 
         * The callback will receive the new `scroll` value.
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} side 'left' or 'top'
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForScrollChange : function(el, side, callback, scope, timeout) {
            el                  = this.normalizeElement(el);
            var scrollProp      = 'scroll' + Joose.S.uppercaseFirst(side);
            var original        = el[scrollProp];

            this.waitFor({
                method          : function() { if (el[scrollProp] !== original) return el[scrollProp]; }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForScrollChange',
                description     : scrollProp  + ' + to change for element "' + el.toString()
            });
        },

        /**
         * Waits until the `scrollLeft` property of the element has changed. 
         * 
         * The callback will receive the new `scrollLeft` value.
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForScrollLeftChange : function(el, callback, scope, timeout) {
            this.waitForScrollChange(this.normalizeElement(el), 'left', callback, scope, timeout);
        },

        /**
         * Waits until the scrollTop property of the element has changed
         * 
         * The callback will receive the new `scrollTop` value.
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForScrollTopChange : function(el, callback, scope, timeout) {
            this.waitForScrollChange(this.normalizeElement(el), 'top', callback, scope, timeout);
        },
        
        
        /**
         * This method changes the "scrollTop" property of the dom element, then waits for the "scroll" event from it and calls the provided callback.
         * 
         * For example:
         * 

    // scroll the domEl to the 100px offset, wait for "scroll" event, call the callback
    t.scrollVerticallyTo(domEl, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         * 
    // scroll the domEl to the 100px offset, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollVerticallyTo(domEl, 100, 1000, function () { ... })
 
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newTop The value for the "scrollTop" property
         * @param {Number} [delay] Additional delay, this argument can be omitted
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         * 
         * @return {Number} The new value of the "scrollTop" property of the dom element
         */
        scrollVerticallyTo : function (el, newTop, delay, callback) {
            el                          = this.normalizeElement(el);
            
            if (this.typeOf(delay) != 'Number') {
                callback                = delay
                delay                   = null
            }
            
            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;
            
            var waiter                  = this.waitForEvent(el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)
                    
                    originalSetTimeout(function () {
                        me.endAsync(async)
                        
                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })
            
            var prevScrollTop   = el.scrollTop
            
            el.scrollTop        = newTop
            
            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollTop == prevScrollTop) {
                waiter.force()
            }
            
            // re-read the scrollTop value and return it (newTop can be too big for example and will be truncated)
            return el.scrollTop
        },
        
        
        /**
         * This method changes the "scrollLeft" property of the dom element, then waits for the "scroll" event from it and calls the provided callback.
         * 
         * For example:
         * 

    // scroll the domEl to the 100px offset, wait for "scroll" event, call the callback
    t.scrollHorizontallyTo(domEl, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         * 
    // scroll the domEl to the 100px offset, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollHorizontallyTo(domEl, 100, 1000, function () { ... })
 
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newLeft The value for the "scrollLeft" property
         * @param {Number} [delay] Additional delay, this argument can be omitted
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         * 
         * @return {Number} The new value of the "scrollLeft" property of the dom element
         */
        scrollHorizontallyTo : function (el, newLeft, delay, callback) {
            el                          = this.normalizeElement(el);
            
            if (this.typeOf(delay) != 'Number') {
                callback                = delay
                delay                   = null
            }
            
            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;
            
            var waiter                  = this.waitForEvent(el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)
                    
                    originalSetTimeout(function () {
                        me.endAsync(async)
                        
                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })
            
            var prevScrollLeft  = el.scrollLeft
            
            el.scrollLeft       = newLeft
            
            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollLeft == prevScrollLeft) {
                waiter.force()
            }
            
            // re-read the scrollLeft value and return it (newLeft can be too big for example and will be truncated)
            return el.scrollLeft
        },
        
        
        
        /**
         * This method accepts an array of the DOM elements and performs a mouse click on them, in order. After that, it calls the provided callback:
         * 
       
       t.chainClick([ el1, el2 ], function () {
            ...
       })
       
         * the elements can be also provided inline, w/o wrapping array:
       
       t.chainClick(el1, el2, function () {
            ...
       })
       
       
         * 
         * @param {Array[Siesta.Test.ActionTarget]} elements The array of elements to click
         * @param {Function} callback The function to call after clicking all elements
         */
        chainClick : function () {
            var args        = Array.prototype.concat.apply([], arguments)
            var callback
            
            if (this.typeOf(args[ args.length - 1 ]) == 'Function') callback = args.pop()
            
            // poor-man Array.flatten, with only 1 level of nesting support
            args            = Array.prototype.concat.apply([], args)
            
            var steps       = []
            
            Joose.A.each(args, function (arg) {
                steps.push({
                    action      : 'click',
                    target      : arg
                })
            })
            
            var me          = this
            
            if (callback) steps.push(function () {
                me.processCallbackFromTest(callback)
            })
            
            this.chain.apply(this, steps)
        },
        
        
        /**
         * This method is a wrapper around the {@link #chainClick}, it performs a click on the every element found with the DOM query.
         * 
         * You can specify the optional `root` element to start the query from:
         * 
         *      t.clickSelector('.my-grid .x-grid-row', someEl, function () {})
         *      
         * or omit it (query will start from the document):
         * 
         *      t.clickSelector('.my-grid .x-grid-row', function () {})
         *      
         * The provided callback will receive an array with DOM elements - result of query.
         * 
         * 
         * @param {String} selector The selector/xpath query
         * @param {Siesta.Test.ActionTarget} [root=document] The root of the query, defaults to the `document`. You can omit this parameter.
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        clickSelector : function (selector, root, callback, scope) {
            if (arguments.length > 1 && this.typeOf(arguments[ 1 ]) == 'Function') {
                scope       = callback;
                callback    = root;
                root        = null;
            }
           
            if (root) root = this.normalizeElement(root);
           
            // convert the result from jQuery dom query to a usual array 
            var result      = Joose.A.map(this.$(selector, root), function (el) { return el });
            
            this.chainClick(result, function () { callback && callback.call(scope || this, result) })
        },
        
        
        /**
         * This assertion passes when the DOM query with specified selector returns the expected number of elements
         * 
         * You can specify the optional `root` element to start the query from:
         * 
         *      t.selectorCountIs('.x-grid-row', grid, 5, "Grid has 5 rows")
         *      
         * or omit it (query will start from the document):
         * 
         *      t.selectorCountIs('.x-grid-row', 0, "No grid rows on the page")
         * 
         * @param {String} selector DOM query selector
         * @param {Siesta.Test.ActionTarget} [root] An optional root element to start the query from, if omited query will start from the document
         * @param {Number} count The expected number of elements in the query result
         * @param {String} [description] The description for the assertion
         */
        selectorCountIs : function (selector, root, count, description) {
            if (!selector) throw 'A CSS selector must be supplied';

            if (this.typeOf(root) == 'Number') {
                description     = count
                count           = root
                root            = null
            } else
                root            = this.normalizeElement(root)
            
            var inDOMCount  = this.$(selector, root).length
            
            if (inDOMCount != count) {
                this.fail(description, {
                    assertionName   : 'selectorCountIs',
                    descTpl         : 'Different number of elements matching the selector {selector} found',
                    selector        : selector,
                    got             : inDOMCount,
                    need            : count
                });
            } else {
                this.pass(description, {
                    descTpl         : 'Found exactly {count} elements matching matching CSS selector {selector}',
                    count           : count,
                    selector        : selector
                });
            } 
        },
        

        /**
         * Passes if the passed element is inside of the visible viewport
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        isInView : function (el, description) {
            if (this.elementIsInView(el))
                this.pass(description, {
                    descTpl         : 'Passed element is within the visible viewport'
                })
            else
                this.fail(description, {
                    assertionName   : 'isInView'
                })
        },

        /**
         * Returns true if the passed element is inside of the visible viewport
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         */
        elementIsInView : function(el) {
            el              = this.normalizeElement(el);

            var inView      = false;
            var offset      = this.$(el).offset();
            
            if (offset) {
                var docViewTop      = $(this.global).scrollTop();
                var docViewBottom   = docViewTop + $(this.global).height();

                var elemTop         = offset.top;
                var elemBottom      = elemTop + $(el).height();
                
                inView              = elemBottom >= docViewTop && elemTop <= docViewBottom;
            }
            
            return inView;
        },

        /**
         * Waits until element is inside in the visible viewport and then calls the supplied callback
         * 
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitUntilInView : function (el, callback, scope, timeout) {
            el              = this.normalizeElement(el);
            
            var me          = this;
            
            this.waitFor({
                method          : function() { return me.elementIsInView(el) && el; }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitUntilInView',
                description     : el.toString + ' to appear in the viewport'
            });
        },
        
        
        focus : function (el) {
            var prevIndex   = el.getAttribute('tabIndex')
            
            try {
                if (prevIndex == null) el.setAttribute('tabIndex', -1)
                el.focus() 
            } catch (e) {
            } finally {
                if (prevIndex == null)
                    el.removeAttribute('tabIndex')
                else
                    el.setAttribute('tabIndex', prevIndex)
            }
        },
        
        
        /**
         * Passes if the passed element has no content (whitespace will be trimmed)
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsEmpty : function (el, description) {
            el              = this.normalizeElement(el);

            if (el && this.isElementEmpty(el))
                this.pass(description, {
                    descTpl         : 'Passed element is empty'
                })
            else
                this.fail(description, {
                    assertionName   : 'elementIsEmpty'
                })
        },

        /**
         * Passes if the passed element has some non-whitespace content
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsNotEmpty : function (el, description) {
            el              = this.normalizeElement(el);

            if (el && !this.isElementEmpty(el))
                this.pass(description, {
                    descTpl         : 'Passed element is not empty'
                })
            else
                this.fail(description, {
                    assertionName   : 'elementIsNotEmpty'
                })
        },

        /**
         * Waits until the innerHTML of the passed element is empty (whitespace will be trimmed)
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementEmpty : function(el, callback, scope, timeout) {
            var me = this;
            el = this.normalizeElement(el);

            this.waitFor({
                method          : function() { return me.isElementEmpty(el); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementEmpty',
                description     : ' element to be empty'
            });
        },

        /**
         * Waits until the innerHTML of the passed element contains some non-whitespace text.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotEmpty : function(el, callback, scope, timeout) {
            var me = this;
            el = this.normalizeElement(el);

            this.waitFor({
                method          : function() { return !me.isElementEmpty(el); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotEmpty',
                description     : ' element to not be empty'
            });
        },

        isElementEmpty : function (el) {
            return !el.innerHTML.replace(/^\s+|\s+$/g, '');
        }
    }
});
;
/**
@class Siesta.Test.Browser
@extends Siesta.Test
@mixin Siesta.Test.Simulate.Event
@mixin Siesta.Test.TextSelection 
@mixin Siesta.Test.Simulate.Mouse
@mixin Siesta.Test.Simulate.Keyboard


A base class for testing a generic browser functionality. It has various DOM-related assertions, and is not optimized for any framework.

*/
Class('Siesta.Test.Browser', {
    
    isa         : Siesta.Test,
        
    does        :  [ 
        Siesta.Test.Simulate.Event,
        Siesta.Test.Simulate.Mouse,
        Siesta.Test.Simulate.Keyboard,
        Siesta.Test.Element,
        Siesta.Test.TextSelection
    ],

    has : {
        // this will be a shared array instance between all subtests
        // it should not be overwritten, instead modify individual elements:
        // NO: this.currentPosition = [ 1, 2 ]
        // YES: this.currentPosition[ 0 ] = 1
        // YES: this.currentPosition[ 1 ] = 2
        currentPosition         : {
           init : function () { return [ 0, 0 ]; }
        },
        
        forceDOMVisible         : false
    },

    methods : { 
        $ : function () {
            var local$ = $.rebindWindowContext(this.global);
            return local$.apply(this.global, arguments);
        },
        
        
        isEventPrevented : function (event) {
            // our custom property - takes highest priority
            if (this.typeOf(event.$defaultPrevented) == 'Boolean') return event.$defaultPrevented
            
            // W3c standards property
            if (this.typeOf(event.defaultPrevented) == 'Boolean') return event.defaultPrevented
            
            return event.returnValue === false
        },
        
        
        getElementPageRect : function (el, $el) {
            $el             = $el || this.$(el)
            
            var offset      = $el.offset()
            
            return new Siesta.Util.Rect({
                left        : offset.left,
                top         : offset.top,
                width       : $el.outerWidth(),
                height      : $el.outerHeight()
            })
        },
        
        
        elementHasScroller : function (el, $el) {
            $el             = $el || this.$(el)
                
            var hasX        = el.scrollWidth != el.clientWidth && $el.css('overflow-x') != 'visible'
            var hasY        = el.scrollHeight != el.clientHeight && $el.css('overflow-y') != 'visible'
            
            return hasX || hasY ? { x : hasX, y : hasY } : false
        },
        
        
        hasForcedIframe : function () {
            return Boolean(this.forceDOMVisible && (this.scopeProvider instanceof Scope.Provider.IFrame) && this.scopeProvider.iframe)
        },
        
        
        elementIsScrolledOut : function (el, offset) {
            var $el                 = this.$(el)
            
            var scrollableParents   = []
            var parent              = $el
            
            var body                = this.global.document.body
            
            while (parent = parent.parent(), parent.length && parent[ 0 ] != body) {
                var hasScroller     = this.elementHasScroller(parent[ 0 ], parent)
                
                if (hasScroller) scrollableParents.unshift({ hasScroller : hasScroller, $el : parent }) 
            }
            
            var $body               = this.$(body)
            var bodyOffset          = $body.offset()
            
            var currentRect         = new Siesta.Util.Rect({
                left        : bodyOffset.left + $body.scrollLeft(),
                top         : bodyOffset.top + $body.scrollTop(),
                width       : body.clientWidth,
                height      : body.clientHeight
            })
            
            for (var i = 0; i < scrollableParents.length; i++) {
                var hasScroller     = scrollableParents[ i ].hasScroller
                var $parent         = scrollableParents[ i ].$el
                
                if (hasScroller && hasScroller.x)
                    currentRect     = currentRect.cropLeftRight(this.getElementPageRect($parent[ 0 ], $parent))
                    
                if (currentRect.isEmpty()) return true
                    
                if (hasScroller && hasScroller.y)
                    currentRect     = currentRect.cropTopBottom(this.getElementPageRect($parent[ 0 ], $parent))
                    
                if (currentRect.isEmpty()) return true
            }
            
            var elPageRect          = this.getElementPageRect($el[ 0 ], $el)
            var finalRect           = currentRect.intersect(elPageRect)
            
            if (finalRect.isEmpty()) return true
            
            offset                  = this.normalizeOffset(offset, $el)
            
            return !finalRect.contains(elPageRect.left + offset[ 0 ], elPageRect.top + offset[ 1 ])
        },
        
        
        scrollTargetIntoView : function (target, offset) {
            // If element isn't visible, try to bring it into view
            if (this.elementIsScrolledOut(target, offset)) {
                // Required to handle the case where the body is scrolled
                target.scrollIntoView();

                this.$(target).scrollintoview({ duration : 0 });
            }
        },

        
        processSubTestConfig : function () {
            var res             = this.SUPERARG(arguments)
            var me              = this
            
            Joose.A.each([ 
                'currentPosition', 
                'actionDelay', 'afterActionDelay', 
                'dragDelay', 'moveCursorBetweenPoints', 'dragPrecision', 'overEls'
            ], function (name) {
                res[ name ]     = me[ name ]
            })
            
            res.simulateEventsWith  = me.getSimulateEventsWith()
            
            return res
        },
        
        
        // Normalizes the element to an HTML element. Every 'framework layer' will need to provide its own implementation
        // This implementation accepts either a CSS selector or an Array with xy coordinates.
        normalizeElement : function (el, allowMissing, shallow) {
            if (typeof el === 'string') {
                // DOM query
                var origEl  = el;
                el          = this.$(el)[ 0 ];
                
                if (!allowMissing && !el) {
                    this.warn('No DOM element found for CSS selector: ' + origEl)
                    throw 'No DOM element found for CSS selector: ' + origEl;
                }
            }
            
            if (this.valueIsArray(el)) el = this.elementFromPoint(el[0], el[1]);
            
            return el;
        },
        
        
        // this method generally has the same semantic as the "normalizeElement", its being used in 
        // Siesta.Test.Action.Role.HasTarget to determine what to pass to next step
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the 
        // component instance
        normalizeActionTarget : function (el, allowMissing) {
            var result = this.normalizeElement(el, allowMissing);
            
            if (!allowMissing && !result) {
                throw 'No action target found for: ' + el;
            }
            return result;
        },

        
        
        // private
        getPathBetweenPoints: function (from, to) {
            if (
                typeof from[0] !== 'number' ||
                typeof from[1] !== 'number' ||
                typeof to[0] !== 'number'   ||
                typeof to[1] !== 'number'   ||
                isNaN(from[0])              ||
                isNaN(from[1])              ||
                isNaN(to[0])                ||
                isNaN(to[1]))
            {
                throw 'Incorrect arguments passed to getPathBetweenPoints';
            }

            var stops = [],
                x0 = Math.floor(from[0]),
                x1 = Math.floor(to[0]),
                y0 = Math.floor(from[1]),
                y1 = Math.floor(to[1]),
                dx = Math.abs(x1 - x0),
                dy = Math.abs(y1 - y0),
                sx, sy, err, e2;

            if (x0 < x1) {
                sx = 1;
            } else {
                sx = -1;
            }

            if (y0 < y1) {
                sy = 1;
            } else {
                sy = -1;
            }
            err = dx - dy;
            
            while (x0 !== x1 || y0 !== y1) {
                e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }

                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
                stops.push([x0, y0]);
            }

            var last = stops[stops.length-1];

            if (stops.length > 0 && (last[0] !== to[0] || last[1] !== to[1])) {
                stops.push(to);
            }
            return stops;
        },

        randomBetween : function (min, max) {
            return Math.round(min + (Math.random()*(max - min)));
        },

        
        // private
        valueIsArray : function(a) {
            return a && (a instanceof Array || a instanceof this.global.Array);
        },
        
        
        /**
         * This method will return the top-most DOM element at the specified coordinates from the test page. If
         * the resulting element is an iframe and `shallow` argument is not passed as `true`
         * it'll query the iframe for its element from the local point inside it.
         * 
         * @param {Number} x The X coordinate
         * @param {Number} y The Y coordinate
         * @param {Boolean} [shallow] Pass `true` to _not_ check the nested iframe if element at original coordinates is an iframe.
         * 
         * @return {HTMLElement} The top-most element at the specified position on the test page
         */
        elementFromPoint : function (x, y, shallow, fallbackEl, fullInfo) {
            var document    = this.global.document;
            var el          = document.elementFromPoint(x, y)
            
            // trying 2nd time if 1st attempt failed and returned null
            // this weird thing seems to be required sometimes for IE8 and may be for IE10
            if (!el) el     = document.elementFromPoint(x, y)
            
            // final fallback to the provided element or to the <body> element
            el              = el || fallbackEl || document.body;
            
            var localX      = x
            var localY      = y

            // If we found IFRAME and its not a `shallow` request, try to dig deeper
            if (el.nodeName.toUpperCase() == 'IFRAME' && !shallow) { 
                // if found iframe is loaded from different domain
                // just accessing its "el.contentWindow.document" property will throw exception
                try {
                    var iframeDoc       = el.contentWindow.document;
                    var offsetsToTop    = this.$(el).offset();
                    
                    localX              = x - offsetsToTop.left
                    localY              = y - offsetsToTop.top
        
                    var resolvedEl      = iframeDoc.elementFromPoint(localX, localY)
        
                    // again weird 2nd attempt for IE
                    if (!resolvedEl) resolvedEl = iframeDoc.elementFromPoint(localX, localY)
                    
                    resolvedEl          = resolvedEl || iframeDoc.body;
        
                    // Chrome reports 'HTML' in nested document.elementFromPoint calls which makes no sense
                    if (resolvedEl.nodeName.toUpperCase() === 'HTML') resolvedEl = iframeDoc.body;
        
                    el                  = resolvedEl;
                } catch (e) {
                    // digging deeper failed, restore the local coordinates
                    localX              = x
                    localY              = y
                }
            }
            
            return fullInfo ? {
                el          : el,
                localXY     : [ localX, localY ],
                globalXY    : [ x, y ]
            } : el
        },
        
        
        activeElement : function (notAllowBody, fallbackEl, elOrDoc) {
            var doc         = elOrDoc ? elOrDoc.ownerDocument || elOrDoc : this.global.document
            
            var focusedEl   = doc.activeElement;

            // For iframes, we need to grab the activeElement of the frame
            if ($(focusedEl).is('iframe') && focusedEl.contentDocument && focusedEl.contentDocument.body) {
                focusedEl = focusedEl.contentDocument.activeElement;
            }
            // 1. In IE10, it seems activeElement cannot be trusted as it sometimes returns an empty object with no properties.
            // Try to detect this case and use the fallback el 
            // 2. Sometimes receiving <body> from this method does not make sense either - use fallback el as well
            else if (!focusedEl || !focusedEl.nodeName || !focusedEl.tagName || (focusedEl === doc.body && notAllowBody)) {
                focusedEl   = fallbackEl;
            }
            
            return focusedEl
        },

        
        /**
         * This method uses native `document.elementFromPoint()` and returns the DOM element under the current logical cursor 
         * position in the test. Note, that this method may work not 100% reliable in IE due to its bugs. In cases
         * when "document.elementFromPoint" can't find any element this method returns the &lt;body&gt; element.
         * 
         * @return {HTMLElement}
         */
        getElementAtCursor : function() {
            var xy          = this.currentPosition;
            
            return this.elementFromPoint(xy[0], xy[1]);
        },

        /**
         * This method will wait for the first browser `event`, fired by the provided `observable` and will then call the provided callback.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of the event to wait for
         * @param {Function} callback The callback to call 
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForEvent : function (observable, event, callback, scope, timeout) {
            var eventFired      = false
            
            this.$(observable).bind(event, function () { eventFired = true })
            
            return this.waitFor({
                method          : function() { return eventFired; }, 
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForEvent',
                description     : ' observable to fire its "' + event + '" event'
            });
        },
        
        
        addListenerToObservable : function (observable, event, listener) {
            this.$(observable).bind(event, listener)
        },
        
        
        removeListenerFromObservable : function (observable, event, listener) {
            this.$(observable).unbind(event, listener)
        },
        
        
        verifyExpectedNumberOfFiredEvents : function (actual, expected) {
            var operator        = '=='
            
            if (this.typeOf(expected) == 'String') {
                var match       = /([<>=]=?)\s*(\d+)/.exec(expected)
                
                if (!match) throw new Error("Wrong format for expected number of events: " + expected)
                
                operator        = match[ 1 ]
                expected        = Number(match[ 2 ])
            }
            
            switch (operator) {
                case '==' : return actual == expected
                case '<=' : return actual <= expected
                case '>=' : return actual >= expected
                case '<' : return actual < expected
                case '>' : return actual > expected
            }
        },
        

        /**
         * This assertion verifies the number of certain events fired by provided observable instance during provided period.
         * 
         * For example:
         *

    t.firesOk({
        observable      : store,
        events          : {
            { update : 1, add : 2, datachanged : '> 1' }
        },
        during          : function () {
            store.getAt(0).set('Foo', 'Bar');
            
            store.add({ FooBar : 'BazQuix' })
            store.add({ Foo : 'Baz' })
        },
        desc            : 'Correct events fired'
    })
    
    // or
    
    t.firesOk({
        observable      : store,
        events          : {
            { update : 1, add : 2, datachanged : '>= 1' }
        },
        during          : 1
    })
    
    store.getAt(0).set('Foo', 'Bar');
    
    store.add({ FooBar : 'BazQuix' })
    store.add({ Foo : 'Baz' })
    
         *
         * Normally this method accepts a single object with various options (as shown above), but also can be called in 2 additional shortcuts forms:
         * 

    // 1st form for multiple events
    t.firesOk(observable, { event1 : 1, event2 : '>1' }, description)
    
    // 2nd form for single event
    t.firesOk(observable, eventName, 1, description)
    t.firesOk(observable, eventName, '>1', description)

         * 
         * In both forms, `during` is assumed to be undefined and `description` is optional.
         * 
         * @param {Object} options An obect with the following properties:
         * @param {Ext.util.Observable/Ext.Element/HTMLElement} options.observable The observable instance that will fire events
         * @param {Object} options.events The object, properties of which corresponds to event names and values - to expected 
         * number of this event triggering. If value of some property is a number then exact that number of events is expected. If value
         * of some property is a string starting with one of the comparison operators like "\<", "\<=" etc and followed by the number
         * then Siesta will perform that comparison with the number of actualy fired events.
         * @param {Number/Function} [options.during] If provided as a number denotes the number of milliseconds during which
         * this assertion will "record" the events from observable, if provided as function - then this assertion will "record"
         * only events fired during execution of this function. If not provided at all - assertions are recorded until the end of
         * current test (or sub-test)  
         * @param {Function} [options.callback] A callback to call after this assertion has been checked. Only used if `during` value is provided. 
         * @param {String} [options.desc] A description for this assertion
         */
        firesOk: function (options, events, n, timeOut, func, desc, callback) {
            //                    |        backward compat arguments        | 
            var me              = this;
            var sourceLine      = me.getSourceLine();
            
            var observable, during
            
            if (arguments.length == 1) {
                observable      = options.observable
                events          = options.events
                during          = options.during
                desc            = options.desc || options.description
                callback        = options.callback
                
                timeOut         = this.typeOf(during) == 'Number' ? during : null
                func            = this.typeOf(during) == 'Function' ? during : null
                
            } else if (arguments.length >= 5) {
                // old signature, backward compat
                observable      = options
                
                if (this.typeOf(events) == 'String') {
                    var obj         = {}
                    obj[ events ]   = n
                    
                    events          = obj
                }
            } else if (arguments.length <= 3 && this.typeOf(events) == 'Object') {
                // shortcut form 1
                observable      = options
                desc            = n
            } else if (arguments.length <= 4 && this.typeOf(events) == 'String') {
                // shortcut form 2
                observable      = options
                
                var obj         = {}
                obj[ events ]   = n
                events          = obj
                
                desc            = timeOut
                timeOut         = null
            } else
                throw new Error("Unrecognized signature for `firesOk`")
            
            // start recording
            var counters    = {};
            var countFuncs  = {};

            Joose.O.each(events, function (expected, eventName) {
                counters[ eventName ]   = 0
                
                var countFunc   = countFuncs[ eventName ] = function () {
                    counters[ eventName ]++
                }
                
                me.addListenerToObservable(observable, eventName, countFunc);    
            })
            
            
            // stop recording and verify the results
            var stopRecording   = function () {
                Joose.O.each(events, function (expected, eventName) {
                    me.removeListenerFromObservable(observable, eventName, countFuncs[ eventName ]);
                    
                    var actualNumber    = counters[ eventName ]
    
                    if (me.verifyExpectedNumberOfFiredEvents(actualNumber, expected))
                        me.pass(desc, {
                            descTpl         : 'Observable fired ' + actualNumber + ' `' + eventName + '` events'
                        });
                    else
                        me.fail(desc, {
                            assertionName   : 'firesOk',
                            sourceLine      : sourceLine,
                            descTpl         : 'Observable fired expected number of `' + eventName + '` events',
                            got             : actualNumber,
                            gotDesc         : 'Actual number of events',
                            need            : expected,
                            needDesc        : 'Expected number of events'
                        });
                })
            }
            
            if (timeOut) {
                var async               = this.beginAsync(timeOut + 100);
                
                var originalSetTimeout  = this.originalSetTimeout;
    
                originalSetTimeout(function () {
                    me.endAsync(async);
                    
                    stopRecording()
    
                    callback && me.processCallbackFromTest(callback);
                }, timeOut);
            } else if (func) {
                func()
                
                stopRecording()
                
                callback && me.processCallbackFromTest(callback)
            } else {
                this.on('beforetestfinalizeearly', stopRecording)
            }
        },


        /**
         * This assertion passes if the observable fires the specified event exactly (n) times during the test execution.
         * Please note that
         *
         * @param {Ext.util.Observable/Ext.Element/HTMLElement} observable The observable instance
         * @param {String} event The name of event
         * @param {Number} n The expected number of events to be fired
         * @param {String} desc The description of the assertion.
         */
        willFireNTimes: function (observable, event, n, desc, isGreaterEqual) {
            this.firesOk(observable, event, isGreaterEqual ? '>=' + n : n, desc)
        },
        
        
        getObjectWithExpectedEvents : function (event, expected) {
            var events      = {}
            
            if (this.typeOf(event) == 'Array') 
                Joose.A.each(event, function (eventName) {
                    events[ eventName ] = expected
                })
            else
                events[ event ]         = expected
                
            return events
        },
        
        
        /**
         * This assertion passes if the observable does not fire the specified event(s) after calling this method.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} desc The description of the assertion.
         */
        wontFire : function(observable, event, desc) {
            this.firesOk({
                observable      : observable,
                events          : this.getObjectWithExpectedEvents(event, 0), 
                desc            : desc
            });
        },

        /**
         * This assertion passes if the observable fires the specified event exactly once after calling this method.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} desc The description of the assertion.
         */
        firesOnce : function(observable, event, desc) {
            this.firesOk({
                observable      : observable,
                events          : this.getObjectWithExpectedEvents(event, 1), 
                desc            : desc
            });
        },

        /**
         * Alias for {@link #wontFire} method
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} desc The description of the assertion.
         */
        isntFired : function() {
            this.wontFire.apply(this, arguments);
        },

        /**
         * This assertion passes if the observable fires the specified event at least `n` times after calling this method.
         * 
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of event
         * @param {Number} n The minimum number of events to be fired
         * @param {String} desc The description of the assertion.
         */
        firesAtLeastNTimes : function(observable, event, n, desc) {
            this.firesOk(observable, event, '>=' + n, desc);
        },


        // This method accepts actionTargets as input (Dom node, string, CQ etc) and does a first normalization pass to get a DOM element.
        // After initial normalization it also tries to locate, the 'top' DOM node at the center of the first pass resulting DOM node.
        // This is the only element we can truly interact with in a real browser.
        // returns an object containing the element plus coordinates
        getNormalizedTopElementInfo : function (actionTarget, skipWarning, actionName, offset) {
            var localXY, globalXY, el;

            actionTarget    = actionTarget || this.currentPosition;

            // First lets get a normal DOM element to work with
            if (this.valueIsArray(actionTarget)) {
                globalXY    = actionTarget;
                
                var info    = this.elementFromPoint(actionTarget[ 0 ], actionTarget[ 1 ], false, null, true);
                
                el          = info.el
                localXY     = info.localXY
            } else {
                el          = this.normalizeElement(actionTarget, skipWarning, Boolean(offset));
            }

            if (!el && skipWarning) {
                return;
            }

            // 1. If this element is not visible, something is wrong
            // 2. If element is visible but not reachable (scrolled out of view) this is also an invalid scenario (this check is skipped for IE)
            //    TODO needs further investigation, conflicting with starting a drag operation on an element that isn't visible until the cursor is above it
            if (!skipWarning && (!this.isElementVisible(el) /* || (!$.browser.msie && !this.elementIsTop(el, true))*/ )) {
                this.fail('findTopDomElement: ' + (actionName ? "Target element of action [" + actionName + "]" : "Target element of some action") +
                        " is not visible or not reachable: " + (el.id ? '#' + el.id : el)
                );
            }

            if (!this.valueIsArray(actionTarget)) {
                var doc     = el.ownerDocument;

                localXY     = this.getTargetCoordinate(el, true, offset)
                globalXY    = this.getTargetCoordinate(el, false, offset)

                // trying 2 times for IE
                el          = doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.body;

                if (!el) {
                    this.fail('findTopDomElement: Could not find any element at [' + localXY + ']');
                    return; // No point going further
                }
            }

            return {
                el          : el,
                localXY     : localXY,
                globalXY    : globalXY
            }
        },

        /**
         * This method will wait for the presence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextPresent : function (text, callback, scope, timeout) {

            return this.waitFor({
                method          : function() { return this.$(':contains(' + text + ')').length > 0; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTextPresent',
                description     : ' text "' + text + '" to be present'
            });
        },

        /**
         * This method will wait for the absence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextNotPresent : function (text, callback, scope, timeout) {

            return this.waitFor({
                method          : function() { return this.$(':contains(' + text + ')').length === 0; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTextNotPresent',
                description     : ' text "' + text + '" to not be present'
            });
        },

        /**
         * Waits until the passed action target is detected. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout) {
            var me = this;

            this.waitFor({
                method          : function() { return me.normalizeElement(target, true); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTarget',
                description     : ' target "' + target + '" appear'
            });
        }
    }
});
;
/**
 *
@class Siesta.Test.ExtJS
@extends Siesta.Test.Browser
@mixin Siesta.Test.ExtJSCore
@mixin Siesta.Test.ExtJS.Ajax
@mixin Siesta.Test.ExtJS.Observable
@mixin Siesta.Test.ExtJS.FormField
@mixin Siesta.Test.ExtJS.Component
@mixin Siesta.Test.ExtJS.Element
@mixin Siesta.Test.ExtJS.Store
@mixin Siesta.Test.ExtJS.DataView
@mixin Siesta.Test.ExtJS.Grid

A base class for testing browser and ExtJS applications. It inherit from {@link Siesta.Test.Browser}
and adds various ExtJS specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Class('Siesta.Test.ExtJS', {

    isa         : Siesta.Test.Browser,

    does        :  [
        Siesta.Test.ExtJSCore,
        Siesta.Test.ExtJS.Component,
        Siesta.Test.ExtJS.Element,
        Siesta.Test.ExtJS.FormField,
        Siesta.Test.ExtJS.Observable,
        Siesta.Test.ExtJS.Store,
        Siesta.Test.ExtJS.Grid,
        Siesta.Test.ExtJS.DataView,
		Siesta.Test.ExtJS.Ajax
    ],

    
    has : {
        globalExtOverrides      : null,
        
        extPathRegex1           : /(.*ext(?:js)?-\d\.\d+(?:\.\d+)?.*?)\/ext-all(?:-debug|-dev)?\.js/,
        extPathRegex2           : /(.*ext(?:js)?\/gpl\/\d\.\d+(?:\.\d+)?.*?)\/ext-all(?:-debug|-dev)?\.js/
    },
    
    methods : {

        getExtBundlePath : function() {
            var path
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)
            var me                  = this

            while (testDescriptor && !path) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        if (url.match && (url.match(me.extPathRegex1) || url.match(me.extPathRegex2))) {
                            path    = url;
                            return false;
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return path;
        },


        getExtBundleFolder : function() {
            var folder;
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)
            var me                  = this

            while (testDescriptor && !folder) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        var match = me.extPathRegex1.exec(url) || me.extPathRegex2.exec(url);

                        if (match) folder = match[1];
                        
                        return false
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return folder;
        },
        
        
        getNumberOfGlobalExtOverrides : function (callback) {
            var globalExtOverrides  = this.globalExtOverrides;
            
            if (globalExtOverrides != null) 
                callback && callback.call(this, globalExtOverrides.length, globalExtOverrides)
            else {
                var me              = this;
                var Ext             = this.getExt();
                var extjsBundleURL  = me.getExtBundlePath()
    
                if (!extjsBundleURL) {
                    me.fail("Can'me find ExtJS bundle url");
                    callback && callback.call(me, null, null)
                    return;
                }

                // For IE
                this.expectGlobal('0');

                var frame           = Ext.core.DomHelper.append(Ext.getBody(), { 
                    tag     : "iframe",
                    style   : 'display:none'
                }, false);
                
                var freshWin        = frame.contentWindow;
    
                freshWin.document.open();
    
                freshWin.document.write(
                    '<html><head><script type="text/javascript" src="' + extjsBundleURL + '"></script></head><body></body></html>'
                );
    
                freshWin.document.close();
                
                var resolveObject   = function (hostObj, nameSpace) {
                    var parts   = nameSpace.split('.');
                    var p       = hostObj
    
                    for (var i = 0; i < parts.length; i++) {
                        p       = p[ parts[ i ] ];
                    };
    
                    return p;
                }
    
                var ignore          = function (name) {
                    return name.match(/Ext\.data\.Store\.ImplicitModel|collectorThreadId/);
                }
                
                var getObjectDifferences    = function (cleanObj, dirtyObj, ns) {
                    var diff    = []

                    for (var p in dirtyObj) {
                        try {
                            if (dirtyObj.hasOwnProperty(p)) {
                                // Check if the object exists on the clean window and also do a string comparison
                                // in case a builtin method has been overridden
                                if (
                                    (!cleanObj.hasOwnProperty(p) && typeof cleanObj[p] == 'undefined' ) ||
                                        (typeof dirtyObj[p] == 'function' && cleanObj[p].toString() !== dirtyObj[p].toString()) ||
                                        (Ext.isPrimitive(dirtyObj[p]) && dirtyObj[p].toString() !== cleanObj[p].toString())
                                ) {
                                    if (!ignore(ns + '.' + p)) diff.push(ns + '.' + p);
                                }
                            }
                        } catch (e) {
                            // Just continue
                        }
                    }
                    return diff;
                }
                
                me.waitFor(
                    function () { return freshWin.Ext && freshWin.Ext.isReady; }, 
                    function () {
                        var dirtyWin    = me.global,
                            overrides   = [];
        
                        // Check for native class augmentations
                        Ext.iterate(Ext.ClassManager.classes, function (item) {
                            if (!item.match(/^Ext\./)) return;
        
                            var freshItem   = resolveObject(freshWin, item);
                            var dirtyItem   = resolveObject(dirtyWin, item);
        
                            if (freshItem && typeof dirtyItem !== 'undefined') {
                                var staticDiff = getObjectDifferences(freshItem,  dirtyItem, item);
                                    
                                overrides.push.apply(overrides, staticDiff);
        
                                // Prototype properties
                                if (dirtyItem.prototype) {
                                    var prototypeDiff = getObjectDifferences(freshItem.prototype, dirtyItem.prototype, item + '.prototype');
                                    
                                    overrides.push.apply(overrides, prototypeDiff);
                                }
                            }
                        });
                        
                        me.globalExtOverrides   = overrides
                        
                        callback && callback.call(me, overrides.length, overrides)
                    }
                )
                // eof waitFor
            }
        },
        

        /**
         * This assertion passes if no global Ext JS overrides exist. It creates a fresh iframe window where a new, fresh copy
         * of Ext JS w/o any overrides is loaded and then a comparison is made against the copy of Ext JS loaded in the test.
         * 
         * A global ExtJS override is some change, made in the core class, for example like this:
         * 

    Ext.data.Store.override({
        removeAll       : function () {
            // my fix
            ...
        }
    })

         * While such overrides are often seems as the only possible solution (usually for some bug in Ext) they should be 
         * avoided as much as possible, because it a very bad practice. For example, in the previous case, a better approach
         * would be to create a new subclass of the Ext.data.Store with the desired changed.
         * 
         * See also {@link #assertMaxNumberOfGlobalExtOverrides} assertion. 
         *
         * @param {String} [description] The description for the assertion
         */
        assertNoGlobalExtOverrides : function (description) {
            this.getNumberOfGlobalExtOverrides(function (length, overrides) {
                if (length == null) {
                    this.fail("Was not able to find the ExtJS bundle URL in the `assertNoGlobalExtOverrides` assertion")
                    return
                }
                
                if (length) {
                    this.fail(description, {
                        assertionName   : 'assertNoGlobalExtOverrides',
                        descTpl         : 'No global Ext overrides found',
                        
                        got             : length,
                        gotDesc         : "Number of overrides found",
                        
                        annotation      : "Found overrides for: `" + overrides.join('`, `') + '`'
                    })
                } else
                    this.pass(description, {
                        descTpl             : 'No global Ext overrides found'
                    })
            })
        },

        
        /**
         * This assertion passes if the number of global overrides does not exceed the given number.
         * 
         * For example, you can add this assertion in your existing codebase (assuming you have 3 overrides your application
         * cannot function without):
         * 
         *      t.assertMaxNumberOfGlobalExtOverrides(3, "Ideally should be none of these")
         *      
         * and catch all the cases when someone adds a new global override.
         * 
         * @param {Number} maxNumber The maximum number of Ext JS overrides allowed
         * @param {String} [description] The description for the assertion
         */
        assertMaxNumberOfGlobalExtOverrides : function (maxNumber, description) {
            this.getNumberOfGlobalExtOverrides(function (length, overrides) {
                if (length == null) {
                    this.fail("Was not able to find the ExtJS bundle URL in the `assertMaxNumberOfGlobalExtOverrides` assertion")
                    return
                }
                
                if (length > maxNumber) {
                    this.fail(description, {
                        assertionName   : 'assertNoGlobalExtOverrides',
                        descTpl         : 'Found less or equal than ' + maxNumber + ' ext global overrides',
                        
                        got             : length,
                        gotDesc         : "Number of overrides found",
                        
                        annotation      : "Found overrides for: `" + overrides.join('`, `') + '`'
                    })
                } else
                    this.pass(description, {
                        descTpl             : 'Found less or equal than ' + maxNumber + ' ext global overrides',
                        annotation          : "Number of overrides found: " + length
                    })
            })
        },

        /**
         * A helper method returning the total number of Ext JS container layouts that have been performed since the beginning of the page lifecycle.
         * @return {Int} The number of layouts
         */
        getTotalLayoutCounter : function () {
            var count       = 0

            this.Ext().each(this.cq('container'), function(c) { count += c.layoutCounter });

            return count;
        },

        /**
         * This assertion passes if no Ext JS layout cycles are performed as a result of running the passed function. This
         * function will query all containers on the page and measure the number of layouts performed before and after the function call.
         *
         * @param {Function} fn The function to call
         * @param {Object} scope The 'thisObject' to use for the function call
         * @param {String} [description] The description for the assertion
         */
        assertNoLayoutTriggered : function(fn, scope, description) {
            var countBefore = this.getTotalLayoutCounter();

            fn.call(scope || this);

            this.is(this.getTotalLayoutCounter(), countBefore, description);
        },

        /**
         * Waits until no ongoing animations can be detected.
         *
         * @param {Function} callback The callback to call after the component becomes visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForAnimations: function (callback, scope, timeout) {
            var Ext = this.Ext();

            this.waitFor({
                method          : function () { return !Ext.fx.Manager.items || Ext.fx.Manager.items.getCount() === 0; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForAnimations',
                description     : ' animations to finalize'
            });
        }
    }
})
;
/**
@class Siesta.Test.SenchaTouch
@extends Siesta.Test.Browser
@mixin Siesta.Test.ExtJSCore
@mixin Siesta.Test.ExtJS.Observable
@mixin Siesta.Test.ExtJS.FormField
@mixin Siesta.Test.ExtJS.Component
@mixin Siesta.Test.ExtJS.Element 
@mixin Siesta.Test.ExtJS.Store 

A base class for testing Sencha Touch applications. It inherits from {@link Siesta.Test.Browser} 
and adds various ST specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Class('Siesta.Test.SenchaTouch', {
    
    isa         : Siesta.Test.Browser,
        
    does        :  [ 
        Siesta.Test.ExtJSCore, 
        Siesta.Test.ExtJS.Component, 
        Siesta.Test.ExtJS.Element, 
        Siesta.Test.ExtJS.Observable, 
        Siesta.Test.ExtJS.Store,
		Siesta.Test.ExtJS.Ajax
    ],
    
    has         : {
        performSetup        : true,
        isSTSetupDone       : false,

        moveCursorBetweenPoints : false
    },
    
    override : {
        
        isReady : function () {
            var result = this.SUPERARG(arguments);

            if (!result.ready) return result;

            if (!this.parent && this.performSetup && !this.isSTSetupDone) return {
                ready       : false,
                reason      : "Waiting for Ext.setup took too long - some dependency can't be loaded? Check the `Net` tab in Firebug"
            }
            
            return {
                ready       : true
            }
        },

        
        start : function () {
            var me      = this;
            var Ext     = this.getExt();
            
            if (!Ext) return
            
            // calling SUPER to setup the loader paths, Ext.setup() will already do Ext.require
            this.SUPERARG(arguments)
            
            // execute "Ext.setup()" for top-level tests only 
            if (this.performSetup && !this.parent) Ext.setup({
                onReady : function () {
                    me.isSTSetupDone    = true
                }
            })
        },
        
        
        launch : function () {
            var setupEventTranslation = function () {
                if (Ext.feature.has.Touch) {
                    if (Ext.getVersion('touch').isGreaterThanOrEqual('2.2.0')) {
                        Ext.event.publisher.TouchGesture.prototype.handledEvents.push('mousedown', 'mousemove', 'mouseup');
                    } else {
                        Ext.event.publisher.TouchGesture.override({
                            moveEventName: 'mousemove',

                            map: {
                                mouseToTouch: {
                                    mousedown: 'touchstart',
                                    mousemove: 'touchmove',
                                    mouseup: 'touchend'
                                },

                                touchToMouse: {
                                    touchstart: 'mousedown',
                                    touchmove: 'mousemove',
                                    touchend: 'mouseup'
                                }
                            },

                            attachListener: function(eventName) {
                                eventName = this.map.touchToMouse[eventName];

                                if (!eventName) {
                                    return;
                                }

                                return this.callOverridden([eventName]);
                            },

                            lastEventType: null,

                            onEvent: function(e) {
                                if ('button' in e && e.button !== 0) {
                                    return;
                                }

                                var type = e.type,
                                    touchList = [e];

                                // Temporary fix for a recent Chrome bugs where events don't seem to bubble up to document
                                // when the element is being animated
                                // with webkit-transition (2 mousedowns without any mouseup)
                                if (type === 'mousedown' && this.lastEventType && this.lastEventType !== 'mouseup') {
                                    var fixedEvent = document.createEvent("MouseEvent");
                                        fixedEvent.initMouseEvent('mouseup', e.bubbles, e.cancelable,
                                            document.defaultView, e.detail, e.screenX, e.screenY, e.clientX,
                                            e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.metaKey,
                                            e.button, e.relatedTarget);

                                    this.onEvent(fixedEvent);
                                }

                                if (type !== 'mousemove') {
                                    this.lastEventType = type;
                                }

                                e.identifier = 1;
                                e.touches = (type !== 'mouseup') ? touchList : [];
                                e.targetTouches = (type !== 'mouseup') ? touchList : [];
                                e.changedTouches = touchList;

                                return this.callOverridden([e]);
                            },

                            processEvent: function(e) {
                                this.eventProcessors[this.map.mouseToTouch[e.type]].call(this, e);
                            }
                        });
                    }
                }
            };

            // Need to tell ST to convert mouse events to their touch counterpart
            this.scopeProvider.runCode('(' + setupEventTranslation.toString() + ')();')
            
            this.SUPERARG(arguments)
        }
    },
    
    methods : {
        // one of these methods feels redundant
        getTouchBundlePath : function() {
            var path;
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)
            
            while (testDescriptor && !path) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        if (url.match && url.match(/(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch(.*)\.js/)) {
                            path = url;
                            return false;
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return path;
        },


        getTouchBundleFolder : function() {
            var folder;
            var testDescriptor      = this.harness.getScriptDescriptor(this.url)

            while (testDescriptor && !folder) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        var regex = /(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch(.*)\.js/;
                        var match = regex.exec(url);
                
                        if (match) {
                           folder = match[1];
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return folder;
        },
        
        
        getExtBundleFolder : function() {
            var folder;

            this.harness.mainPreset.eachResource(function (resource) {
                var desc = resource.asDescriptor();
                
                var regex = /(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch-all(?:-debug)?\.js/;
                var match = regex.exec(desc.url);
                
                if (match) {
                   folder = match[1];
                }
            });

            return folder;
        },
        

        /**
         * This method taps the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         * 
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        tap: function (target, callback, scope, offset) {
            var me      = this;
            var context = this.getNormalizedTopElementInfo(target, true, 'tap', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.tap(target, callback, scope, offset);
                }, this);

                return;
            }

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 30 : 0,
                
                observeTest     : this,
                
                processor       : function (data) {
                    me.simulateEvent.apply(me, data);
                }
            })
            
            queue.addStep([ context.localXY, "mousedown", {}, false ])
            queue.addStep([ context.localXY, "mouseup", {}, true ])

            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },

        /**
         * This method double taps the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         * 
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action
         * @param {Object} scope (optional) The scope for the callback
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        doubleTap: function (target, callback, scope, offset) {
            var me          = this;

            var context = this.getNormalizedTopElementInfo(target, true, 'doubleTap', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.doubleTap(target, callback, scope, offset);
                }, this);

                return;
            }

            target = context.localXY;

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,
                
                interval        : callback ? 30 : 0,
                
                observeTest     : this,
                
                processor       : function (data) {
                    me.simulateEvent.apply(me, data);   
                }
            })
            
            queue.addStep([ target, "mousedown", {}, false ])
            queue.addStep([ target, "mouseup", {}, true ])
            
            queue.addStep([ target, "mousedown", {}, false ])
            queue.addStep([ target, "mouseup", {}, true ])
            
            var async   = me.beginAsync();
            
            queue.run(function () {
                me.endAsync(async);
                
                me.processCallbackFromTest(callback, null, scope || me)
            })
        },

        /**
         * This method performs a long press on the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         * 
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action
         * @param {Object} scope (optional) The scope for the callback
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        longpress: function (target, callback, scope, offset) {
            var Ext = this.Ext();
            var me = this;

            var context = this.getNormalizedTopElementInfo(target, true, 'longpress', offset);

            if (!context) {
                this.waitForTarget(target, function() {
                    this.longpress(target, callback, scope, offset);
                }, this);

                return;
            }
            target = context.localXY;

            var amount = Ext.event.recognizer.LongPress.prototype.config.minDuration + 50;

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : callback ? 30 : 0,

                observeTest     : this,

                processor       : function (data) {
                    me.simulateEvent.apply(me, data);
                }
            })

            queue.addStep([ target, "mousedown", {} ])
            queue.addDelayStep(amount);
            queue.addStep([ target, "mouseup", {} ])

            var async   = me.beginAsync();

            queue.run(function () {
                me.endAsync(async);

                me.processCallbackFromTest(callback, null, scope || me)
            })
        },

        /**
        * This method will simulate a swipe operation between either two points or on a single DOM element.
        *   
        * @param {Siesta.Test.ActionTarget} target Target for this action
        * @param {String} direction Either 'left', 'right', 'up' or 'down'
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the drag operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        */
        swipe : function(target, direction, callback, scope) {
            target = this.normalizeElement(target, true);

            if (!target) {
                this.waitForTarget(target, function() {
                    this.swipe(target, direction, callback, scope);
                }, this);

                return;
            }

            var Ext = this.Ext();
            
            var box = Ext.fly(target).getBox(),
                start,
                end,
                edgeOffsetRatio = 10;
            
            // Since this method accepts elements as target, we need to assure that we swipe at least about 150px
            // using Math.max below etc

            switch(direction) {
                case 'u':
                case 'up':
                    start   = [box.x + box.width/2, (box.y + box.height*9/edgeOffsetRatio)];
                    end     = [box.x + box.width/2, box.y + box.height/edgeOffsetRatio]; 
                    
                    end[1] = Math.min(start[1] - 100, end[1]);
                break;

                case 'd':
                case 'down':
                    start   = [box.x + box.width/2, (box.y + box.height/edgeOffsetRatio)]; 
                    end     = [box.x + box.width/2, (box.y + box.height*9/edgeOffsetRatio)];

                    end[1] = Math.max(start[1] + 100, end[1]);
                break;

                case 'r':
                case 'right':
                    start   = [box.x + (box.width /edgeOffsetRatio), (box.y + box.height/2)]; 
                    end     = [box.x + (box.width * 9/edgeOffsetRatio), (box.y + box.height/2)];
                    
                    end[0] = Math.max(start[0] + 100, end[0]);
                break;

                case 'l':
                case 'left':
                    start   = [box.x + (box.width * 9/edgeOffsetRatio), (box.y + box.height/2)];
                    end     = [box.x + (box.width /edgeOffsetRatio), (box.y + box.height/2)]; 
                    
                    end[0] = Math.min(start[0] - 100, end[0]);
                break;

                default: 
                    throw 'Invalid swipe direction: ' + direction;
            }

            this.dragTo(start, end, callback, scope);
        },

        /**
        * This method will simulate a finger move to an xy-coordinate or an element (the center of it)
        * 
        * @param {Siesta.Test.ActionTarget} target Target point to move the finger to.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveFingerTo : function(target, callback, scope, offset) {
            this.moveCursorTo.apply(this, arguments);
        },

        /**
        * This method will simulate a finger move from current position relative by the x and y distances provided.
        * 
        * @param {Array} delta The delta offset to move the finger by.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        */
        moveFingerBy : function(delta, callback, scope) {
            if (!delta) {
                throw 'Trying to call moveFingerBy without relative distances';
            }

            this.moveCursorBy.apply(this, arguments);
        },

//        /**
//        * This method will simulate a swipe operation between either two points or on a single DOM element.
//        *   
//        * @param {Siesta.Test.ActionTarget} source The drag start point as one of the {@link Siesta.Test.ActionTarget} values.
//        * @param {Siesta.Test.ActionTarget} target The drag end point as one of the {@link Siesta.Test.ActionTarget} values.
//        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the swipe operation is completed.
//        * @param {Object} scope (optional) the scope for the callback
//        */
//        swipeTo : function(source, target, callback, scope) {
//            source = this.normalizeElement(source);
//            target = this.normalizeElement(target);
//
//            this.SUPER(source, target, callback, scope, options, dragOnly);
//        },

//        /**
//        * This method will do something
//        *   
//        * @param {Ext.Component/String/HTMLElement/Array} target Either an Ext.Component, a Component Query selector, an element, or [x,y] as the drag end point
//        * @param {String} direction Either 'left', 'right', 'up' or 'down'
//        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the drag operation is completed.
//        * @param {Object} scope (optional) the scope for the callback
//        */
        scrollUntil : function(target, direction, checkerFn, callback, scope) {
            var me = this,
                startDate = new Date(),
                dir = direction;

            // Invert direction, Scroll up => Swipe down
            switch(dir) {
                case 'u':
                case 'up':
                    direction = 'down';
                break;

                case 'd':
                case 'down':
                    direction = 'up';
                break;

                case 'l':
                case 'left':
                    direction = 'right';
                break;

                case 'r':
                case 'right':
                    direction = 'left';
                break;

                default: 
                    throw 'Invalid swipe direction: ' + direction;
            }

            var inner = function() {
                if (checkerFn.call(scope || me, target)) {
                    // We're done
                    me.processCallbackFromTest(callback, null, scope || me)
                } else {
                    me.swipe(target, direction, function() { 

                        if (new Date() - startDate < this.waitForTimeout) {
                            var as = me.beginAsync();
                            setTimeout(function() {
                                me.endAsync(as); 
                                inner(); 
                            }, 1000); 
                        } else {
                            me.fail('scrollUntil failed to achieve its mission');
                        }
                    });
                }
            };

            inner();
        },

        /**
         * Waits until the supplied x&y scroll property has the passed value. You can test for either x or y, or both.
         *
         * @param {Ext.scroller.Scroller} scrollable The scroller instance
         * @param {String} direction 'up', 'down', 'left' or 'right'
         * @param {Siesta.Test.ActionTarget} actionTarget The target, either an element or a CSS selector normally.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         */
        scrollUntilElementVisible : function(scrollable, direction, actionTarget, callback, scope) {
            var me = this;
            if (!actionTarget || !scrollable) {
                this.fail('scrollUntilElementVisible: target or scrollable not provided');
                return;
            }

            this.scrollUntil(scrollable, direction, function() {
                var element = me.normalizeElement(actionTarget, true);
                return me.elementIsInView(element);
            },
            callback, scope);
        },

        
        /**
         * Waits until the supplied x&y scroll property has the passed value. You can test for either x or y, or both.
         * 
         * @param {Ext.scroller.Scroller} scroller The scroller instance
         * @param {Object} position An object with an x, y, or x&y values. Ex. { x : 0 } or { x : 0, y : 200 }.
         * @param {Int} value
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        waitForScrollerPosition: function(scroller, pos, callback, scope, timeout) {
            this.waitFor({
                method          : function() { 
                    return (!('x' in pos) || pos.x === scroller.position.x) && (!('y' in pos) || pos.y === scroller.position.y);
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForScrollerPosition',
                description     : ' scroller to reach position "' + Siesta.Util.Serializer.stringify(pos)
            });
        },

        /**
         * Waits until no ongoing animations can be detected.
         *
         * @param {Function} callback The callback to call after the component becomes visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForAnimations: function (callback, scope, timeout) {
            var Ext = this.Ext();

            this.waitFor({
                method          : function () { return !Ext.AnimationQueue.isRunning; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForAnimations',
                description     : ' animations to finalize'
            });
        }
    }
})
;
/**
 * 
@class Siesta.Test.jQuery
@extends Siesta.Test.Browser

A base class for testing jQuery applications. It inherit from {@link Siesta.Test.Browser} and adds various jQuery specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

*/
Class('Siesta.Test.jQuery', {
    
    isa         : Siesta.Test.Browser,
        
    methods : {
        
        initialize : function() {
            // Since this test is preloading jQuery, we should let Siesta know what to 'expect'
            this.expectGlobals('$', 'jQuery');
            this.SUPER();
        },
     

        /**
         * This method returns the jQuery object from the scope of the test. When creating your own assertions for jQuery code, you need
         * to make sure you are using this method to get the `jQuery` instance. 
         * @return {Object} The `$` object from the scope of test
         */
        get$ : function () {
            return this.global.$;
        },

        normalizeElement : function(el) {
            return el.jquery ? el.get(0) : this.SUPER(el);
        }
    }
})
;
Class('Siesta.Content.Manager.Browser', {
    
    isa     : Siesta.Content.Manager,
    
    has : {
//        baseUrl             : window.location.href.replace(/\?.*$/,'').replace(/\/[^/]*$/, '/'),
//        baseHost            : window.location.host,
//        baseProtocol        : window.location.protocol
    },
    
    
    methods : {
        
        // TODO check that URL can be actully fetched with XHR (same origin)
        load : function (url, onsuccess, onerror) {
            var req = new JooseX.SimpleRequest()
            
            try {
                req.getText(url, true, function (success, text) {
                    
                    if (!success) { 
                        onerror(this + " not found") 
                        return 
                    }
                    
                    onsuccess(text)
                })
            } catch (e) {
                onerror(e)
            }
        }
    }
})

;
Class('Siesta.Content.Manager.Browser.ExtJSCore', {
    isa     : Siesta.Content.Manager.Browser
})

;
/**
@class Siesta.Harness.Browser
@extends Siesta.Harness 

Class, representing the browser harness. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.Browser}, which contains
only generic browser-related assertions. So, use this harness class, when testing a generic web page.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.


Synopsys
========

    var Harness = Siesta.Harness.Browser;
    
    Harness.configure({
        title     : 'Awesome Test Suite',
        
        transparentEx       : true,
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],
        
        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })
    
    
    Harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
        
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
            
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
        
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
            
            autoCheckGlobals    : false,
            
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )



*/

Class('Siesta.Harness.Browser', {
    
    // static
    my : {
        isa         : Siesta.Harness,
        
        has : {
            id                  : null,
            
            /**
             * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.Browser}.
             * You can subclass {@link Siesta.Test.Browser} and provide a new class. 
             * 
             * This option can be also specified in the test file descriptor. 
             */
            testClass           : Siesta.Test.Browser,
            
            viewportClass       : "Siesta.Harness.Browser.UI.Viewport",

            viewport            : null,
            
            /**
             * @cfg {Boolean} autoRun When set to `true`, harness will automatically launch the execution either of the checked test files or the whole suite.
             * Default value is `false`
             */
            autoRun             : false,
            
            /**
             * @cfg {Boolean} viewDOM When set to `true`, harness will expand the panel with the `<iframe>` of the test file, so you can examine the content of DOM.
             * Default value is `false`
             */
            viewDOM             : false,
            
            /**
             * @cfg {Boolean} speedRun When set to `true`, harness will reduce the quality or completely remove the visual effects for events simulation,
             * improving the speed of test. Default value is `true`.
             * 
             * This option can be also specified in the test file descriptor.
             */
            speedRun            : true,

            /**
             * @cfg {Boolean} breakOnFail When set to `true`, harness will not start launching any further tests after detecting a failed assertion.
             * improving the speed of test. Default value is `false`.   
             */
            breakOnFail             : false,
            activateDebuggerOnFail  : false,

            contentManagerClass : Siesta.Content.Manager.Browser,
            scopeProvider       : 'Scope.Provider.IFrame',
            
            /**
             * @cfg {Boolean} disableCaching When set to `true`, harness will prevent the browser caching of files being preloaded and the test files, by appending
             * a query string to it.
             * Note, that in this case, debuggers may not understand that you are actually loading the same file, and breakpoints may not work. Default value is `false`
             */
            disableCaching      : false,
            
            baseUrl             : window.location.href.replace(/\?.*$/,'').replace(/\/[^/]*$/, '/'),
            baseHost            : window.location.host,
            baseProtocol        : window.location.protocol,
            
            /**
             * @cfg {Boolean} forceDOMVisible When set to `true` the tests will be executed in "fullscreen" mode, with their iframes on top of all other elements.
             * This is required in IE if your test includes interaction with the DOM, for example when using the `document.getElementFromPoint()` method (it will not work unless the element
             * is visible).
             *
             * This option is enabled by default in IE and disabled in all other browsers.
             * This option can be also specified in the test file descriptor (usually you will create a group of "rendering" tests). Usually it's only relevant for IE,
             * so using this option should look like:
             *

    Harness.start(
        {
            group       : 'Rendering',
            
            forceDOMVisible    : $.browser.msie,
            
            items       : [
                'rendering/01_grid.t.js',
                ...
            ]
        },
        ...
    )
            
             */
            forceDOMVisible     : $.browser.msie,
            
            
            /**
             * @cfg {String} hostPageUrl The url of the HTML page which will be the target for the test(s). This option is used for application level testing, Siesta will visit this URL and then launch
             * the test. See `/examples/021-extjs-drag-drop/index.js` for an example.
             * 
             * Note that with this option, the test descriptor will stop inheriting the {@link #preload} option from parent descriptors/harness
             * (to make sure you don't preload your dependencies twice). This is usually an expected behavior, and you still can specify the `preload` option
             * directly on such descriptor if needed.
             * 
             * This option can be also specified in the test file descriptor.
             * 
             * For example, to define that a test should be executed on a page generated by some php script:

    Harness.start(
        {
            hostPageUrl     : '../my_php_script?page=home',     // url of the html page for test
            url             : '020_home_page_drag_n_drop.t.js'  // url of the js file, containing actual test code
        },
        ...
    )
             *  
             * 
             */
            hostPageUrl         : null,
            
            
            /**
             * @cfg {Boolean} useStrictMode When set to `false` the test scopes will be created w/o strict mode `DOCTYPE`. Default value is `true`.
             * This option is not applicable for tests with `hostPageUrl` option. 
             * 
             * This option can be also specified in the test file descriptor.
             */
            useStrictMode       : true,
            
            
            /**
             * @cfg {String} runCore Either `parallel` or `sequential`. Indicates how the individual tests should be run - several at once or one-by-one.
             * 
             * Default value is "parallel", except for IE 6, 7, 8 where it's set to `sequential`. You should not need to change this option.
             */
            runCore                 : 'parallel',
            
            /**
             * @cfg {String} simulateEventsWith
             * 
             * This option is IE9-strict mode (and probably above) specific. It specifies how Siesta should simulate events.
             * The options are 'dispatchEvent' (W3C standard) or 'fireEvent' (MS interface) - both are available in IE9 strict mode
             * and each activates different set of event listeners. See this blog post for detailed explanations: 
             * <http://www.digitalenginesoftware.com/blog/archives/76-DOM-Event-Model-Compatibility-or-Why-fireEvent-Doesnt-Trigger-addEventListener.html>
             * 
             * Valid values are "dispatchEvent" and "fireEvent".
             * 
             * The framework specific adapters (like {@link Siesta.Test.ExtJS} and like {@link Siesta.Test.jQuery}) chooses the most appropriate value 
             * automatically (unless explicitly configured). 
             */
            simulateEventsWith  : {
                is      : 'rw',
                init    : 'dispatchEvent'
            },
            
            // the test with currently "forced" (by the "forceDOMVisible" option) iframe 
            testOfForcedIFrame          : null,
            
            /**
             * @cfg {Boolean} autoScrollElementsIntoView
             * 
             * With this option enabled Siesta will try to scroll the invisible action targets into the view automatically, before performing the
             * action. 
             * 
             * This option can also be specified in the test file descriptor.
             */
            autoScrollElementsIntoView  : true,
            
            /**
             * @cfg {Boolean} maintainViewportSize
             * 
             * Enabling this option will cause Siesta to honor the {@link #viewportWidth} and {@link #viewportHeight} configuration options.
             * 
             * This option can also be specified in the test file descriptor.
             */
            maintainViewportSize        : true,
            
            /**
             * @cfg {Number} viewportWidth 
             * 
             * The width of the test iframe, default value is 1024
             */
            viewportWidth               : 1024,
            
            /**
             * @cfg {Number} viewportHeight
             * 
             * The height of the test iframe, default value is 768
             */
            viewportHeight              : 768,
            
            needUI                      : true,
            
            isAutomated                 : false,
            
            // will read the settings from cookies when started
            stateful                    : true
        },
        
        
        after : {
            
            onBeforeScopePreload : function (scopeProvider, url) {
                if (this.viewport) this.viewport.onBeforeScopePreload(scopeProvider, url)
            },
            
            
            onTestSuiteStart : function (descriptors, contentManager) {
                if (this.viewport) this.viewport.onTestSuiteStart(descriptors, contentManager)
            },
            
            
            onTestSuiteEnd : function (descriptors, contentManager) {
                if (this.viewport) this.viewport.onTestSuiteEnd(descriptors, contentManager)
                
                // remove the links to forced iframe / test in hope to ease the memory pressure
                delete this.testOfForcedIFrame
            },
            
            
            onTestStart : function (test) {
                if (this.viewport) this.viewport.onTestStart(test)
                
                if (test.hasForcedIframe()) {
                    if (this.testOfForcedIFrame) this.hideForcedIFrame(this.testOfForcedIFrame)
                
                    this.showForcedIFrame(test)
                
                    this.testOfForcedIFrame     = test
                }        
            },
            
            
            onTestUpdate : function (test, result, parentResult) {
                if (this.viewport) this.viewport.onTestUpdate(test, result, parentResult)
                
                if ((result instanceof Siesta.Result.Diagnostic) && result.isWarning && this.needUI) { 
                    if (typeof console != 'undefined' && console.warn) console.warn(result + '')
                }
            },
            
            
            onTestEnd : function (test) {
                if (test.hasForcedIframe())             this.hideForcedIFrame(test)
                
                if (test == this.testOfForcedIFrame)    this.testOfForcedIFrame = null
                
                if (this.viewport) this.viewport.onTestEnd(test)
                
                // when browser is simulating the event on the element that is not visible in the iframe
                // it will scroll that point into view, using the `scrollLeft` property of the parent element
                // this line fixes that displacement
                var wrapper     = test.scopeProvider.wrapper
                
                if (wrapper) {
                    wrapper.scrollLeft      = wrapper.scrollTop = 0
                }
            },
            
            
            onTestFail : function (test, exception, stack) {
                if (this.viewport) this.viewport.onTestFail(test, exception, stack)
            }
        },
        
        
        methods : {
            createViewport       : function(config) {
                return Ext.create("Siesta.Harness.Browser.UI.Viewport", config);
            },
            
            
            canShowCursorForTest : function (test) {
                // return false for test's running in popups (not iframes), since we can't show any visual accompaniment for them
                if (!(test.scopeProvider instanceof Scope.Provider.IFrame)) return false;
            
                // if there is a "forced to be on top" test then we only need to compare the tests instances
                if (this.testOfForcedIFrame) {
                    return this.testOfForcedIFrame.isFromTheSameGeneration(test)
                }
                
                // finally we can only show cursor for tests with iframe wrapper
                // (since mouse visualizer puts the cursor in it)
                return Boolean(test.scopeProvider.wrapper)
            },
            
            
            configure : function() {
                this.SUPERARG(arguments);

                this.id = this.title || window.location.href;
            },

            
            start : function () {
                // Opera's global variables handling is weird
                if ($.browser.opera) {
                    this.autoCheckGlobals = false;
                }
                
                if ($.browser.msie && $.browser.version !== "9.0") {
                    if (!this.hasOwnProperty('runCore'))            this.runCore            = 'sequential'
                }
                
                this.SUPERARG(arguments)
            },
            
            
            launch : function () {
                var me = this
                
                var args        = arguments
                var SUPER       = this.SUPER
                
                if (this.needUI && !this.viewport) {
                    var cb = function () {
//                        if (Ext.QuickTips) {
//                            Ext.QuickTips.init();
//                        }
//
                        me.viewport = me.createViewport({
                            title           : me.title,
                            harness         : me
                        });
                        
                        // if we are here, then we were requested to show the UI for automated launch
                        // auto-launch the test suite in this case
                        if (me.isAutomated) SUPER.apply(me, args) 
                    };

                    if (Ext.setup) {
                        Ext.setup({ onReady : cb });
                    } else {
                        Ext.onReady(cb) 
                    }
                } else {
                    this.SUPERARG(arguments)
                }
            },
            
            
            populateCleanScopeGlobals : function (scopeProvider, callback) {
                if ($.browser.msie && Number(/^(\d+)/.exec($.browser.version)[ 1 ]) < 9) {
                    // do nothing for IE < 9 - testing leakage of globals is not supported
                    // also IE8 often crashes on this stage
                    this.disableGlobalsCheck = true
                    
                    callback()
                    
                    return
                }
                
                // always populate the globals from IFrame (even if user specified the Window provider)
                this.SUPER('Scope.Provider.IFrame', callback)
            },
            
            
            setup : function (callback) {
                var me      = this
                var sup     = this.SUPER

                // delay the super setup until dom ready
                if (!this.isAutomated) {
                    Ext.onReady(function () {
                        // init the singletone
                        Siesta.Harness.Browser.FeatureSupport();
                    
                        sup.call(me, callback);
                    });
                } else {
                    $(function () {
                        // init the singletone
                        Siesta.Harness.Browser.FeatureSupport();
                    
                        sup.call(me, callback);
                    });
                }
            },
            
            
            getDescriptorConfig : function (descriptor, configName, doNotLookAtRoot) {
                // if its any other config use regular parent implementation
                if (configName != 'preload') return this.SUPERARG(arguments)
                
                var testConfig          = descriptor.testConfig
                
                var hasOwnPreload       = testConfig && testConfig.hasOwnProperty('preload') || descriptor.hasOwnProperty('preload')
                // this will include lookup in the "testConfig"
                var preloadValue        = this.lookUpValueInDescriptorTree(descriptor, 'preload')
                
                var hasHostPageUrl      = Boolean(this.getDescriptorConfig(descriptor, 'hostPageUrl', true))
                
                // for host page url, if we found preload value which is not inherit, then return it if its own (defined on the descriptor)
                // otherwise return empty array
                if (hasHostPageUrl && preloadValue != 'inherit') return hasOwnPreload ? preloadValue : []
                        
                do {
                    var testConfig      = descriptor.testConfig
                    var testHasPreload  = testConfig && testConfig.hasOwnProperty('preload')
                    
                    if (testHasPreload || descriptor.hasOwnProperty('preload')) {
                        var preload     = testHasPreload ? testConfig.preload : descriptor.preload
                        
                        if (preload != 'inherit') return preload
                    }
                    
                    descriptor          = descriptor.parent
                    
                } while (descriptor && descriptor != this)
                    
                if (doNotLookAtRoot) 
                    return undefined
                else
                    return this.preload
            },
            
            
            getScopeProviderConfigFor : function (desc, launchId) {
                var config                      = this.SUPERARG(arguments)
                
                config.cls                      = 'tr-iframe'
                config.performWrap              = true
                config.wrapCls                  = 'tr-iframe-wrapper'
                config.sourceURL                = config.sourceURL || this.getDescriptorConfig(desc, 'hostPageUrl')
                config.minViewportSize          = config.minViewportSize || {
                    width   : this.getDescriptorConfig(desc, 'viewportWidth'),
                    height  : this.getDescriptorConfig(desc, 'viewportHeight')
                }
                
                if (!config.hasOwnProperty('useStrictMode')) config.useStrictMode = this.getDescriptorConfig(desc, 'useStrictMode')
                
                return config
            },
            
            
            getNewTestConfiguration : function (desc, scopeProvider, contentManager, options, runFunc) {
                var config          = this.SUPERARG(arguments)
                
                if (this.getDescriptorConfig(desc, 'speedRun')) {
                    Joose.O.extend(config, {
                        actionDelay         : 1,
                        dragPrecision       : 20,
                        dragDelay           : 10
                    })
                }
                
                if (this.hasOwnProperty('simulateEventsWith')) config.simulateEventsWith = this.simulateEventsWith
                
                config.forceDOMVisible              = this.getDescriptorConfig(desc, 'forceDOMVisible')
                config.autoScrollElementsIntoView   = this.getDescriptorConfig(desc, 'autoScrollElementsIntoView')
                
                return config
            },
            
            
            runCoreGeneral : function (descriptors, contentManager, options, callback) {
                
                if (this.runCore == 'parallel') {
                    
                    var me                  = this
                    var canRunParallel      = []
                    var mustRunSequential   = []
                    
                    Joose.A.each(descriptors, function (desc) {
                        
                        if (me.getDescriptorConfig(desc, 'forceDOMVisible'))
                            mustRunSequential.push(desc)
                        else
                            canRunParallel.push(desc)
                    })
                    
                    this.runCoreParallel(canRunParallel, contentManager, options, function () {
                        
                        setTimeout(function () {
                            
                            me.runCoreSequential(mustRunSequential, contentManager, options, callback)
                            
                        }, 100)
                    })
                
                } else
                    this.SUPERARG(arguments)
            },
            
            
            normalizeURL : function (url) {
                // ref to JSAN module - DEPRECATED
                if (/^jsan:/.test(url)) url = '/jsan/' + url.replace(/^jsan:/, '').replace(/\./g, '/') + '.js'
                
                // ref to lib in current dist (no `/` and trailing `.js`) - DEPRECATED 
                if (!/\.js$/.test(url) && !/\//.test(url) && !/\.css(\?.*)?$/i.test(url)) url = '../lib/' + url.replace(/\./g, '/') + '.js'
                
                return url
            },
            
            
            resolveURL : function (url, scopeProvider, desc) {
                // if the `scopeProvider` is provided and it has a sourceURL - then absolutize the preloads relative to that url
                if (scopeProvider && scopeProvider.sourceURL) url = this.absolutizeURL(url)
                
                if (this.disableCaching)
                    // if there's a ?param string in url - append new param
                    if (/\?./.test(url))
                        url += '&disableCaching=' + new Date().getTime()
                    else
                        if (!/\?$/.test(url)) 
                            url += '?disableCaching=' + new Date().getTime()
                
                // otherwise assumed to be a raw filename, relative or absolute
                return url
            },
            
            
            absolutizeURL : function (url, baseUrl) {
                // if the url is already absolute - just return it (perhaps with some normalization - 2nd case)
                if (/^(https?|file):\/\//.test(url))  return url
                if (/^\//.test(url))    return this.baseProtocol + '//' + this.baseHost + url
                
                baseUrl             = baseUrl || this.baseUrl
                
                // strip the potential query and filename from baseURL, leaving only the "directory" part
                baseUrl             = baseUrl.replace(/\?.*$/,'').replace(/\/[^/]*$/, '/')
                
                // first absolutize the base url relative the harness page (which will be always global, so it won't recurse)
                var absBaseUrl      = this.absolutizeURL(baseUrl, this.baseUrl)
                
                // add a trailing "/" if missing
                absBaseUrl          = absBaseUrl.replace(/\/?$/, '/')
                
                return absBaseUrl + url
            },
            
            
            showForcedIFrame : function (test) {
                $.rebindWindowContext(window);
                
                var wrapper     = test.scopeProvider.wrapper
                
                $(wrapper).addClass('tr-iframe-forced')
                $(wrapper).removeClass('tr-iframe-hidden')
            
                $(wrapper).center()
                
                test.fireEvent('testframeshow')
            },
        
        
            hideForcedIFrame : function (test) {
                $.rebindWindowContext(window);
                
                var wrapper     = test.scopeProvider.wrapper
                
                $(wrapper).removeClass('tr-iframe-forced')
                $(wrapper).addClass('tr-iframe-hidden')
                
                test.fireEvent('testframehide')
            },
            
            getQueryParam : function (paramName) {
                var regex       = new RegExp('(?:\\?|&)' + paramName + '=(.*?)(?:\\?|&|$)', 'i')
            
                var match       = regex.exec(window.location.search)
            
                if (!match) return null
            
                return match[ 1 ]
            }
        }
        
    }
    //eof my
})
//eof Siesta.Harness.Browser;
Singleton('Siesta.Harness.Browser.FeatureSupport', {
    
    has     : {
        supports    : Joose.I.Object,
        
        tests       : {
            init        : [
                {
                    id : "mouseEnterLeave",
                    fn : function() {
                        var el = document.createElement("div");
                        return 'onmouseenter' in el && 'onmouseleave' in el;
                    }
                },
        
                {
                    id : "enterOnAnchorTriggersClick",
                    fn : function() {
                        var sim     = this.simulator,
                            E       = Siesta.Test.Simulate.KeyCodes().keys.ENTER,
                            result  = false;
                            
                        var anchor = $('<a href="foo" style="display:none">test me</a>');
                        $('body').append(anchor);
        
                        anchor.focus();
                        anchor.click(function(e) {
                            result = true;
                            return false;
                        });
                
                        sim.simulateEvent(anchor, 'keypress', { keyCode : E, charCode : 0 }, true);
                 
                        anchor.remove();
                        return result;
                    }
                },
        
                {
                    id : "canSimulateKeyCharacters",
                    fn : function() {
                        var sim     = this.simulator;
                        
                        var input   = $('<input class="siesta-hidden" type="text" />'),
                            A       = Siesta.Test.Simulate.KeyCodes().keys.A;
                            
                        $('body').append(input);
                        
                        input.focus();
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A }, true);
                        sim.simulateEvent(input, 'textInput', { text : "A" }, true);
                
                        var result  = input.val() === 'A';
                        
                        input.remove();
                        
                        return result;
                    }
                },
        
                {
                    id : "canSimulateBackspace",
                    fn : function() {
                        var sim     = this.simulator;
                        
                        var input   = $('<input class="siesta-hidden" type="text" />'),
                            BS      = Siesta.Test.Simulate.KeyCodes().keys.BACKSPACE,
                            A       = Siesta.Test.Simulate.KeyCodes().keys.A;
                            
                        $('body').append(input);
                        
                        input.focus();
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A }, true);
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A }, true);
                        sim.simulateEvent(input, 'keypress', { keyCode : BS, charCode : BS }, true);
                        
                        var result  = input.val() === 'A';
                 
                        input.remove();
                        
                        return result;
                    }
                },

                {
                    id : "enterSubmitsForm",
                    fn : function() {
                        var sim     = this.simulator,
                            E       = Siesta.Test.Simulate.KeyCodes().keys.ENTER,
                            result  = false;

                        var form = $('<form method="post"><input type="text"/></form>');
                        var input = $(form).find('input');
                        $('body').append(form);

                        form[0].onsubmit = function(e) {
                            result = true;
                            return false;
                        };

                        input.focus();
                        sim.simulateEvent(input, 'keypress', { keyCode : E, charCode : 0 }, true);

                        form.remove();
                        return result;
                    }
                }
            ]
        }
        
    },
    
    methods     : {
        
        initialize : function() {
            var emptyFn = function() {},
                foo = Class({
                    does    : [
                        Siesta.Test.Simulate.Event,
                        Siesta.Test.Simulate.Mouse,
                        Siesta.Test.Simulate.Keyboard
                    ],
                
                    has     : {
                        global      : null
                    },
                
                    methods : {
                        focusOnClick        : emptyFn,
                        getElementAtCursor  : emptyFn,
                        fireEvent           : emptyFn,
                        addResult           : emptyFn,
                        normalizeElement    : function(a) { return a[0]; },
                        findCenter          : function() { return [0,0]; },
                        valueIsArray        : function(arr) { return 'length' in arr; }
                    }
                });
            
            this.simulator = new foo({ global : window });
    
            for (var i = 0; i < this.tests.length; i++) {
                var test            = this.tests[i];
                var testId          = test.id;
                var detectorFn      = test.fn;
                
                // also save the results to "results" property - we'll use this in out own test suite
                // where we copy the feature testing results from the outer scope to inner
                this.supports[ testId ] = detectorFn.call(this);
            }
        }
    }
})
;
/**
@class Siesta.Harness.Browser.ExtJSCore

This is a role (mixin), representing the shared functionality between ExtJS and SenchaTouch harnesses.

*/
Role('Siesta.Harness.Browser.ExtJSCore', {
    
    has : {
        /**
         * @cfg {Object} loaderPath
         * 
         * The path used to configure the Ext.Loader, for dynamic loading of Ext JS classes. 
         * 
         * By default the value will be set right before the test starts. If you need to set it earlier (during preloading phase),
         * use {@link #getLoaderPathHook} method. 
         *
         * This option can be also specified in the test file descriptor. 
         */
        loaderPath              : null,
        
        
        // Set to true to fail t.knownBugInStatements, useful when running against Ext JS nightly builds
        failKnownBugIn          : false
    },
    
    override : {
        getNewTestConfiguration : function (desc, scopeProvider, contentManager, options, runFunc) {
            var config              = this.SUPERARG(arguments)
            
            config.loaderPath       = this.getDescriptorConfig(desc, 'loaderPath')
            
            return config
        }
    },
    
    methods : {
        
        generateLoaderPathHook : function () {
            // Such tedious check to allow setting the paths without crash for Ext JS versions < 4
            // (which may have own "Ext.Loader" object)
            return function (StartTest, Ext, loaderPath) {
                if (!loaderPath || StartTest.loaderPathHookInstalled || !Ext || !Ext.Loader || !Ext.Loader.setPath) return
                
                StartTest.loaderPathHookInstalled   = true
                
                Ext.Loader.setPath(loaderPath)
            }
        },
        
        
        /**
         * Returns a string presentation of the ExtJS/SenchaTouch hook for setting "Ext.Loader" paths, suitable to be used in the test's 
         * {@link Siesta.Harness#preload preloads}. This will allow you to install the hook at the earliest possible point, 
         * right after preloading Ext and before "requiring" any classes. 
         * 
         * The value for the paths should be provided in the {@link #loaderPath} config. 
         * The inheritance of the value from groups is supported as usually.   
         * 
         * Typical usage will be:
         * 
    
    var Harness = Siesta.Harness.Browser.ExtJS;

    Harness.configure({
        loaderPath              : { 'My' : 'js', 'My.Namespace' : 'js/somepath' },
        
        preload                 : [
            'http://cdn.sencha.io/ext-4.2.0-gpl/ext-all.js',
            {
                // inject the loader paths right after ExtJS and before the application file
                text    : Harness.getLoaderPathHook()
            },
            'app.js'
        ]
    });

         * 
         * @return {String}
         */
        getLoaderPathHook : function () {
            var hook     = function (installationHook) {
                var parentWindow        = window.opener || window.parent
                var harness             = parentWindow.Siesta.my.activeHarness
                
                eval('(' + installationHook + ')')(StartTest, Ext, harness.getDescriptorConfig(harness.getScriptDescriptor(StartTest.id), "loaderPath"))
            }
            
            return ';(' + hook.toString() + ')(' + JSON.stringify(this.generateLoaderPathHook().toString()) + ')'
        }
    }
});
/**
@class Siesta.Harness.Browser.ExtJS
@extends Siesta.Harness.Browser 
@mixin Siesta.Harness.Browser.ExtJSCore

Class, representing the browser harness. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.ExtJS}, which inherits from 
{@link Siesta.Test.Browser} and contains various ExtJS-specific assertions. So, use this harness class, when testing an ExtJS application.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

Synopsys
========

    var Harness = Siesta.Harness.Browser.ExtJS;
    
    Harness.configure({
        title     : 'Awesome ExtJS Application Test Suite',
        
        transparentEx       : true,
        
        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],
        
        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })
    
    
    Harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
        
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
            
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
        
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
            
            autoCheckGlobals    : false,
            
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/

Class('Siesta.Harness.Browser.ExtJS', {
    
    isa     : Siesta.Harness.Browser,
    
    // pure static class, no need to instantiate it
    my : {
        
        does    : [
            Siesta.Harness.Browser.ExtJSCore
        ],
        
        has     : {
            /**
             * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.ExtJS}.
             * You can subclass {@link Siesta.Test.ExtJS} and provide a new class. 
             * 
             * This option can be also specified in the test file descriptor. 
             */
            testClass           : Siesta.Test.ExtJS,
            
            /**
             * @cfg {Boolean} waitForExtReady
             * 
             * By default the `StartTest` function will be executed after `Ext.onReady`. Set to `false` to launch `StartTest` immediately.  
             * 
             * This option can be also specified in the test file descriptor. 
             */
            waitForExtReady     : true,
            
            /**
             * @cfg {Boolean} waitForAppReady
             * 
             * Setting this configuration option to "true" will cause Siesta to wait until the ExtJS MVC application on the test page will become ready,
             * before starting the test. More precisely it will wait till the first "launch" event from any instance of `Ext.app.Application` class on the page.
             *   
             * This option can (and probably should) be also specified in the test file descriptor. 
             */
            waitForAppReady     : false,
            

            extVersion              : null,

            /**
             * @cfg {Boolean} allowExtVersionChange
             * 
             * True to show a version picker to swiftly change which Ext JS version is used in the test suite.
             */
            allowExtVersionChange   : false,
            
            extVersionRegExp        : /ext(?:js)?-(\d\.\d+\.\d+.*?)\//,
            
            contentManagerClass     : Siesta.Content.Manager.Browser.ExtJSCore
        },
        
        
        methods : {
            createViewport       : function(config) {
               return Ext.create("Siesta.Harness.Browser.UI.ExtViewport", config);
            },
            
            setup : function (callback) {
                var me      = this
                
                /*
                    This is to be able to pass "next" function form the chain step to the Ext as callback:
                        function (next) {
                            resourceStore.reload({
                                callback : next
                            })
                        }
                    For some reason, Ext performs "isFunction" check on the callback value and only calls it if this check passes
                    (assuming programming does not know what he is doing)
                    "isFunction" check in turn relies on the presence of this property in the Function prototype
                    
                    This line can be removed once "isFunction" in Ext will become cross-context or Ext will stop
                    using "isFunction" check for callbacks
                */
                Function.prototype.$extIsFunction = true;
                
                this.SUPER(function () {
                    if (me.allowExtVersionChange) me.extVersion = me.findExtVersion()
                    
                    callback()
                })
            },
            
        
            getNewTestConfiguration : function (desc, scopeProvider, contentManager, options, runFunc) {
                var config          = this.SUPERARG(arguments)
                
                config.waitForExtReady  = this.getDescriptorConfig(desc, 'waitForExtReady')
                config.waitForAppReady  = this.getDescriptorConfig(desc, 'waitForAppReady')
                
                return config
            },
            
            
            setExtVersion : function (newVersion) {
                if (!this.allowExtVersionChange || newVersion == this.extVersion) return
                
                this.extVersion         = newVersion
                
                var me                  = this
                var allDescriptors      = this.flattenDescriptors(this.descriptors)
                var mainPreset          = this.mainPreset
                
                this.setExtVersionForPreset(mainPreset, newVersion)
                
                Joose.A.each(allDescriptors, function (desc) {
                    if (desc.preset != mainPreset) me.setExtVersionForPreset(desc.preset, newVersion)
                })
            },
            
            
            setExtVersionForPreset : function (preset, newVersion) {
                var me      = this
                
                preset.eachResource(function (resource) {
                    var url     = resource.url
                    
                    if (url && url.match(me.extVersionRegExp)) resource.url = url.replace(me.extVersionRegExp, 'ext-' + newVersion + '/')
                })
            },
            
            
            findExtVersion : function () {
                var me      = this
                
                var found
                
                this.mainPreset.eachResource(function (resource) {
                    var match   = me.extVersionRegExp.exec(resource.url)
                    
                    if (match) {
                        found   = match[ 1 ]
                        
                        return false
                    }
                })
                
                return found
            }
        }
    }
});
/**
@class Siesta.Harness.Browser.SenchaTouch
@extends Siesta.Harness.Browser 
@mixin Siesta.Harness.Browser.ExtJSCore

A Class representing the browser harness. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.SenchaTouch}, which inherits from 
{@link Siesta.Test.Browser} and contains various Sencha Touch-specific assertions. Use this harness class when testing Sencha Touch applications.

* **Note** Make sure, you've checked the {@link #performSetup} configuration option. 

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/siesta_getting_started">Getting Started Guide</a>.

Synopsys
========

    var Harness = Siesta.Harness.Browser.SenchaTouch;
        
    Harness.configure({
        title           : 'Awesome Sencha Touch Application Test Suite',
                
        transparentEx   : true,
                
        preload         : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js"
        ]
    })
        
        
    Harness.start(
        // simple string - url relative to harness file
        'sanity.t.js',
                
        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',
                        
            // replace `preload` option of harness
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },
                
        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',
                        
            autoCheckGlobals    : false,
                        
            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/

Class('Siesta.Harness.Browser.SenchaTouch', {

    isa: Siesta.Harness.Browser,

    // pure static class, no need to instantiate it
    my: {

        does    : [
            Siesta.Harness.Browser.ExtJSCore
        ],
        
        has     : {
            /**
            * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.SenchaTouch}.
            * You can subclass {@link Siesta.Test.SenchaTouch} and provide a new class. 
            * 
            * This option can be also specified in the test file descriptor. 
            */
            testClass           : Siesta.Test.SenchaTouch,

            /**
             * @cfg {Boolean} transparentEx
             */
            transparentEx       : true,
            keepResults         : false,
            keepNLastResults    : 0,
            
            /**
             * @cfg {Boolean} performSetup When set to `true`, Siesta will perform a `Ext.setup()` call, so you can safely assume there's a viewport for example.
             * If, however your test code, performs `Ext.setup()` itself, you need to disable this option.
             * 
             * If this option is not explicitly specified in the test descritor, but instead inherited, it will be automatically disabled if test has {@link #hostPageUrl} value.
             * 
             * This option can be also specified in the test file descriptor.
             */
            performSetup        : true,
            
            /**
             * @cfg {String} runCore
             */
            runCore             : 'sequential',

            isRunningOnMobile   : true,
            useExtJSUI          : true,
            
            contentManagerClass : Siesta.Content.Manager.Browser.ExtJSCore
        },


        methods: {
            
            setup : function () {
                // TODO fix proper mobile detection, since Ext may be absent in "no-ui" harness
                this.isRunningOnMobile = typeof Ext !== 'undefined' && Ext.getVersion && Ext.getVersion('touch')
                
                if (!this.isRunningOnMobile) this.keepNLastResults = 2
                
                this.SUPERARG(arguments)
            },


            getNewTestConfiguration: function (desc, scopeProvider, contentManager, options, runFunc) {
                var config = this.SUPERARG(arguments)

                var hostPageUrl = this.getDescriptorConfig(desc, 'hostPageUrl');
                
                if (!desc.hasOwnProperty('performSetup') && hostPageUrl) {
                    config.performSetup = false;
                } else {
                    config.performSetup = this.getDescriptorConfig(desc, 'performSetup')
                }
                
                return config
            },



            createViewport: function (config) {
                if (!this.isRunningOnMobile && this.useExtJSUI) return Ext.create("Siesta.Harness.Browser.UI.ExtViewport", config);
                
                var mainPanel = Ext.create('Siesta.Harness.Browser.UI_Mobile.MainPanel', config);
                
                Ext.Viewport.add(mainPanel);
                
                return mainPanel;
            },

            
            showForcedIFrame : function (test) {
                $.rebindWindowContext(window);
                
                var wrapper     = test.scopeProvider.wrapper

                $(wrapper).css({
                    'z-index'   : 100000
                });
            }
        }
    }
})


;
;
if (typeof Ext !== "undefined" && Ext.versions) {;
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('K M;I(M)1S 2U("2a\'t 4k M 4K 2g 3l 4G 4H");(6(){6 r(f,e){I(!M.1R(f))1S 3m("3s 15 4R");K a=f.1w;f=M(f.1m,t(f)+(e||""));I(a)f.1w={1m:a.1m,19:a.19?a.19.1a(0):N};H f}6 t(f){H(f.1J?"g":"")+(f.4s?"i":"")+(f.4p?"m":"")+(f.4v?"x":"")+(f.3n?"y":"")}6 B(f,e,a,b){K c=u.L,d,h,g;v=R;5K{O(;c--;){g=u[c];I(a&g.3r&&(!g.2p||g.2p.W(b))){g.2q.12=e;I((h=g.2q.X(f))&&h.P===e){d={3k:g.2b.W(b,h,a),1C:h};1N}}}}5v(i){1S i}5q{v=11}H d}6 p(f,e,a){I(3b.Z.1i)H f.1i(e,a);O(a=a||0;a<f.L;a++)I(f[a]===e)H a;H-1}M=6(f,e){K a=[],b=M.1B,c=0,d,h;I(M.1R(f)){I(e!==1d)1S 3m("2a\'t 5r 5I 5F 5B 5C 15 5E 5p");H r(f)}I(v)1S 2U("2a\'t W 3l M 59 5m 5g 5x 5i");e=e||"";O(d={2N:11,19:[],2K:6(g){H e.1i(g)>-1},3d:6(g){e+=g}};c<f.L;)I(h=B(f,c,b,d)){a.U(h.3k);c+=h.1C[0].L||1}Y I(h=n.X.W(z[b],f.1a(c))){a.U(h[0]);c+=h[0].L}Y{h=f.3a(c);I(h==="[")b=M.2I;Y I(h==="]")b=M.1B;a.U(h);c++}a=15(a.1K(""),n.Q.W(e,w,""));a.1w={1m:f,19:d.2N?d.19:N};H a};M.3v="1.5.0";M.2I=1;M.1B=2;K C=/\\$(?:(\\d\\d?|[$&`\'])|{([$\\w]+)})/g,w=/[^5h]+|([\\s\\S])(?=[\\s\\S]*\\1)/g,A=/^(?:[?*+]|{\\d+(?:,\\d*)?})\\??/,v=11,u=[],n={X:15.Z.X,1A:15.Z.1A,1C:1r.Z.1C,Q:1r.Z.Q,1e:1r.Z.1e},x=n.X.W(/()??/,"")[1]===1d,D=6(){K f=/^/g;n.1A.W(f,"");H!f.12}(),y=6(){K f=/x/g;n.Q.W("x",f,"");H!f.12}(),E=15.Z.3n!==1d,z={};z[M.2I]=/^(?:\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\29-26-f]{2}|u[\\29-26-f]{4}|c[A-3o-z]|[\\s\\S]))/;z[M.1B]=/^(?:\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\29-26-f]{2}|u[\\29-26-f]{4}|c[A-3o-z]|[\\s\\S])|\\(\\?[:=!]|[?*+]\\?|{\\d+(?:,\\d*)?}\\??)/;M.1h=6(f,e,a,b){u.U({2q:r(f,"g"+(E?"y":"")),2b:e,3r:a||M.1B,2p:b||N})};M.2n=6(f,e){K a=f+"/"+(e||"");H M.2n[a]||(M.2n[a]=M(f,e))};M.3c=6(f){H r(f,"g")};M.5l=6(f){H f.Q(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,"\\\\$&")};M.5e=6(f,e,a,b){e=r(e,"g"+(b&&E?"y":""));e.12=a=a||0;f=e.X(f);H b?f&&f.P===a?f:N:f};M.3q=6(){M.1h=6(){1S 2U("2a\'t 55 1h 54 3q")}};M.1R=6(f){H 53.Z.1q.W(f)==="[2m 15]"};M.3p=6(f,e,a,b){O(K c=r(e,"g"),d=-1,h;h=c.X(f);){a.W(b,h,++d,f,c);c.12===h.P&&c.12++}I(e.1J)e.12=0};M.57=6(f,e){H 6 a(b,c){K d=e[c].1I?e[c]:{1I:e[c]},h=r(d.1I,"g"),g=[],i;O(i=0;i<b.L;i++)M.3p(b[i],h,6(k){g.U(d.3j?k[d.3j]||"":k[0])});H c===e.L-1||!g.L?g:a(g,c+1)}([f],0)};15.Z.1p=6(f,e){H J.X(e[0])};15.Z.W=6(f,e){H J.X(e)};15.Z.X=6(f){K e=n.X.1p(J,14),a;I(e){I(!x&&e.L>1&&p(e,"")>-1){a=15(J.1m,n.Q.W(t(J),"g",""));n.Q.W(f.1a(e.P),a,6(){O(K c=1;c<14.L-2;c++)I(14[c]===1d)e[c]=1d})}I(J.1w&&J.1w.19)O(K b=1;b<e.L;b++)I(a=J.1w.19[b-1])e[a]=e[b];!D&&J.1J&&!e[0].L&&J.12>e.P&&J.12--}H e};I(!D)15.Z.1A=6(f){(f=n.X.W(J,f))&&J.1J&&!f[0].L&&J.12>f.P&&J.12--;H!!f};1r.Z.1C=6(f){M.1R(f)||(f=15(f));I(f.1J){K e=n.1C.1p(J,14);f.12=0;H e}H f.X(J)};1r.Z.Q=6(f,e){K a=M.1R(f),b,c;I(a&&1j e.58()==="3f"&&e.1i("${")===-1&&y)H n.Q.1p(J,14);I(a){I(f.1w)b=f.1w.19}Y f+="";I(1j e==="6")c=n.Q.W(J,f,6(){I(b){14[0]=1f 1r(14[0]);O(K d=0;d<b.L;d++)I(b[d])14[0][b[d]]=14[d+1]}I(a&&f.1J)f.12=14[14.L-2]+14[0].L;H e.1p(N,14)});Y{c=J+"";c=n.Q.W(c,f,6(){K d=14;H n.Q.W(e,C,6(h,g,i){I(g)5b(g){24"$":H"$";24"&":H d[0];24"`":H d[d.L-1].1a(0,d[d.L-2]);24"\'":H d[d.L-1].1a(d[d.L-2]+d[0].L);5a:i="";g=+g;I(!g)H h;O(;g>d.L-3;){i=1r.Z.1a.W(g,-1)+i;g=1Q.3i(g/10)}H(g?d[g]||"":"$")+i}Y{g=+i;I(g<=d.L-3)H d[g];g=b?p(b,i):-1;H g>-1?d[g+1]:h}})})}I(a&&f.1J)f.12=0;H c};1r.Z.1e=6(f,e){I(!M.1R(f))H n.1e.1p(J,14);K a=J+"",b=[],c=0,d,h;I(e===1d||+e<0)e=5D;Y{e=1Q.3i(+e);I(!e)H[]}O(f=M.3c(f);d=f.X(a);){I(f.12>c){b.U(a.1a(c,d.P));d.L>1&&d.P<a.L&&3b.Z.U.1p(b,d.1a(1));h=d[0].L;c=f.12;I(b.L>=e)1N}f.12===d.P&&f.12++}I(c===a.L){I(!n.1A.W(f,"")||h)b.U("")}Y b.U(a.1a(c));H b.L>e?b.1a(0,e):b};M.1h(/\\(\\?#[^)]*\\)/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?"":"(?:)"});M.1h(/\\((?!\\?)/,6(){J.19.U(N);H"("});M.1h(/\\(\\?<([$\\w]+)>/,6(f){J.19.U(f[1]);J.2N=R;H"("});M.1h(/\\\\k<([\\w$]+)>/,6(f){K e=p(J.19,f[1]);H e>-1?"\\\\"+(e+1)+(3R(f.2S.3a(f.P+f[0].L))?"":"(?:)"):f[0]});M.1h(/\\[\\^?]/,6(f){H f[0]==="[]"?"\\\\b\\\\B":"[\\\\s\\\\S]"});M.1h(/^\\(\\?([5A]+)\\)/,6(f){J.3d(f[1]);H""});M.1h(/(?:\\s+|#.*)+/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?"":"(?:)"},M.1B,6(){H J.2K("x")});M.1h(/\\./,6(){H"[\\\\s\\\\S]"},M.1B,6(){H J.2K("s")})})();1j 2e!="1d"&&(2e.M=M);K 1v=6(){6 r(a,b){a.1l.1i(b)!=-1||(a.1l+=" "+b)}6 t(a){H a.1i("3e")==0?a:"3e"+a}6 B(a){H e.1Y.2A[t(a)]}6 p(a,b,c){I(a==N)H N;K d=c!=R?a.3G:[a.2G],h={"#":"1c",".":"1l"}[b.1o(0,1)]||"3h",g,i;g=h!="3h"?b.1o(1):b.5u();I((a[h]||"").1i(g)!=-1)H a;O(a=0;d&&a<d.L&&i==N;a++)i=p(d[a],b,c);H i}6 C(a,b){K c={},d;O(d 2g a)c[d]=a[d];O(d 2g b)c[d]=b[d];H c}6 w(a,b,c,d){6 h(g){g=g||1P.5y;I(!g.1F){g.1F=g.52;g.3N=6(){J.5w=11}}c.W(d||1P,g)}a.3g?a.3g("4U"+b,h):a.4y(b,h,11)}6 A(a,b){K c=e.1Y.2j,d=N;I(c==N){c={};O(K h 2g e.1U){K g=e.1U[h];d=g.4x;I(d!=N){g.1V=h.4w();O(g=0;g<d.L;g++)c[d[g]]=h}}e.1Y.2j=c}d=e.1U[c[a]];d==N&&b!=11&&1P.1X(e.13.1x.1X+(e.13.1x.3E+a));H d}6 v(a,b){O(K c=a.1e("\\n"),d=0;d<c.L;d++)c[d]=b(c[d],d);H c.1K("\\n")}6 u(a,b){I(a==N||a.L==0||a=="\\n")H a;a=a.Q(/</g,"&1y;");a=a.Q(/ {2,}/g,6(c){O(K d="",h=0;h<c.L-1;h++)d+=e.13.1W;H d+" "});I(b!=N)a=v(a,6(c){I(c.L==0)H"";K d="";c=c.Q(/^(&2s;| )+/,6(h){d=h;H""});I(c.L==0)H d;H d+\'<17 1g="\'+b+\'">\'+c+"</17>"});H a}6 n(a,b){a.1e("\\n");O(K c="",d=0;d<50;d++)c+="                    ";H a=v(a,6(h){I(h.1i("\\t")==-1)H h;O(K g=0;(g=h.1i("\\t"))!=-1;)h=h.1o(0,g)+c.1o(0,b-g%b)+h.1o(g+1,h.L);H h})}6 x(a){H a.Q(/^\\s+|\\s+$/g,"")}6 D(a,b){I(a.P<b.P)H-1;Y I(a.P>b.P)H 1;Y I(a.L<b.L)H-1;Y I(a.L>b.L)H 1;H 0}6 y(a,b){6 c(k){H k[0]}O(K d=N,h=[],g=b.2D?b.2D:c;(d=b.1I.X(a))!=N;){K i=g(d,b);I(1j i=="3f")i=[1f e.2L(i,d.P,b.23)];h=h.1O(i)}H h}6 E(a){K b=/(.*)((&1G;|&1y;).*)/;H a.Q(e.3A.3M,6(c){K d="",h=N;I(h=b.X(c)){c=h[1];d=h[2]}H\'<a 2h="\'+c+\'">\'+c+"</a>"+d})}6 z(){O(K a=1E.36("1k"),b=[],c=0;c<a.L;c++)a[c].3s=="20"&&b.U(a[c]);H b}6 f(a){a=a.1F;K b=p(a,".20",R);a=p(a,".3O",R);K c=1E.4i("3t");I(!(!a||!b||p(a,"3t"))){B(b.1c);r(b,"1m");O(K d=a.3G,h=[],g=0;g<d.L;g++)h.U(d[g].4z||d[g].4A);h=h.1K("\\r");c.39(1E.4D(h));a.39(c);c.2C();c.4C();w(c,"4u",6(){c.2G.4E(c);b.1l=b.1l.Q("1m","")})}}I(1j 3F!="1d"&&1j M=="1d")M=3F("M").M;K e={2v:{"1g-27":"","2i-1s":1,"2z-1s-2t":11,1M:N,1t:N,"42-45":R,"43-22":4,1u:R,16:R,"3V-17":R,2l:11,"41-40":R,2k:11,"1z-1k":11},13:{1W:"&2s;",2M:R,46:11,44:11,34:"4n",1x:{21:"4o 1m",2P:"?",1X:"1v\\n\\n",3E:"4r\'t 4t 1D O: ",4g:"4m 4B\'t 51 O 1z-1k 4F: ",37:\'<!4T 1z 4S "-//4V//3H 4W 1.0 4Z//4Y" "1Z://2y.3L.3K/4X/3I/3H/3I-4P.4J"><1z 4I="1Z://2y.3L.3K/4L/5L"><3J><4N 1Z-4M="5G-5M" 6K="2O/1z; 6J=6I-8" /><1t>6L 1v</1t></3J><3B 1L="25-6M:6Q,6P,6O,6N-6F;6y-2f:#6x;2f:#6w;25-22:6v;2O-3D:3C;"><T 1L="2O-3D:3C;3w-32:1.6z;"><T 1L="25-22:6A-6E;">1v</T><T 1L="25-22:.6C;3w-6B:6R;"><T>3v 3.0.76 (72 73 3x)</T><T><a 2h="1Z://3u.2w/1v" 1F="38" 1L="2f:#3y">1Z://3u.2w/1v</a></T><T>70 17 6U 71.</T><T>6T 6X-3x 6Y 6D.</T></T><T>6t 61 60 J 1k, 5Z <a 2h="6u://2y.62.2w/63-66/65?64=5X-5W&5P=5O" 1L="2f:#3y">5R</a> 5V <2R/>5U 5T 5S!</T></T></3B></1z>\'}},1Y:{2j:N,2A:{}},1U:{},3A:{6n:/\\/\\*[\\s\\S]*?\\*\\//2c,6m:/\\/\\/.*$/2c,6l:/#.*$/2c,6k:/"([^\\\\"\\n]|\\\\.)*"/g,6o:/\'([^\\\\\'\\n]|\\\\.)*\'/g,6p:1f M(\'"([^\\\\\\\\"]|\\\\\\\\.)*"\',"3z"),6s:1f M("\'([^\\\\\\\\\']|\\\\\\\\.)*\'","3z"),6q:/(&1y;|<)!--[\\s\\S]*?--(&1G;|>)/2c,3M:/\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g,6a:{18:/(&1y;|<)\\?=?/g,1b:/\\?(&1G;|>)/g},69:{18:/(&1y;|<)%=?/g,1b:/%(&1G;|>)/g},6d:{18:/(&1y;|<)\\s*1k.*?(&1G;|>)/2T,1b:/(&1y;|<)\\/\\s*1k\\s*(&1G;|>)/2T}},16:{1H:6(a){6 b(i,k){H e.16.2o(i,k,e.13.1x[k])}O(K c=\'<T 1g="16">\',d=e.16.2x,h=d.2X,g=0;g<h.L;g++)c+=(d[h[g]].1H||b)(a,h[g]);c+="</T>";H c},2o:6(a,b,c){H\'<2W><a 2h="#" 1g="6e 6h\'+b+" "+b+\'">\'+c+"</a></2W>"},2b:6(a){K b=a.1F,c=b.1l||"";b=B(p(b,".20",R).1c);K d=6(h){H(h=15(h+"6f(\\\\w+)").X(c))?h[1]:N}("6g");b&&d&&e.16.2x[d].2B(b);a.3N()},2x:{2X:["21","2P"],21:{1H:6(a){I(a.V("2l")!=R)H"";K b=a.V("1t");H e.16.2o(a,"21",b?b:e.13.1x.21)},2B:6(a){a=1E.6j(t(a.1c));a.1l=a.1l.Q("47","")}},2P:{2B:6(){K a="68=0";a+=", 18="+(31.30-33)/2+", 32="+(31.2Z-2Y)/2+", 30=33, 2Z=2Y";a=a.Q(/^,/,"");a=1P.6Z("","38",a);a.2C();K b=a.1E;b.6W(e.13.1x.37);b.6V();a.2C()}}}},35:6(a,b){K c;I(b)c=[b];Y{c=1E.36(e.13.34);O(K d=[],h=0;h<c.L;h++)d.U(c[h]);c=d}c=c;d=[];I(e.13.2M)c=c.1O(z());I(c.L===0)H d;O(h=0;h<c.L;h++){O(K g=c[h],i=a,k=c[h].1l,j=3W 0,l={},m=1f M("^\\\\[(?<2V>(.*?))\\\\]$"),s=1f M("(?<27>[\\\\w-]+)\\\\s*:\\\\s*(?<1T>[\\\\w-%#]+|\\\\[.*?\\\\]|\\".*?\\"|\'.*?\')\\\\s*;?","g");(j=s.X(k))!=N;){K o=j.1T.Q(/^[\'"]|[\'"]$/g,"");I(o!=N&&m.1A(o)){o=m.X(o);o=o.2V.L>0?o.2V.1e(/\\s*,\\s*/):[]}l[j.27]=o}g={1F:g,1n:C(i,l)};g.1n.1D!=N&&d.U(g)}H d},1M:6(a,b){K c=J.35(a,b),d=N,h=e.13;I(c.L!==0)O(K g=0;g<c.L;g++){b=c[g];K i=b.1F,k=b.1n,j=k.1D,l;I(j!=N){I(k["1z-1k"]=="R"||e.2v["1z-1k"]==R){d=1f e.4l(j);j="4O"}Y I(d=A(j))d=1f d;Y 6H;l=i.3X;I(h.2M){l=l;K m=x(l),s=11;I(m.1i("<![6G[")==0){m=m.4h(9);s=R}K o=m.L;I(m.1i("]]\\>")==o-3){m=m.4h(0,o-3);s=R}l=s?m:l}I((i.1t||"")!="")k.1t=i.1t;k.1D=j;d.2Q(k);b=d.2F(l);I((i.1c||"")!="")b.1c=i.1c;i.2G.74(b,i)}}},2E:6(a){w(1P,"4k",6(){e.1M(a)})}};e.2E=e.2E;e.1M=e.1M;e.2L=6(a,b,c){J.1T=a;J.P=b;J.L=a.L;J.23=c;J.1V=N};e.2L.Z.1q=6(){H J.1T};e.4l=6(a){6 b(j,l){O(K m=0;m<j.L;m++)j[m].P+=l}K c=A(a),d,h=1f e.1U.5Y,g=J,i="2F 1H 2Q".1e(" ");I(c!=N){d=1f c;O(K k=0;k<i.L;k++)(6(){K j=i[k];g[j]=6(){H h[j].1p(h,14)}})();d.28==N?1P.1X(e.13.1x.1X+(e.13.1x.4g+a)):h.2J.U({1I:d.28.17,2D:6(j){O(K l=j.17,m=[],s=d.2J,o=j.P+j.18.L,F=d.28,q,G=0;G<s.L;G++){q=y(l,s[G]);b(q,o);m=m.1O(q)}I(F.18!=N&&j.18!=N){q=y(j.18,F.18);b(q,j.P);m=m.1O(q)}I(F.1b!=N&&j.1b!=N){q=y(j.1b,F.1b);b(q,j.P+j[0].5Q(j.1b));m=m.1O(q)}O(j=0;j<m.L;j++)m[j].1V=c.1V;H m}})}};e.4j=6(){};e.4j.Z={V:6(a,b){K c=J.1n[a];c=c==N?b:c;K d={"R":R,"11":11}[c];H d==N?c:d},3Y:6(a){H 1E.4i(a)},4c:6(a,b){K c=[];I(a!=N)O(K d=0;d<a.L;d++)I(1j a[d]=="2m")c=c.1O(y(b,a[d]));H J.4e(c.6b(D))},4e:6(a){O(K b=0;b<a.L;b++)I(a[b]!==N)O(K c=a[b],d=c.P+c.L,h=b+1;h<a.L&&a[b]!==N;h++){K g=a[h];I(g!==N)I(g.P>d)1N;Y I(g.P==c.P&&g.L>c.L)a[b]=N;Y I(g.P>=c.P&&g.P<d)a[h]=N}H a},4d:6(a){K b=[],c=2u(J.V("2i-1s"));v(a,6(d,h){b.U(h+c)});H b},3U:6(a){K b=J.V("1M",[]);I(1j b!="2m"&&b.U==N)b=[b];a:{a=a.1q();K c=3W 0;O(c=c=1Q.6c(c||0,0);c<b.L;c++)I(b[c]==a){b=c;1N a}b=-1}H b!=-1},2r:6(a,b,c){a=["1s","6i"+b,"P"+a,"6r"+(b%2==0?1:2).1q()];J.3U(b)&&a.U("67");b==0&&a.U("1N");H\'<T 1g="\'+a.1K(" ")+\'">\'+c+"</T>"},3Q:6(a,b){K c="",d=a.1e("\\n").L,h=2u(J.V("2i-1s")),g=J.V("2z-1s-2t");I(g==R)g=(h+d-1).1q().L;Y I(3R(g)==R)g=0;O(K i=0;i<d;i++){K k=b?b[i]:h+i,j;I(k==0)j=e.13.1W;Y{j=g;O(K l=k.1q();l.L<j;)l="0"+l;j=l}a=j;c+=J.2r(i,k,a)}H c},49:6(a,b){a=x(a);K c=a.1e("\\n");J.V("2z-1s-2t");K d=2u(J.V("2i-1s"));a="";O(K h=J.V("1D"),g=0;g<c.L;g++){K i=c[g],k=/^(&2s;|\\s)+/.X(i),j=N,l=b?b[g]:d+g;I(k!=N){j=k[0].1q();i=i.1o(j.L);j=j.Q(" ",e.13.1W)}i=x(i);I(i.L==0)i=e.13.1W;a+=J.2r(g,l,(j!=N?\'<17 1g="\'+h+\' 5N">\'+j+"</17>":"")+i)}H a},4f:6(a){H a?"<4a>"+a+"</4a>":""},4b:6(a,b){6 c(l){H(l=l?l.1V||g:g)?l+" ":""}O(K d=0,h="",g=J.V("1D",""),i=0;i<b.L;i++){K k=b[i],j;I(!(k===N||k.L===0)){j=c(k);h+=u(a.1o(d,k.P-d),j+"48")+u(k.1T,j+k.23);d=k.P+k.L+(k.75||0)}}h+=u(a.1o(d),c()+"48");H h},1H:6(a){K b="",c=["20"],d;I(J.V("2k")==R)J.1n.16=J.1n.1u=11;1l="20";J.V("2l")==R&&c.U("47");I((1u=J.V("1u"))==11)c.U("6S");c.U(J.V("1g-27"));c.U(J.V("1D"));a=a.Q(/^[ ]*[\\n]+|[\\n]*[ ]*$/g,"").Q(/\\r/g," ");b=J.V("43-22");I(J.V("42-45")==R)a=n(a,b);Y{O(K h="",g=0;g<b;g++)h+=" ";a=a.Q(/\\t/g,h)}a=a;a:{b=a=a;h=/<2R\\s*\\/?>|&1y;2R\\s*\\/?&1G;/2T;I(e.13.46==R)b=b.Q(h,"\\n");I(e.13.44==R)b=b.Q(h,"");b=b.1e("\\n");h=/^\\s*/;g=4Q;O(K i=0;i<b.L&&g>0;i++){K k=b[i];I(x(k).L!=0){k=h.X(k);I(k==N){a=a;1N a}g=1Q.4q(k[0].L,g)}}I(g>0)O(i=0;i<b.L;i++)b[i]=b[i].1o(g);a=b.1K("\\n")}I(1u)d=J.4d(a);b=J.4c(J.2J,a);b=J.4b(a,b);b=J.49(b,d);I(J.V("41-40"))b=E(b);1j 2H!="1d"&&2H.3S&&2H.3S.1C(/5s/)&&c.U("5t");H b=\'<T 1c="\'+t(J.1c)+\'" 1g="\'+c.1K(" ")+\'">\'+(J.V("16")?e.16.1H(J):"")+\'<3Z 5z="0" 5H="0" 5J="0">\'+J.4f(J.V("1t"))+"<3T><3P>"+(1u?\'<2d 1g="1u">\'+J.3Q(a)+"</2d>":"")+\'<2d 1g="17"><T 1g="3O">\'+b+"</T></2d></3P></3T></3Z></T>"},2F:6(a){I(a===N)a="";J.17=a;K b=J.3Y("T");b.3X=J.1H(a);J.V("16")&&w(p(b,".16"),"5c",e.16.2b);J.V("3V-17")&&w(p(b,".17"),"56",f);H b},2Q:6(a){J.1c=""+1Q.5d(1Q.5n()*5k).1q();e.1Y.2A[t(J.1c)]=J;J.1n=C(e.2v,a||{});I(J.V("2k")==R)J.1n.16=J.1n.1u=11},5j:6(a){a=a.Q(/^\\s+|\\s+$/g,"").Q(/\\s+/g,"|");H"\\\\b(?:"+a+")\\\\b"},5f:6(a){J.28={18:{1I:a.18,23:"1k"},1b:{1I:a.1b,23:"1k"},17:1f M("(?<18>"+a.18.1m+")(?<17>.*?)(?<1b>"+a.1b.1m+")","5o")}}};H e}();1j 2e!="1d"&&(2e.1v=1v);',62,441,'||||||function|||||||||||||||||||||||||||||||||||||return|if|this|var|length|XRegExp|null|for|index|replace|true||div|push|getParam|call|exec|else|prototype||false|lastIndex|config|arguments|RegExp|toolbar|code|left|captureNames|slice|right|id|undefined|split|new|class|addToken|indexOf|typeof|script|className|source|params|substr|apply|toString|String|line|title|gutter|SyntaxHighlighter|_xregexp|strings|lt|html|test|OUTSIDE_CLASS|match|brush|document|target|gt|getHtml|regex|global|join|style|highlight|break|concat|window|Math|isRegExp|throw|value|brushes|brushName|space|alert|vars|http|syntaxhighlighter|expandSource|size|css|case|font|Fa|name|htmlScript|dA|can|handler|gm|td|exports|color|in|href|first|discoveredBrushes|light|collapse|object|cache|getButtonHtml|trigger|pattern|getLineHtml|nbsp|numbers|parseInt|defaults|com|items|www|pad|highlighters|execute|focus|func|all|getDiv|parentNode|navigator|INSIDE_CLASS|regexList|hasFlag|Match|useScriptTags|hasNamedCapture|text|help|init|br|input|gi|Error|values|span|list|250|height|width|screen|top|500|tagName|findElements|getElementsByTagName|aboutDialog|_blank|appendChild|charAt|Array|copyAsGlobal|setFlag|highlighter_|string|attachEvent|nodeName|floor|backref|output|the|TypeError|sticky|Za|iterate|freezeTokens|scope|type|textarea|alexgorbatchev|version|margin|2010|005896|gs|regexLib|body|center|align|noBrush|require|childNodes|DTD|xhtml1|head|org|w3|url|preventDefault|container|tr|getLineNumbersHtml|isNaN|userAgent|tbody|isLineHighlighted|quick|void|innerHTML|create|table|links|auto|smart|tab|stripBrs|tabs|bloggerMode|collapsed|plain|getCodeLinesHtml|caption|getMatchesHtml|findMatches|figureOutLineNumbers|removeNestedMatches|getTitleHtml|brushNotHtmlScript|substring|createElement|Highlighter|load|HtmlScript|Brush|pre|expand|multiline|min|Can|ignoreCase|find|blur|extended|toLowerCase|aliases|addEventListener|innerText|textContent|wasn|select|createTextNode|removeChild|option|same|frame|xmlns|dtd|twice|1999|equiv|meta|htmlscript|transitional|1E3|expected|PUBLIC|DOCTYPE|on|W3C|XHTML|TR|EN|Transitional||configured|srcElement|Object|after|run|dblclick|matchChain|valueOf|constructor|default|switch|click|round|execAt|forHtmlScript|token|gimy|functions|getKeywords|1E6|escape|within|random|sgi|another|finally|supply|MSIE|ie|toUpperCase|catch|returnValue|definition|event|border|imsx|constructing|one|Infinity|from|when|Content|cellpadding|flags|cellspacing|try|xhtml|Type|spaces|2930402|hosted_button_id|lastIndexOf|donate|active|development|keep|to|xclick|_s|Xml|please|like|you|paypal|cgi|cmd|webscr|bin|highlighted|scrollbars|aspScriptTags|phpScriptTags|sort|max|scriptScriptTags|toolbar_item|_|command|command_|number|getElementById|doubleQuotedString|singleLinePerlComments|singleLineCComments|multiLineCComments|singleQuotedString|multiLineDoubleQuotedString|xmlComments|alt|multiLineSingleQuotedString|If|https|1em|000|fff|background|5em|xx|bottom|75em|Gorbatchev|large|serif|CDATA|continue|utf|charset|content|About|family|sans|Helvetica|Arial|Geneva|3em|nogutter|Copyright|syntax|close|write|2004|Alex|open|JavaScript|highlighter|July|02|replaceChild|offset|83'.split('|'),0,{}))
;
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('(2(){1 h=5;h.I=2(){2 n(c,a){4(1 d=0;d<c.9;d++)i[c[d]]=a}2 o(c){1 a=r.H("J"),d=3;a.K=c;a.M="L/t";a.G="t";a.u=a.v=2(){6(!d&&(!8.7||8.7=="F"||8.7=="z")){d=q;e[c]=q;a:{4(1 p y e)6(e[p]==3)B a;j&&5.C(k)}a.u=a.v=x;a.D.O(a)}};r.N.R(a)}1 f=Q,l=h.P(),i={},e={},j=3,k=x,b;5.T=2(c){k=c;j=q};4(b=0;b<f.9;b++){1 m=f[b].w?f[b]:f[b].S(/\\s+/),g=m.w();n(m,g)}4(b=0;b<l.9;b++)6(g=i[l[b].E.A]){e[g]=3;o(g)}}})();',56,56,'|var|function|false|for|SyntaxHighlighter|if|readyState|this|length|||||||||||||||||true|document||javascript|onload|onreadystatechange|pop|null|in|complete|brush|break|highlight|parentNode|params|loaded|language|createElement|autoloader|script|src|text|type|body|removeChild|findElements|arguments|appendChild|split|all'.split('|'),0,{}))
;
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
;(function()
{
	// CommonJS
	typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter : null;

	function Brush()
	{
		var keywords =	'break case catch continue ' +
						'default delete do else false  ' +
						'for function if in instanceof ' +
						'new null return super switch ' +
						'this throw true try typeof var while with'
						;

		var r = SyntaxHighlighter.regexLib;
		
		this.regexList = [
			{ regex: r.multiLineDoubleQuotedString,					css: 'string' },			// double quoted strings
			{ regex: r.multiLineSingleQuotedString,					css: 'string' },			// single quoted strings
			{ regex: r.singleLineCComments,							css: 'comments' },			// one line comments
			{ regex: r.multiLineCComments,							css: 'comments' },			// multiline comments
			{ regex: /\s*#.*/gm,									css: 'preprocessor' },		// preprocessor tags like #region and #endregion
			{ regex: new RegExp(this.getKeywords(keywords), 'gm'),	css: 'keyword' }			// keywords
			];
	
		this.forHtmlScript(r.scriptScriptTags);
	};

	Brush.prototype	= new SyntaxHighlighter.Highlighter();
	Brush.aliases	= ['js', 'jscript', 'javascript'];

	SyntaxHighlighter.brushes.JScript = Brush;

	// CommonJS
	typeof(exports) != 'undefined' ? exports.Brush = Brush : null;
})();
;
Ext.define('ExtX.Reference.Slot', {
    override : 'Ext.Component',

    slot            : null,
    __COLLECTOR__   : null,

    onRemoved : function() {
        if (this.__COLLECTOR__) {
            delete this.__COLLECTOR__.slots[this.slot]
            delete this.__COLLECTOR__
        }
    
        this.callOverridden(arguments)
    },


    beforeDestroy : function () {
        if (this.__COLLECTOR__) {
            delete this.__COLLECTOR__.slots[this.slot]
            delete this.__COLLECTOR__
        }
    
        this.callOverridden(arguments)
    }
})


Ext.define('ExtX.Reference.Slot2', {

    override : 'Ext.Container',

    slots       : null,

    onAdd : function () {
    
        this.cascade(function (comp) {
            if (comp.slot && !comp.__COLLECTOR__) {
        
                var parentWithSlots = comp.__COLLECTOR__ = comp.up('{slots}')
            
                if (parentWithSlots) parentWithSlots.slots[ comp.slot ] = comp
            }
        })
    },

    initComponent : function () {
        if (this.slots) this.slots = {}
    
        this.callOverridden()
    }
})
;
(function () {
    var config = {
        idProperty : 'id',

        fields : [
            'id',
            'url',

            'title',

            { name : 'passCount', type : 'int', defaultValue : 0 },
            { name : 'failCount', type : 'int', defaultValue : 0 },
            { name : 'todoPassCount', type : 'int', defaultValue : 0 },
            { name : 'todoFailCount', type : 'int', defaultValue : 0 },

            { name : 'time', type : 'int', defaultValue : 0 },

            { name : 'checked', defaultValue : false },

            { name : 'folderStatus', defaultValue : 'yellow' },

            // will be set to true for all tests, once the users clicks "run"
            'isStarting',
            // will be set to true, right before the scope preload begin
            'isStarted',
            // will be set to true, after preload ends and tests launch
            { name : 'isRunning', type : 'boolean', defaultValue : false },
            { name : 'isMissing', type : 'boolean', defaultValue : false },
            { name : 'isFailed', type : 'boolean', defaultValue : false },

            // composite objects
            'assertionsStore',
            'test',
            'descriptor'
        ]
    };
    
    var isSenchaTouch = Ext.getVersion && Ext.getVersion('touch')

    Ext.define(
        'Siesta.Harness.Browser.Model.TestFile',
        
        Ext.apply({
            extend      : 'Ext.data.Model',
            
            init        : function () {
                this.internalId = this.getId() || this.internalId
            },
    
            computeFolderStatus : function () {
                if (!this.childNodes.length) return 'yellow'
    
                var isWorking = false
                var hasFailed = false
                var allGreen = true
    
                Joose.A.each(this.childNodes, function (childNode) {
    
                    if (childNode.isLeaf()) {
                        var test = childNode.get('test')
    
                        if (test && test.isFailed()) {
                            allGreen = false
                            hasFailed = true
    
                            // stop iteration
                            return false
                        }
    
                        if (!test && childNode.get('isStarting'))    isWorking = true
                        if (test && !test.isFinished())     isWorking = true
                        if (test && !test.isPassed())       allGreen = false
                        if (!test)                          allGreen = false
    
                    } else {
                        var status = childNode.computeFolderStatus()
    
                        if (status == 'red') {
                            allGreen = false
                            hasFailed = true
    
                            // stop iteration
                            return false
                        }
    
                        if (status == 'working') {
                            isWorking = true
    
                            // stop iteration
                            return false
                        }
    
                        if (status == 'yellow')         allGreen = false
                    }
                })
    
                if (isWorking)  return 'working'
                if (hasFailed)  return 'red'
                if (allGreen)   return 'green'
    
                return 'yellow'
            },
    
    
            updateFolderStatus : function () {
                this.set('folderStatus', this.computeFolderStatus())
    
                var parentNode = this.parentNode
    
                if (parentNode && !parentNode.isRoot()) parentNode.updateFolderStatus()
            }
        }, isSenchaTouch ? { config : config } : config),
        // eof Ext.apply
        
        function () {
            if (!isSenchaTouch) {
                Ext.data.NodeInterface.decorate(this);
    
                this.override({
                    expand : function () {
                        Ext.suspendLayouts();
                        this.callParent(arguments);
                        Ext.resumeLayouts();
                    }
                });
            }
        }
    )
})();
;
(function () {
    var config = {
        idProperty  : 'id',
        
        proxy       : { type : 'memory' },

        fields      : [
            'id',
            { name : 'folderStatus', defaultValue : 'yellow' },
            // the Siesta.Result instance itself
            { name : 'result' }
        ]
    };
    
    var isSenchaTouch = Ext.getVersion && Ext.getVersion('touch')

    Ext.define(
        'Siesta.Harness.Browser.Model.Assertion', 
        
        Ext.apply({
            extend : 'Ext.data.Model',
            
            getResult : function () {
                return this.data.result
            },
            
            
            isAssertion : function () {
                return this.data.result instanceof Siesta.Result.Assertion
            },
            
            
            isDiagnostic : function () {
                return this.data.result instanceof Siesta.Result.Diagnostic
            },
            
            
            isSummary : function () {
                return this.data.result instanceof Siesta.Result.Summary
            },
            
            
            ensureVisible : function () {
                var parent      = this.parentNode
                
                while (parent && !parent.isRoot()) {
                    parent.expand()
                    
                    parent      = parent.parentNode
                }
            },
            
            
            isWaitingAssertion : function () {
                var result      = this.data.result
                
                return this.isAssertion() && result.isWaiting && !result.completed
            },
            
            
            updateFolderStatus : function () {
                if (!this.isLeaf()) this.set('folderStatus', this.computeFolderStatus())
    
                var parentNode = this.parentNode
    
                if (parentNode && !parentNode.isRoot()) parentNode.updateFolderStatus()
            },
            
            
            triggerUIUpdate: function(){
                // This isn't ideal, however none of the underlying fields have changed
                // but we still need to update the UI
                this.afterEdit([]);    
            },

            
            computeFolderStatus : function () {
                if (!this.isLeaf() && this.getResult().isWorking()) return 'working'
                
                if (!this.childNodes.length) return 'yellow'
                
                var isWorking   = false
                var hasFailed   = false
                var allGreen    = true
    
                Joose.A.each(this.childNodes, function (childNode) {
                    var result  = childNode.getResult()
    
                    if (childNode.isLeaf()) {
                        if (childNode.isWaitingAssertion()) 
                            isWorking           = true
                        
                        if (childNode.isAssertion()) {
                            if (!result.isPassed()) {
                                allGreen        = false
                                hasFailed       = true
                                
                                // stop iteration
                                return false
                            }
                        }
    
                    } else {
                        var status = childNode.computeFolderStatus()
    
                        if (status == 'red') {
                            allGreen            = false
                            hasFailed           = true
    
                            // stop iteration
                            return false
                        }
                        
                        if (result.isWorking() || status == 'working') {
                            isWorking           = true
    
                            // stop iteration
                            return false
                        }
    
                        if (status == 'yellow')
                            allGreen            = false
                    }
                })
    
                if (isWorking)  return 'working'
                if (hasFailed)  return 'red'
                if (allGreen)   return 'green'
    
                return 'yellow'
            }
            
        }, isSenchaTouch ? { config : config } : config),
        
        function () {
            if (!isSenchaTouch) {
                Ext.data.NodeInterface.decorate(this);
    
                this.override({
                    expand : function () {
                        Ext.suspendLayouts();
                        this.callParent(arguments);
                        Ext.resumeLayouts();
                    }
                });
            }
        }
    );
})();
;
Ext.define("Sch.data.FilterableNodeStore", {
    extend          : 'Ext.data.NodeStore',
    
    
    onNodeExpand : function (parent, records, suppressEvent) {
        var visibleRecords      = [];
        
        for (var i = 0; i < records.length; i++) {
            var record      = records[ i ];
            
            if (!(record.isHidden && record.isHidden() || record.hidden || record.data.hidden)) visibleRecords[ visibleRecords.length ] = record;
        }
        
        return this.callParent([ parent, visibleRecords, suppressEvent ]);
    }
});;
Ext.define("Sch.data.mixin.FilterableTreeStore", {
    
    requires : [
        'Sch.data.FilterableNodeStore'
    ],
    
    
    nodeStoreClassName      : 'Sch.data.FilterableNodeStore',
    
    nodeStore               : null,
    
    isFilteredFlag          : false,
    
    
    /**
     * Should be called in the constructor of the consuming class, to activate the filteirng functionality.
     */
    initTreeFiltering : function () {
        if (!this.nodeStore) this.nodeStore = this.createNodeStore(this);
        
        this.addEvents(
            'filter-set',
            'filter-clear',
            'nodestore-datachange-start',
            'nodestore-datachange-end'
        );
    },
    
    
    createNodeStore : function (treeStore) {
        return Ext.create(this.nodeStoreClassName, {
            treeStore       : treeStore,
            recursive       : true,
            rootVisible     : this.rootVisible
        });
    },
    
    
    /**
     * Clears current filter (if any).
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    clearTreeFilter : function () {
        if (!this.isTreeFiltered()) return;
        
        this.refreshNodeStoreContent();
        
        this.isFilteredFlag = false;
        
        this.fireEvent('filter-clear', this);
    },
    
    
    refreshNodeStoreContent : function (skipUIRefresh) {
        var root            = this.getRootNode(),
            linearNodes     = [];
            
        var rootVisible     = this.rootVisible;
        
        var collectNodes    = function (node) {
            if (node.isHidden && node.isHidden() || node.hidden || node.data.hidden) return;
            
            if (rootVisible || node != root) linearNodes[ linearNodes.length ] = node;
            
            if (!node.data.leaf && node.isExpanded()) {
                var childNodes  = node.childNodes,
                    length      = childNodes.length;
                
                for (var k = 0; k < length; k++) collectNodes(childNodes[ k ]);
            }
        };
        
        collectNodes(root);
        
        this.fireEvent('nodestore-datachange-start', this);
        
        var nodeStore       = this.nodeStore;
        
        // "loadDataInNodeStore" is a special hook for buffered case
        // in buffered case, instead of "loadRecords" we need to use "cachePage"
        if (!this.loadDataInNodeStore || !this.loadDataInNodeStore(linearNodes)) nodeStore.loadRecords(linearNodes);
        
        // HACK - forcing view to refresh, the usual "refresh" event is blocked by the tree view (see `blockRefresh` property)
        if (!skipUIRefresh) this.fireEvent('forcedrefresh', this);
        
        this.fireEvent('nodestore-datachange-end', this);
    },
    
    
    /**
     * Returns the boolean, indicating whether this store is currently filtered
     * 
     * @return {Boolean}
     */
    isTreeFiltered : function () {
        return this.isFilteredFlag;
    },    
    
    
    /**
     * This method filters the tree store. It accept an object with following properties:
     * 
     * - `filter` - a function to check if the node should be included in the results. It will be called for each **leaf** node in tree and will receive the current node as the first argument.
     * It should return `true` if node should remain visible, `false` otherwise. The results will also contain all parents nodes of all matching leafs. Results will not include
     * parent nodes, which do not have at least one matching child.
     * To call this method for parent nodes too, pass an additional parameter - `checkParents` (see below).
     * - `scope` - a scope to call the filter with (optional)
     * - `checkParents` - when set to `true` will also call the `filter` function for each parent node. If function returns `false` for some parent node, 
     * it still may be included in filter results, if some of its children matches the `filter` (see also "shallow" option below). If function returns `true` for some parent node, it will be
     * included in the filtering results even if it does not have any matching child nodes. 
     * - `shallow` - implies `checkParents`. When set to `true` will stop checking child nodes if the `filter` function return `false` for some parent node. Whole sub-tree, starting
     * from non-matching parent, will be excluded from filtering results in such case.
     * - `onlyParents` - alternative for `checkParents`. When set to `true` will only call the provided `filter` function for parent tasks. If 
     * filter returns `true`, parent, and all its direct children leaf will be included in the results. If `filter` returns `false`, parent node still can
     * be included in the results (w/o direct children leafs), if some of its child nodes matches the filter.
     * - `fullMathchingParents` - implies `onlyParents`. In this mode, if parent node matches the filter, then not only its direct children
     * will be included in the results, but a whole sub-tree, starting form matching node.
     * 
     * Repeated calls to this method will clear previous filters.
     * 
     * This function can be also called with 2 arguments, which should be the `filter` function and `scope` in such case.
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     * 
     * @param {Object} params
     */
    filterTreeBy : function (params, scope) {
        var filter;
        
        if (arguments.length == 1 && Ext.isObject(arguments[ 0 ])) {
            scope       = params.scope;
            filter      = params.filter;
        } else {
            filter      = params;
            params      = {};
        }
        
        this.fireEvent('nodestore-datachange-start', this);
        
        params                  = params || {};
        
        var shallowScan             = params.shallow;
        var checkParents            = params.checkParents || shallowScan;
        var fullMathchingParents    = params.fullMathchingParents;
        var onlyParents             = params.onlyParents || fullMathchingParents;
        var rootVisible             = this.rootVisible;
        
        if (onlyParents && checkParents) throw new Error("Can't combine `onlyParents` and `checkParents` options");
        
        var keepTheseParents    = {};
        
        var root                = this.getRootNode(),
            linearNodes         = [];
        
        var includeParentNodesInResults = function (node) {
            var parent  = node.parentNode;
            
            while (parent && !keepTheseParents[ parent.internalId ]) {
                keepTheseParents[ parent.internalId ] = true;
                
                parent = parent.parentNode;
            }
        };
        
        var collectNodes    = function (node) {
            if (node.isHidden && node.isHidden() || node.hidden || node.data.hidden) return;
            
            var nodeMatches, childNodes, length, k;
            
            // `collectNodes` should not be called for leafs at all
            if (node.data.leaf) {
                if (filter.call(scope, node, keepTheseParents)) {
                    linearNodes[ linearNodes.length ] = node;
                    
                    includeParentNodesInResults(node);
                }
            } else {
                // include _all_ parent nodes in intermediate result set originally, except the root one
                // intermediate result set will be filtered
                if (rootVisible || node != root) linearNodes[ linearNodes.length ] = node;
                
                if (onlyParents) {
                    nodeMatches     = filter.call(scope, node);

                    childNodes      = node.childNodes;
                    length          = childNodes.length;
                        
                    if (nodeMatches) {
                        keepTheseParents[ node.internalId ] = true;
                        
                        includeParentNodesInResults(node);
                        
                        if (fullMathchingParents) {
                            node.cascadeBy(function (currentNode) {
                                if (currentNode != node) {
                                    linearNodes[ linearNodes.length ] = currentNode;
                                    
                                    if (!currentNode.data.leaf) keepTheseParents[ currentNode.internalId ] = true;
                                }
                            });
                            
                            return;
                        }
                    }
                    
                    // at this point nodeMatches and fullMathchingParents can't be both true
                    for (k = 0; k < length; k++)
                        if (nodeMatches && childNodes[ k ].data.leaf) 
                            linearNodes[ linearNodes.length ] = childNodes[ k ];
                        else if (!childNodes[ k ].data.leaf)
                            collectNodes(childNodes[ k ]);
                        
                } else {
                    // mark matching nodes to be kept in results
                    if (checkParents) {
                        nodeMatches = filter.call(scope, node, keepTheseParents);
                        
                        if (nodeMatches) {
                            keepTheseParents[ node.internalId ] = true;
                            
                            includeParentNodesInResults(node);
                        }
                    }
                    
                    // recurse if
                    // - we don't check parents
                    // - shallow scan is not enabled
                    // - shallow scan is enabled and parent node matches the filter or it does not, but its and invisible root, so we don't care
                    if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
                        childNodes      = node.childNodes;
                        length          = childNodes.length;
                        
                        for (k = 0; k < length; k++) collectNodes(childNodes[ k ]);
                    }
                }
            }
        };
        
        collectNodes(root);
        
        // additional filtering of the result set
        // removes the parent nodes which do not match filter themselves and have no macthing children  
        var nodesToKeep = [];
            
        for (var i = 0, len = linearNodes.length; i < len; i++) {
            var node    = linearNodes[ i ];
            
            if (node.data.leaf || keepTheseParents[ node.internalId ]) nodesToKeep[ nodesToKeep.length ] = node;
        }
        
        var nodeStore   = this.nodeStore;
        
        nodeStore.loadRecords(nodesToKeep, false);
        
        // HACK - forcing view to refresh, the usual "refresh" event is blocked by the tree view (see `blockRefresh` property)
        this.fireEvent('forcedrefresh', this);
        
        this.isFilteredFlag = true;
        
        this.fireEvent('nodestore-datachange-end', this);
        
        this.fireEvent('filter-set', this);
    },
    
    
    /**
     * Hide nodes from the tree store rendering presenation (they still remains in the store).
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     * 
     * @param {Function} filter - A filtering function. Will be called for each node in the tree store and receive a current node as 1st argument. Should return `true` to **hide** the node
     * and `false`, to **keep it visible**.
     * @param {Object} scope (optional).
     */
    hideNodesBy : function (filter, scope) {
        if (this.isFiltered()) throw new Error("Can't hide nodes of the filtered tree store");
        
        var me      = this;
        scope       = scope || this;
        
        this.getRootNode().cascadeBy(function (node) {
            node.hidden = filter.call(scope, node, me);
        });
        
        this.refreshNodeStoreContent();
    },
    
    
    /**
     * Shows all nodes, previously hidden with {@link #hideNodesBy}
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    showAllNodes : function () {
        this.getRootNode().cascadeBy(function (node) {
            node.hidden = node.data.hidden = false;
        });
        
        this.refreshNodeStoreContent();
    }
});;
Ext.define('Siesta.Harness.Browser.Model.FilterableTreeStore', {
    extend          : 'Ext.data.TreeStore',

    mixins          : [
        'Sch.data.mixin.FilterableTreeStore'
    ],

    constructor     : function () {
        this.callParent(arguments)
        
        this.initTreeFiltering()
    }

});
Ext.define('Siesta.Harness.Browser.Model.AssertionTreeStore', {
    extend          : 'Ext.data.TreeStore',

    model   : 'Siesta.Harness.Browser.Model.Assertion',

    mixins          : [
        'Sch.data.mixin.FilterableTreeStore'
    ],

    constructor     : function () {
        this.callParent(arguments)
        
        this.initTreeFiltering()
        
        this.nodeStore.setNode(this.getRootNode())
    },
    
    
    removeAll : function () {
//        slow
//        this.getRootNode().removeAll()
        
        var newRoot = this.setRootNode({
            id              : '__ROOT__',
            expanded        : true,
            loaded          : true
        })
        
        this.nodeStore.setNode(newRoot)
    },
    
    
    add : function (record) {
        this.getRootNode().appendChild(record)
    }
});
Ext.define('Siesta.Harness.Browser.UI.VersionField', {
    
    extend  : 'Ext.form.field.Spinner',
    alias   : 'widget.versionfield',

    width   : 90,
    
    // versions : read from harness?
    versions : [
        '4.0.2a',
        '4.0.7',
        '4.1.0',
        '4.1.1',
        '4.1.2',
        '4.1.3',
        '4.1.4'
    ],
    

    onSpinUp: function() {
        var me = this;
        var index = Ext.Array.indexOf(me.versions, me.getValue());
        if (index < me.versions.length - 1) {
            me.setValue(me.versions[index+1]);
        }
    },

    onSpinDown: function() {
        var val, me = this;
        var index = Ext.Array.indexOf(me.versions, me.getValue());
        if (index > 0) {
            me.setValue(me.versions[index-1]);
        }
    }
});
;
// !XXX when adding new methods to this mixing need to also update the 
// `setupLockableTree` method in the Sch.mixin.Lockable
Ext.define("Sch.mixin.FilterableTreeView", {
    
    filterableTreeStore             : null,
    treeStoreFilteringListeners     : null,
    
    
    initTreeFiltering : function () {
        this.treeStoreFilteringListeners = {
            'nodestore-datachange-start'        : this.onFilterChangeStart,
            'nodestore-datachange-end'          : this.onFilterChangeEnd,
            
            'filter-clear'                      : this.onFilterCleared,
            'filter-set'                        : this.onFilterSet,
            'forcedrefresh'                     : this.onForcedRefresh,
            
            scope                               : this
        }
        
        var doInit  = function () {
            var treeStore       = this.up('tablepanel').store;

            this.bindFilterableTreeStore(treeStore)
        };
        
        if (this.rendered)
            doInit.call(this);
        else
            this.on('beforerender', doInit, this, { single : true });
    },
    
    
    bindFilterableTreeStore : function (store) {
        if (this.filterableTreeStore) this.mun(this.filterableTreeStore, this.treeStoreFilteringListeners)
        
        this.filterableTreeStore        = store
        
        if (store) this.mon(store, this.treeStoreFilteringListeners)
    },
    
    
    onForcedRefresh : function () {
        this.focusRow       = function () {}
        
        this.refresh()
        
        delete this.focusRow
    },
    
    
    onFilterChangeStart : function () {
        Ext.suspendLayouts();
    },
    
    
    onFilterChangeEnd : function () {
        Ext.resumeLayouts(true);
    },
    
    
    onFilterCleared : function () {
        delete this.toggle;
        
        var el          = this.getEl();
        
        if (el) el.removeCls('sch-tree-filtered');
    },
    
    
    onFilterSet : function () {
        this.toggle     = function () {};
        
        var el          = this.getEl();
        
        if (el) el.addCls('sch-tree-filtered');
    }
});;
Ext.define('Siesta.Harness.Browser.UI.FilterableTreeView', {
    extend          : 'Ext.tree.View',
    alias           : 'widget.filterabletreeview',
    
    mixins          : [
        'Sch.mixin.FilterableTreeView'
    ],
    
    
    constructor     : function () {
        this.callParent(arguments)
        
        this.initTreeFiltering()
    },
    
    
    bindStore : function (store, initial, propName) {
        if (store instanceof Ext.data.TreeStore) {
            this.bindFilterableTreeStore(store)
            
            this.callParent([ store.nodeStore || store, initial, propName ])
        } else
            this.callParent(arguments)
    }
})
;
Ext.define('Siesta.Harness.Browser.UI.TreeFilterField', {
    extend      : 'Ext.form.field.Trigger',
    alias       : 'widget.treefilter',
    
    filterGroups        : false,
    
    store               : null,
    
    filterField         : 'text',
    
    hasAndCheck         : null,
    andChecker          : null,
    andCheckerScope     : null,
    
    trigger1Cls         : 'x-form-clear-trigger',
    
    triggerLeafCls      : 'tr-filter-trigger-leaf',
    triggerGroupCls     : 'tr-filter-trigger-group',

    
    initComponent : function () {
        var me = this;

        Ext.apply(this, {
            trigger2Cls     : this.triggerLeafCls,
            
            onTrigger1Click : function() {
                me.reset()
            },
            
            onTrigger2Click : function() {
                me.setFilterGroups(!me.getFilterGroups())
            },
            
            listeners       : {
                change          : this.onFilterChange,
                specialkey      : this.onFilterSpecialKey,
                scope           : this,
                
                buffer          : 400
            }
        })
    
        this.callParent(arguments);
    },
    
    
    afterRender : function () {
        this.callParent(arguments)
        
        if (this.filterGroups) {
            this.triggerEl.item(1).addCls(this.triggerGroupCls)
            this.triggerEl.item(1).removeCls(this.triggerLeafCls)
        }
    },
    
    
    onFilterSpecialKey : function(field, e, t) {
        if (e.keyCode === e.ESC) {
            field.reset();
        }
    },
    
    
    setFilterGroups : function (value) {
        if (value != this.filterGroups) {
            this.filterGroups   = value
            
            if (this.rendered) {
                var el      = this.triggerEl.item(1)
                
                if (value) {
                    el.addCls(this.triggerGroupCls)
                    el.removeCls(this.triggerLeafCls)
                } else {
                    el.removeCls(this.triggerGroupCls)
                    el.addCls(this.triggerLeafCls)
                }
            }
            
            this.refreshFilter()
            
            this.fireEvent('filter-group-change', this)
        }
    },
    
    
    getFilterGroups : function () {
        return this.filterGroups
    },
    
    
    refreshFilter : function () {
        this.onFilterChange(this, this.getValue())
    },
    
    
    onFilterChange : function (field, newValue) {
        if (newValue || this.hasAndCheck && this.hasAndCheck()) {
            var field           = this.filterField
            var parts           = newValue.split(/\s*\|\s*/);
            var regexps         = []
            var lengths         = []
            
            for (var i = 0; i < parts.length; i++) {
                // ignore empty
                if (parts[ i ]) {
                    regexps.push(
                        Ext.Array.map(parts[ i ].split(/\s+/), function (token) { return new RegExp(Ext.String.escapeRegex(token), 'i') })
                    )
                    lengths.push(regexps[ regexps.length - 1 ].length)
                }
            }
            
            var andChecker      = this.andChecker
            var andCheckerScope = this.andCheckerScope || this
            
            this.store.filterTreeBy({
                filter  : function (node) {
                    if (andChecker && !andChecker.call(andCheckerScope, node)) return false
                    
                    var title       = node.get(field)
                    
                    for (var p = 0; p < regexps.length; p++) {
                        var groupMatch  = true
                        
                        // blazing fast "for" loop! :)
                        for (var i = 0; i < lengths[ p ]; i++)
                            if (!regexps[ p ][ i ].test(title)) {
                                groupMatch  = false
                                break
                            }
                            
                        if (groupMatch) return true
                    }
                        
                    return false
                },
                fullMathchingParents    : this.filterGroups
            })
        } else {
            this.store.clearTreeFilter()
        }
    }
})
;
Ext.define('Siesta.Harness.Browser.UI.CanFillAssertionsStore', {

    processNewResult : function (assertionStore, test, result, parentResult) {
        var data            = {
            id                  : result.id,
            
            result              : result,
            
            loaded              : true,
            leaf                : !(result instanceof Siesta.Result.SubTest),
            expanded            : (result instanceof Siesta.Result.SubTest) && result.test.specType != 'it'
        };
        
        var alreadyInTheStore   = assertionStore.getById(result.id)
        
        if (alreadyInTheStore) {
            alreadyInTheStore.triggerUIUpdate()
        } else {
            Ext.suspendLayouts()
            
            alreadyInTheStore   = (assertionStore.getById(parentResult.id) || assertionStore.getRootNode()).appendChild(data);
            
            Ext.resumeLayouts()
        }
        
        if (result.isPassed && !result.isPassed()) alreadyInTheStore.ensureVisible()
        
        alreadyInTheStore.updateFolderStatus()
    },
    

    // is bubbling and thus triggered for all tests (including sub-tests) 
    processEveryTestEnd : function (assertionStore, test) {
        var testResultNode  = assertionStore.getById(test.getResults().id)
        
        // can be missing for "root" tests
        testResultNode && testResultNode.updateFolderStatus()
    }
})
;
Ext.define('Siesta.Harness.Browser.UI.DomContainer', {
    extend : 'Ext.Panel',
    alias  : 'widget.domcontainer',
    cls    : 'siesta-domcontainer',

    test          : null,
    testListeners : null,

    maintainViewportSize : true,

    canManageDOM            : true,
    suspendAfterLayoutAlign : false,
    padding                 : 10,
    title                   : 'DOM Panel',
    inspecting              : false,

    initComponent : function () {
        this.testListeners = []

        this.addEvents(
            'startinspection',
            'componenthover',
            'componentselected',
            'stopinspection'
        )

        Ext.apply(this, {
            header       : false,
            collapsible  : true,
            animCollapse : false,

            dockedItems : this.consoleCt = new Ext.Component({
                dock      : 'bottom',
                hidden    : true,
                height    : 20,
                cls       : 'domcontainer-console',
                renderTpl : '<div><input type="text" /></div>'
            })
        });

        this.callParent()

        this.on({
            afterlayout : this.onAfterLayout,
            expand      : this.onExpand,
            collapse    : this.onCollapse,

            scope : this
        })
    },

    afterRender : function () {
        this.callParent(arguments);

        var input = this.consoleInput = this.el.down('.domcontainer-console input');

        this.on('componenthover', function (dc, cmp) {
            input.dom.value = 'Ext.getCmp("' + cmp.id + '").';
        });

        this.on('componentselected', function (dc, cmp) {
            input.focus(true);
        });

        input.on({
            keyup : function (e, t) {
                var val = input.dom.value;

                if (e.getKey() === e.ENTER && val) {
                    var frame = this.getIFrame();
                    try {
                        var retVal = frame.contentWindow.eval(val);
                        if (console) {
                            console.log(retVal);
                        }
                    } catch (e) {
                        console.log(e.message);
                    }
                }
            },
            scope : this
        });
    },

    setCanManageDOM : function (value) {
        if (value != this.canManageDOM) {
            this.canManageDOM = value

            if (value && !this.hidden) this.alignIFrame()
        }
    },


    getIFrameWrapper : function () {
        var test = this.test;

        if (test)
            return this.canManageDOM && test.scopeProvider && test.scopeProvider.wrapper || null
        else
            return null;
    },


    getIFrame : function () {
        var test = this.test;

        if (test)
            return this.canManageDOM && test.scopeProvider && test.scopeProvider.iframe || null
        else
            return null;
    },


    onAfterLayout : function () {
        if (!this.suspendAfterLayoutAlign) this.alignIFrame();
    },


    alignIFrame : function () {
        var wrapper = this.getIFrameWrapper();

        if (!this.isFrameVisible() || !wrapper) return

        Ext.fly(wrapper).removeCls('tr-iframe-hidden')
        Ext.fly(wrapper).removeCls('tr-iframe-forced')

        var box = this.body.getBox()

        Ext.fly(wrapper).setBox(box)

        if (!this.maintainViewportSize) {
            Ext.fly(this.getIFrame()).setSize(this.body.getSize())
        }

        var test = this.test

        test && test.fireEvent('testframeshow')
    },


    onCollapse : function () {
        this.hideIFrame();
    },


    onExpand : function () {
        this.alignIFrame();
    },


    hideIFrame : function () {
        var iframe = this.getIFrameWrapper()

        iframe && Ext.fly(iframe).setLeftTop(-10000, -10000)

        var test = this.test

        test && test.fireEvent('testframehide')
    },


    isFrameVisible : function () {
        return !(this.hidden || this.collapsed)
    },


    showTest : function (test, assertionsStore) {
        this.stopInspection();

        if (this.test) {
            Joose.A.each(this.testListeners, function (listener) {
                listener.remove()
            })

            this.testListeners = []

            this.hideIFrame()
        }

        this.test = test

        this.testListeners = [
            test.on('testfinalize', this.onTestFinalize, this)
        ]

        // when starting the test with forcedIframe - do not allow the assertion grid to change the location of the iframe
        // (canManageDOM is set to false)
        this.setCanManageDOM(!test.hasForcedIframe())

        this.alignIFrame();
    },


    onTestFinalize : function (event, test) {
        this.setCanManageDOM(true)

        // this prevents harness from hiding the iframe, because "test.hasForcedIframe()" will return null
        // we've moved the iframe to the correct position, and it can never be "forced" again anyway
        if (this.isFrameVisible()) test.forceDOMVisible = false
    },


    destroy                 : function () {
        // just in case
        this.hideIFrame()

        Joose.A.each(this.testListeners, function (listener) {
            listener.remove()
        })

        this.test = null

        this.callParent(arguments)
    },

    // BEGIN Inspection related code
    // -----------------------------
    inspectedComponent      : null,
    inspectedComponentXType : null,

    toggleInspectionMode : function (on) {
        if (!this.test) return;

        if (on) {
            this.startInspection();
        } else {
            this.stopInspection();
        }
    },

    startInspection : function (showConsole) {
        if (!this.test) return;

        var frame = this.test.scopeProvider.iframe;
        var _Ext = frame.contentWindow.Ext;

        // This is only relevant for frames containing 'Ext'
        if (!_Ext) return;

        var me = this;
        var wrap = Ext.get(this.getIFrameWrapper());

        me.boxIndicator = me.boxIndicator || wrap.createChild({
            cls      : 'cmp-inspector-box',
            children : {
                tag    : 'a',
                cls    : 'cmp-inspector-label',
                target : '_blank'
            }
        });

        if (showConsole !== false) {
            this.consoleCt.show();
        }

        this.toggleMouseMoveListener(true);

        _Ext.getBody().on('click', this.onInspectionClick, this);
        wrap.on('mouseout', this.onMouseLeave, this);

        this.fireEvent('startinspection', this);

        this.addCls('inspection-mode');

        this.inspecting = true;
    },

    stopInspection : function (suppressEvent) {

        if (!this.inspecting) return;

        this.inspecting = false;

        var wrap = Ext.get(this.getIFrameWrapper());
        var frame = this.test.scopeProvider.iframe;
        var _Ext = frame.contentWindow.Ext;

        if (!_Ext) return;

        Ext.destroy(this.boxIndicator);
        this.boxIndicator = null;

        this.removeCls('inspection-mode');

        this.consoleCt.hide();

        wrap.un('mouseout', this.onMouseLeave, this);

        if (!suppressEvent) {
            this.fireEvent('stopinspection', this);
        }

        this.toggleMouseMoveListener(false);
        _Ext && _Ext.getBody().un('click', this.onInspectionClick, this);

        this.inspectedComponent = this.inspectedComponentXType = null;
    },

    onMouseLeave            : function (e, t) {
        if (!this.el.contains(e.relatedTarget) && !Ext.fly(this.getIFrameWrapper()).contains(e.relatedTarget)) {
            this.stopInspection();
        }
    },

    // Listen for mousemove in the frame and any direct iframe children too
    toggleMouseMoveListener : function (enabled) {
        var frame = this.test.scopeProvider.iframe;
        var _Ext = frame.contentWindow.Ext;
        var frames = _Ext.getBody().select('iframe');
        var fn = enabled ? 'on' : 'un';

        _Ext.getBody()[fn]('mousemove', this.onMouseMove, this, { buffer : 30 });

        for (var i = 0; i < frames.getCount(); i++) {
            var innerExt = frames.item(i).dom.contentWindow.Ext;
            innerExt && innerExt.getBody()[fn]('mousemove', this.onMouseMove, this, { buffer : 30 });
        }
    },

    onInspectionClick : function (e, t) {
        if (e.synthetic || !this.boxIndicator) return;

        this.toggleMouseMoveListener(false);

        // If user clicks on a non-component, or clicking outside currently selected component - we abort
        if (!this.inspectedComponent || this.findComponentByTarget(t) !== this.inspectedComponent) {
            this.stopInspection();
        } else {
            this.fireEvent('componentselected', this, this.inspectedComponent, this.inspectedComponentXType);
        }
    },

    onMouseMove : function (e, t) {
        if (e.synthetic || !this.boxIndicator) return;

        var cmp = this.findComponentByTarget(t);

        if (!cmp || cmp === this.inspectedComponent) return;

        var me = this;

        var xtype = this.resolveComponentXtype(cmp);

        this.inspectedComponent = cmp;
        this.inspectedComponentXType = xtype;

        me.highlightTarget(cmp.el);
        me.updateHighlightContent(cmp, xtype);

        this.fireEvent('componenthover', this, this.inspectedComponent, this.inspectedComponentXType);
    },

    resolveComponentXtype : function(cmp) {
        var xtype = (cmp.getXType && cmp.getXType()) || cmp.xtype;

        // If the found component doesn't have an own xtype, look up the superclass chain to find one
        if (!xtype) {
            var cls = cmp;
            for (var i = 0; i < 10 && !xtype; i++) {
                cls = cmp.superclass;
                xtype = cls.xtype;
            }
        }

        return xtype;
    },

    updateHighlightContent : function (cmp, xtype) {
        var html;
        var link = {
            tag    : 'a',
            cls    : 'cmp-inspector-label',
            href   : '#'
        };

        if (typeof cmp === 'string') {
            html = cmp;
        } else if (Ext.ClassManager) {

            // If recorder is visible, let's add some targeting suggestions
            var recorder = Ext.ComponentQuery.query('recorderpanel')[0];

            if (recorder && recorder.isVisible()) {
                html = '>>' + (recorder.extractor.getOptimalCQForComponent(cmp) || xtype);
            } else {
                var clsName = this.findExtAncestorClassName(cmp);

                if (clsName) {
                    var docsPath = 'http://docs.sencha.com/{0}/#!/api/{1}';
                    var framework;

                    if (Ext.versions.touch) {
                        framework = 'touch';
                    } else {
                        framework = 'extjs';
                    }

                    link.target = '_blank';
                    link.href = Ext.String.format(docsPath, framework, clsName);
                    link.title = 'View documentation for ' + clsName;

                    html = xtype;
                }
            }
        }

        if (html) {
            link.html = html;
            this.boxIndicator.update(Ext.DomHelper.createHtml(link));
        }
    },

    highlightTarget : function (target, content) {
        if (!this.inspecting) {
            this.startInspection();
        }

        var me = this;
        var el = Ext.get(this.test.normalizeElement(target));
        var node = el.dom;
        var boxStyle = me.boxIndicator.dom.style;
        var offsets = this.getOffsets(node);

        // Regular getWidth/getHeight doesn't work if another iframe is on the page
        boxStyle.left = (el.getX() - 1 + offsets[0]) + 'px';
        boxStyle.top = (el.getY() - 1 + offsets[1]) + 'px';
        boxStyle.width = ((el.getWidth() || (parseInt(node.style.width.substring(0, node.style.width.length - 2), 10))) + 2) + 'px';
        boxStyle.height = ((el.getHeight() || (parseInt(node.style.height.substring(0, node.style.height.length - 2), 10))) + 2) + 'px';

        if (content) {
            this.updateHighlightContent(content);
        }
    },

    clearHighlight : function () {
        this.stopInspection();
    },

    findComponentByTarget : function (t) {
        var test = this.test;
        var Ext = test.getExt();
        var testDoc = test.global.document;
        var cmp;

        // Handle potentially having another Ext copy loaded in another frame
        if (t.ownerDocument !== testDoc) {
            var innerFrame = (t.ownerDocument.parentWindow || t.ownerDocument.defaultView).frameElement;
            Ext = innerFrame.contentWindow.Ext;
        }

        while (!cmp && t && t.nodeName !== 'BODY') {
            cmp = Ext.getCmp(t.id);
            t = t.parentNode;
        }

        return cmp;
    },

    getOffsets : function (node) {
        var testDoc = this.test.global.document;
        var offsets = [0, 0];

        if (node.ownerDocument !== testDoc) {
            var innerFrame = (node.ownerDocument.parentWindow || node.ownerDocument.defaultView).frameElement;

            offsets = Ext.fly(innerFrame).getXY();
            offsets[0] -= node.ownerDocument.body.scrollLeft;
            offsets[1] -= node.ownerDocument.body.scrollTop;
        }

        return offsets;
    },

    findExtAncestorClassName : function (cmp) {
        while (cmp) {
            var name = Ext.ClassManager.getName(cmp);
            if (name.match(/^Ext./)) {
                return name;
            }

            cmp = cmp.superclass;
        }

        return '';
    },

    // END Inspection related code
    // -----------------------------

    onDestroy : function() {
        Ext.destroy(this.boxIndicator);
        this.boxIndicator = null;

        this.callParent(arguments);
    }
});;
Ext.define('Siesta.Harness.Browser.UI.MouseVisualizer', {

    cursorEl                    : null,

    onEventSimulatedListener    : null,
    onTestFinishedListener      : null,
    
    harness                     : null,
    
    currentTest                 : null,
    currentContainer            : null,
    
    supportsTransitions         : null,

    clickEvents                 : {
        click       : 0,
        dblclick    : 0,
        touchstart  : 0,
        touchend    : 0,
        mousedown   : 0,
        contextmenu : 0
    },

    constructor : function (config) {
        config      = config || {}
        
        Ext.apply(this, config)
        this.supportsTransitions = (Ext.supports && Ext.supports.Transitions) || (Ext.feature && Ext.feature.has.CssTransitions);

        delete this.harness
        
        this.setHarness(config.harness)
    },
    
    
    getCursorEl : function () {
        if (this.cursorEl) return this.cursorEl
        
        var currentContainer    = this.currentContainer
        
        if (!currentContainer) throw "Need container for cursor"
        
        return this.cursorEl = Ext.fly(currentContainer).down('.ghost-cursor') || Ext.fly(currentContainer).createChild({
            tag     : 'div',
            cls     : 'ghost-cursor'
        })
    },
    
    
    setHarness : function (harness) {
        if (this.harness) {
            this.harness.un('testframeshow', this.onTestFrameShow, this);
            this.harness.un('testframehide', this.onTestFrameHide, this);
        }
        
        this.harness    = harness
    
        if (harness) {
            harness.on('testframeshow', this.onTestFrameShow, this);
            harness.on('testframehide', this.onTestFrameHide, this);
        }
    },

    
    reset : function () {
        if (this.onEventSimulatedListener)  {
            this.onEventSimulatedListener.remove()
            this.onEventSimulatedListener = null
        }
        
        if (this.onTestFinishedListener)    {
            this.onTestFinishedListener.remove()
            this.onTestFinishedListener = null
        }
        
        this.cursorEl           = null
        this.currentTest        = null
        this.currentContainer   = null
    },
    
    
    onTestFrameShow : function (event) {
        var test                            = event.source
        
        // do not react on re-positions of the same running test 
        if (test == this.currentTest) return
        
        this.reset()
        
        this.currentTest    = test
        
        if (this.harness.canShowCursorForTest(test)) {
            this.currentContainer           = test.scopeProvider.wrapper
            
            this.onEventSimulatedListener   = test.on('eventsimulated', this.onEventSimulated, this);
            this.onTestFinishedListener     = test.on('testfinalize', this.onTestFinished, this);
        }
    },

    
    onTestFrameHide : function (event) {
        // ideally, instead of this cleanup, we need to keep listening for the 
        // `testfinalize` event on all tests visualizer has been "attached" to
        // and cleanup only in that event
        this.cleanupCursor()
        this.reset()
    },
    
    
    // this method can be called already after the test has been finalized and cursor element fade out
    // during that time, current test may change, so it needs to work in 2 modes
    // 1) "sync" mode, when its "attached" to the "this.currentTest"  
    // 2) "async" mode, when it cleans up the cursor of the "old" test
    cleanupCursor : function (cursorEl, currentContainer) {
        cursorEl            = cursorEl || this.cursorEl
        currentContainer    = currentContainer || this.currentContainer
        
        if (currentContainer) {
            try {
                Ext.fly(cursorEl).remove()
            } catch (e) {
                // catch potential exceptions for example
                // if iframe of test has been already removed
            }
            
            try {
                Ext.select('.ghost-cursor-click-indicator', false, currentContainer).remove()
            } catch (e) {
                // catch potential exceptions for example
                // if iframe of test has been already removed
            }
        }
    },
    

    onTestFinished : function (event, test) {
        var cursorEl            = this.cursorEl
        var currentContainer    = this.currentContainer
        
        this.reset()
        
        // if test was using cursor at all
        if (cursorEl) {
            var me              = this;
            
            setTimeout(function () {
                // ExtJS branch
                if (cursorEl.fadeOut) {
                    cursorEl.fadeOut({ duration : 2000, callback : function () {
                        me.cleanupCursor(cursorEl, currentContainer)
                    } });
                } else {
                    // ST branch
                    me.cleanupCursor(cursorEl, currentContainer)
                }
            }, 2000);
        }
    },

    
    onEventSimulated : function (event, test, el, type, evt) {
        if (type.match(/touch|mouse|click|contextmenu/) && Ext.isNumber(evt.clientX) && Ext.isNumber(evt.clientY)) {
            // this should never happen, but still happens sometimes
            if (!this.currentContainer) return
            
            var x               = test.currentPosition[0],
                y               = test.currentPosition[1];
                
            this.updateGhostCursor(type, x, y);

            if (this.supportsTransitions && type in this.clickEvents) {
                this.showClickIndicator(type, x, y);
            }
        }
    },

    // This method shows a fading circle at the position of click/dblclick/mousedown/contextmenu
    showClickIndicator : function(type, x, y) {
        var clickCircle = Ext.fly(this.currentContainer).createChild({
            cls     : 'ghost-cursor-click-indicator ' ,
            style   : 'left:' + x + 'px;top:' + y + 'px'
        });

        // need to a delay to make it work in FF
        setTimeout(function() {
            clickCircle.addCls('ghost-cursor-click-indicator-big');
        }, 5);
    },

    
    // This method updates the ghost cursor position and appearance
    updateGhostCursor: function (type, x, y) {
        var cursorEl        = this.getCursorEl(),
            translate3d     = 'translate3d(' + (x - 5) + 'px, ' + y + 'px, 0px)';
        
        cursorEl.setStyle({
            '-webkit-transform' : translate3d,
            '-moz-transform'    : translate3d,
            '-o-transform'      : translate3d,
            'transform'         : translate3d
        })
        
        switch(type) {
            case 'touchstart':
            case 'mousedown':
                cursorEl.addCls('ghost-cursor-press');
            break;

            case 'dblclick':
                cursorEl.addCls('ghost-cursor-press');
                Ext.Function.defer(cursorEl.removeCls, 40, cursorEl, ['ghost-cursor-press']);
            break;

            case 'touchend':
            case 'mouseup':
            case 'click':
                cursorEl.removeCls('ghost-cursor-press');
            break;
        
            case 'contextmenu' :
            break;
        }
    }
});
;
Ext.define('Siesta.Harness.Browser.UI.AssertionGrid', {
    alias           : 'widget.assertiongrid',

    extend          : 'Ext.tree.Panel',
    
    mixins          : [
        'Siesta.Harness.Browser.UI.CanFillAssertionsStore'
    ],

//    requires            : [
//        'Siesta.Harness.Browser.Model.AssertionTreeStore',
//        'Siesta.Harness.Browser.UI.FilterableTreeView',
//        'Siesta.Harness.Browser.UI.TreeColumn'
//    ],

    cls                 : 'siesta-assertion-grid hide-simulated',

    enableColumnHide    : false,
    enableColumnMove    : false,
    enableColumnResize  : false,
    sortableColumns     : false,
    
    border              : false,
    forceFit            : true,
    minWidth            : 100,
    trackMouseOver      : false,
    autoScrollToBottom  : true,
    hideHeaders         : true,
    resultTpl           : null,
    rowLines            : false,
    isStandalone        : false,
    rootVisible         : false,
    collapseDirection   : 'left',
    test                : null,
    testListeners       : null,
    viewType            : 'filterabletreeview',

    initComponent : function() {
        var me = this;
        
        this.testListeners  = []
        
        if (!this.store) this.store = new Siesta.Harness.Browser.Model.AssertionTreeStore({

            proxy   : {
                type        : 'memory',
                reader      : { type: 'json' }
            },

            root    : {
                id          : '__ROOT__',
                expanded    : true,
                loaded      : true
            }
        })

        Ext.apply(this, {
            resultTpl   : new Ext.XTemplate(
                '<span class="assertion-text">{[this.getDescription(values.result)]}</span>{[this.getAnnotation(values)]}',
                {
                    getDescription : function (result) {
                        if (result instanceof Siesta.Result.Summary)
                            return result.description.join('<br>')
                        else
                            return result.isWarning ? 'WARN: ' + result.description : result.description
                    },
                    getAnnotation : function (data) {
                        var annotation = data.result.annotation
                        
                        if (annotation) {
                            return '<pre style="margin-left:' + data.depth * 16 + 'px" class="tr-assert-row-annontation">' + Ext.String.htmlEncode(annotation) + '</pre>'
                        } else
                            return '';
                    }
                }
            ),

            columns     : [
                {
                    xtype           : 'assertiontreecolumn',
                    flex            : 1,
                    
                    dataIndex       : 'folderStatus',
                    renderer        : this.resultRenderer,
                    scope           : this,
                    
                    menuDisabled    : true,
                    sortable        : false
                } 
            ],

            viewConfig  : {
                enableTextSelection     : true,
                stripeRows              : false,
                disableSelection        : true,
                markDirty               : false,
                // Animation is disabled until: http://www.sencha.com/forum/showthread.php?265901-4.2.0-Animation-breaks-the-order-of-nodes-in-the-tree-view&p=974172
                // is resolved
                animate                 : false,
                trackOver               : false,

                // dummy store to be re-defined before showing each test
                store                   : new Ext.data.NodeStore({ fields : [], data : [] }),

                onAdd                   : function (store, records, index) {
                    this.refreshSize    = Ext.emptyFn;
                    var val             = Ext.tree.View.prototype.onAdd.apply(this, arguments);
                    this.refreshSize    = Ext.tree.View.prototype.refreshSize;
                    
                    // Scroll to bottom
                    if (me.autoScrollToBottom) {
                        var el          = this.getEl().dom;
                        el.scrollTop    = el.scrollHeight;
                    }
                    
                    return val;
                },
                
                onUpdate                : function () {
                    this.refreshSize    = Ext.emptyFn;
                    var val             = Ext.tree.View.prototype.onUpdate.apply(this, arguments);
                    this.refreshSize    = Ext.tree.View.prototype.refreshSize;
                    
                    return val;
                },

                // this should be kept `false` - otherwise assertion grid goes crazy, see #477
                deferInitialRefresh     : false,
                
                getRowClass             : this.getRowClass
            }
        });

        this.callParent(arguments);
    },
    
    
    getRowClass : function (record, rowIndex, rowParams, store) {
        var result      = record.getResult()
        
        var cls         = ''
        
        // TODO switch to "instanceof"
        switch (result.meta.name) {
            case 'Siesta.Result.Diagnostic': 
                return 'tr-diagnostic-row ' + (result.isWarning ? 'tr-warning-row' : '');
        
            case 'Siesta.Result.Summary': 
                return 'tr-summary-row ' + (result.isFailed ? ' tr-summary-failure' : '');
        
            case 'Siesta.Result.SubTest':
                cls     = 'tr-subtest-row tr-subtest-row-' + record.get('folderStatus')
                
                if (result.test.specType == 'describe') cls += ' tr-subtest-row-describe'
                if (result.test.specType == 'it') cls += ' tr-subtest-row-it'
            
                return cls;
            
            case 'Siesta.Result.Assertion':
                cls     += 'tr-assertion-row '
            
                if (result.isWaitFor) 
                    cls += 'tr-waiting-row ' + (result.completed ? (result.passed ? 'tr-waiting-row-passed' : 'tr-assertion-row-failed tr-waiting-row-failed') : '')
                else if (result.isException) 
                    cls += result.isTodo ? 'tr-exception-todo-row' : 'tr-exception-row'
                else if (result.isTodo)
                    cls += result.passed ? 'tr-todo-row-passed' : 'tr-todo-row-failed'
                else
                    cls += result.passed ? 'tr-assertion-row-passed' : 'tr-assertion-row-failed'
                
                return cls
            default:
                throw "Unknown result class"
        }
    },    
    
    
    showTest : function (test, assertionsStore) {
        if (this.test) {
            Joose.A.each(this.testListeners, function (listener) { listener.remove() })
            
            this.testListeners  = []
        }
        
        this.test               = test
    
        this.testListeners      = [].concat(
            this.isStandalone ? [
                test.on('testupdate', this.onTestUpdate, this),
                test.on('testendbubbling', this.onEveryTestEnd, this)
            ] : []
        )
        
        Ext.suspendLayouts()

        if (assertionsStore) 
            this.reconfigure(assertionsStore)
        else
            this.store.removeAll()
            
        Ext.resumeLayouts()
    },

    
    onTestUpdate : function (event, test, result, parentResult) {
        this.processNewResult(this.store, test, result, parentResult)
    },
    
    
    // is bubbling and thus triggered for all tests (including sub-tests) 
    onEveryTestEnd : function (event, test) {
        this.processEveryTestEnd(this.store, test)
    },
          
    
    resultRenderer : function (value, metaData, record, rowIndex, colIndex, store) {
        return this.resultTpl.apply(record.data);
    },
    
    
    bindStore : function (treeStore, isInitial, prop) {
        this.callParent(arguments)
        
        this.store    = treeStore;
        
        if (treeStore && treeStore.nodeStore) {
            this.getView().dataSource   = treeStore.nodeStore
            // passing the tree store instance to the underlying `filterabletreeview`
            // the view will re-bind the tree store listeners
            this.getView().bindStore(treeStore, isInitial, prop)
        }
    },
    
    
    destroy : function () {
        Joose.A.each(this.testListeners, function (listener) { listener.remove() })
        
        this.testListeners  = []
        
        this.test           = null
        
        this.callParent(arguments)
    },
    
    
    clear : function () {
        Ext.suspendLayouts()
        
        this.store.removeAll();

        this.getView().getEl().update('<div class="assertiongrid-initializing">Initializing test...</div>');
        
        Ext.resumeLayouts(true)
    }
    
})
;
Ext.define('Siesta.Harness.Browser.UI.TreeColumn', {
    
    extend              : 'Ext.tree.Column',
    alias               : 'widget.assertiontreecolumn',
    
    imgWithOffsetText   : '<img src="{1}" class="{0}" style="left:{2}px" />',
    
    tdCls               : Ext.baseCSSPrefix + 'grid-cell-treecolumn tr-tree-column',

    treeRenderer: function(value, metaData, record, rowIdx, colIdx, store, view){
        var me = this,
            buf = [],
            format = Ext.String.format,
            depth = record.getDepth(),
            treePrefix  = me.treePrefix,
            elbowPrefix = me.elbowPrefix,
            expanderCls = me.expanderCls,
            imgText     = me.imgText,
            checkboxText= me.checkboxText,
            formattedValue = me.origRenderer.apply(me.origScope, arguments),
            blank = Ext.BLANK_IMAGE_URL,
            href = record.get('href'),
            target = record.get('hrefTarget'),
            cls = record.get('cls');

        while (record) {
            if (!record.isRoot() || (record.isRoot() && view.rootVisible)) {
                if (record.getDepth() === depth) {
                    buf.unshift(format(imgText,
                        treePrefix + 'icon ' + 
                        treePrefix + 'icon' + (record.get('icon') ? '-inline ' : (record.isLeaf() ? '-leaf ' : '-parent ')) +
                        (record.get('iconCls') || ''),
                        record.get('icon') || blank
                    ));
                    if (record.get('checked') !== null) {
                        buf.unshift(format(
                            checkboxText,
                            (treePrefix + 'checkbox') + (record.get('checked') ? ' ' + treePrefix + 'checkbox-checked' : ''),
                            record.get('checked') ? 'aria-checked="true"' : ''
                        ));
                        if (record.get('checked')) {
                            metaData.tdCls += (' ' + treePrefix + 'checked');
                        }
                    }
                    if (record.isLast()) {
                        if (record.isExpandable()) {
                            buf.unshift(format(imgText, (elbowPrefix + 'end-plus ' + expanderCls), blank));
                        } else {
                            buf.unshift(format(imgText, (elbowPrefix + 'end'), blank));
                        }
                            
                    } else {
                        if (record.isExpandable()) {
                            buf.unshift(format(imgText, (elbowPrefix + 'plus ' + expanderCls), blank));
                        } else {
                            buf.unshift(format(imgText, (treePrefix + 'elbow'), blank));
                            buf.unshift(format(this.imgWithOffsetText, (treePrefix + 'elbow-line tr-elbow-line'), blank, (record.getDepth() - 1) * 16));
                        }
                    }
                } else {
                    if (record.isLast() || record.getDepth() === 0) {
                        buf.unshift(format(imgText, (elbowPrefix + 'empty'), blank));
                    } else if (record.getDepth() !== 0) {
                        buf.unshift(format(imgText, (elbowPrefix + 'line'), blank));
                        buf.unshift(format(imgText, (elbowPrefix + 'line tr-elbow-line'), blank));
                    }                      
                }
            }
            record = record.parentNode;
        }
        if (href) {
            buf.push('<a href="', href, '" target="', target, '">', formattedValue, '</a>');
        } else {
            buf.push(formattedValue);
        }
        if (cls) {
            metaData.tdCls += ' ' + cls;
        }
        return buf.join('');
    }
});
;
Ext.define('Siesta.Harness.Browser.UI.TestGrid', {
    extend : 'Ext.tree.Panel',
    alias  : 'widget.testgrid',

    requires    : [
        'Siesta.Harness.Browser.UI.FilterableTreeView'
    ],

    // TODO seems there's 4.2.0 bug related to stateful
    stateful    : false,
    forceFit    : true,
    rootVisible : false,
    header      : false,
    rowLines    : false,

    cls                 : 'tr-testgrid',
    width               : 300,
    lines               : false,
    filter              : null,
    enableColumnMove    : false,
    title               : 'Double click a test to run it',
    filterGroups        : false,
    viewType            : 'filterabletreeview',
    resultSummary       : null,
    
    stateConfig         : null,
    
    expanded            : true,
    coverageReportButton    : null,


    initComponent : function () {
        var me = this;

        Ext.apply(this, {

            viewConfig : {
                store               : this.store.nodeStore,
                enableTextSelection : true,
                toggleOnDblClick    : false,
                markDirty           : false,
                trackOver           : false,

                // HACK, prevent layouts on update of a row
                onUpdate            : function () {
                    this.refreshSize = Ext.emptyFn;
                    var val = Ext.tree.View.prototype.onUpdate.apply(this, arguments);
                    this.refreshSize = Ext.tree.View.prototype.refreshSize;

                    return val;
                }
            },

            columns : [
                {
                    xtype    : 'treecolumn',
                    header   : 'Name',
                    sortable : false,

                    dataIndex    : 'title',
                    menuDisabled : true,
                    width        : 180,
                    renderer     : this.treeColumnRenderer,
                    tdCls        : 'test-name-column',
                    scope        : this
                },
                { header : 'Pass', width : 30, sortable : false, tdCls : 'x-unselectable', menuDisabled : true, dataIndex : 'passCount', align : 'center', renderer : this.passedColumnRenderer, scope : this },
                { header : 'Fail', width : 30, sortable : false, tdCls : 'x-unselectable', menuDisabled : true, dataIndex : 'failCount', align : 'center', renderer : this.failedColumnRenderer, scope : this }
//                { header : 'Time', width : 50, sortable : false, dataIndex : 'time', align : 'center', hidden : true }
            ],

            tbar : {
                height : 44,
                border : false,
                cls    : 'main-tbar',
                items  : [
                    {
                        xtype           : 'treefilter',
                        emptyText       : 'Filter tests',
                        
                        itemId          : 'trigger',
                        filterGroups    : this.filterGroups,
                        filterField     : 'title',
                        
                        store           : this.store,
                        
                        width           : 180,
                    
                        cls             : 'filterfield',
                        height          : 30,
                        flex            : 1,

                        trigger1Cls     : 'icon-close',
                        triggerLeafCls  : 'icon-file-2',
                        triggerGroupCls : 'icon-folder'
                    },
                    {
                        width       : 14,
                        cls         : 'toggle-expand',
                        tooltip     : 'Expand / Collapse all',
                        tooltipType : 'title',
                        scope       : this,
                        margin      : '0 0 0 1',

                        handler : function () {
                            this.expanded = !this.expanded;

                            if (this.expanded) {
                                this.expandAll()
                            } else {
                                this.collapseAll()
                            }
                        }
                    }
                ]
            },

            bbar : {
                xtype  : 'container',
                layout : 'hbox',
                items  : [
                    {
                        xtype    : 'toolbar',
                        cls      : 'main-bbar',
                        border   : false,
                        flex     : 1,
                        defaults : {
                            height      : 30,
                            width       : 30,
                            tooltipType : 'title'
                        },

                        items : [
                            {
                                cls        : 'tr-icon-run-checked',
                                iconCls    : 'icon-play',
                                tooltip    : 'Run checked',
                                actionName : 'run-checked',
                                scope      : this,
                                handler    : this.onBtnClicked
                            },
                            {
                                iconCls    : 'icon-forward tr-icon-run-all',
                                tooltip    : 'Run all',
                                actionName : 'run-all',
                                scope      : this,
                                handler    : this.onBtnClicked
                            },
                            {
                                iconCls    : 'icon-play tr-icon-run-failed',
                                tooltip    : 'Run failed',
                                actionName : 'run-failed',
                                scope      : this,
                                handler    : this.onBtnClicked
                            },
                            '->',
                            {
                                tooltip         : 'Show coverage report',
                                action          : 'show-coverage',
                                iconCls         : 'icon-book',
                                width           : 24,
                                disabled        : true,
                                scope           : this,
                                handler         : this.onShowCoverageReport
                            },
                            {
                                tooltip : 'Options...',
                                cls     : 'tr-icon-options',
                                iconCls : 'icon-cog',
                                width   : 38,
                                action  : 'options',
                                menu    : {
                                    itemId    : 'tool-menu',
                                    defaults  : {
                                        scope        : this,
                                        checkHandler : this.onOptionChange
                                    },
                                    listeners : {
                                        beforeshow : this.onSettingsMenuBeforeShow,
                                        scope      : this
                                    }
                                }
                            }
                        ]
                    },
                    {
                        xtype     : 'component',
                        cls       : 'summary-bar',
                        border    : false,
                        width     : 65,
                        itemId    : 'result-summary',
                        renderTpl : '<div><span class="total-pass">{pass}</span><span class="icon-checkmark"></span></div><div><span class="total-fail">{fail}</span><span class="icon-bug"></span></div>'
                    }
                ]
            }
        })

        this.callParent(arguments);
        
        var me          = this
        
        this.store.on({
            'filter-set'        : function () {
                me.down('[cls="toggle-expand"]').disable()
            },
            'filter-clear'      : function () {
                me.down('[cls="toggle-expand"]').enable()
            }            
        })
        
        this.getView().on('beforerefresh', function () {
            var trigger     = me.down('trigger')
            
            if (me.filterGroups)    trigger.setFilterGroups(me.filterGroups)
            if (me.filter)          trigger.setValue(me.filter)

            // fixes wrong widths of the columns
            // TODO remove after upgrade of UI to 4.2.1 or later
            if (!me.filter) setTimeout(function () {
                me.doLayout()
            }, 10)

            // cancel refresh if there's a filter - in this case an additional refresh will be triggered by 
            // the filtering which will be already not canceled since this is 1 time listener
            return !me.filter
        }, null, { single : true })

        this.coverageReportButton = this.down('[action=show-coverage]');
    },

    
    getFilterValue : function () {
        return this.down('trigger').getValue()
    },


    getFilterGroups : function () {
        return this.down('trigger').getFilterGroups()
    },
    
    
    treeColumnRenderer : function (value, metaData, testFile, rowIndex, colIndex, store) {
        metaData.tdCls = 'tr-test-status '
        var cls = '';

        if (testFile.isLeaf()) {

            var test = testFile.get('test')

            if (test) {

                if (testFile.get('isFailed'))
                    cls = 'icon-flag'

                else if (testFile.get('isRunning') && !test.isFinished())
                    cls = 'icon-lightning'
                else if (test.isFinished()) {

                    if (test.isPassed())
                        cls = 'icon-checkmark'
                    else
                        cls = 'icon-bug'
                } else
                    cls = 'icon-busy'

            } else {

                if (testFile.get('isMissing'))
                    cls = 'icon-close'
                else if (testFile.get('isStarting'))
                    cls = 'icon-busy'
                else
                    cls = 'icon-file-2'
            }
        } else {
            cls = (testFile.data.expanded ? 'icon-folder-open' : 'icon-folder') + ' tr-folder-' + testFile.get('folderStatus')
        }
        return '<span class="test-icon ' + cls + '"></span>' + value;
    },


    passedColumnRenderer : function (value, meta, record) {
        if (!record.isLeaf()) return ''

        if (record.data.todoPassCount > 0) {
            value += ' <span title="' + record.data.todoPassCount + ' todo assertion(s) passed" class="tr-test-todo tr-test-todo-pass">+ ' + record.data.todoPassCount + '</span>';
        }
        return value;
    },


    failedColumnRenderer : function (value, meta, record) {
        if (!record.isLeaf()) return ''

        if (record.data.todoFailCount > 0) {
            value += ' <span title="' + record.data.todoFailCount + ' todo assertion(s) failed" class="tr-test-todo tr-test-todo-fail">+ ' + record.data.todoFailCount + '</span>';
        }
        return value;
    },

    onBtnClicked : function (btn) {
        if (btn.actionName) {
            this.fireEvent('buttonclick', this, btn, btn.actionName);
        }
    },

    onSettingsMenuBeforeShow : function (menu) {
        this.fireEvent('beforesettingsmenushow', this, menu);
    },

    onOptionChange : function (button, state) {
        this.fireEvent('optionchange', this, button.option, state);
    },

    // Add menu items lazily
    addMenuItems   : function () {
        var state = this.stateConfig;

        this.down('#tool-menu').add([
            {
                text    : 'View DOM',
                option  : 'viewDOM',
                checked : state.viewDOM
            },
            {
                text    : 'Transparent exceptions',
                option  : 'transparentEx',
                checked : state.transparentEx
            },
            {
                text    : 'Cache preloads',
                option  : 'cachePreload',
                checked : state.cachePreload
            },
            {
                text    : 'Auto launch',
                option  : 'autoRun',
                checked : state.autoRun
            },
            {
                text    : 'Keep results',
                option  : 'keepResults',
                checked : state.keepResults
            },
            {
                text    : 'Speed run',
                option  : 'speedRun',
                checked : state.speedRun
            },
            {
                text    : 'Break on fail',
                option  : 'breakOnFail',
                checked : state.breakOnFail
            },
            { xtype : 'menuseparator' },
            {
                text    : 'About Siesta',
                handler : function () {
                    new Siesta.Harness.Browser.UI.AboutWindow().show();
                }
            },
            {
                text       : 'Siesta Documentation',
                href       : 'http://bryntum.com/docs/siesta',
                hrefTarget : '_blank'
            }
        ]);
    },

    afterRender : function () {
        this.callParent(arguments);

        this.resultSummary = this.down('#result-summary');
        this.down('[action=options]').el.on('mousedown', this.addMenuItems, this, { single : true });
    },

    updateStatus : function (pass, fail) {
        var el = this.resultSummary.el;

        el.update(this.resultSummary.renderTpl.apply({ pass : pass, fail : fail }));
    },

    enableCoverageButton : function () {
        this.coverageReportButton.enable()
    },

    disableCoverageButton : function () {
        this.coverageReportButton.disable()
    },

    onShowCoverageReport : function () {
        this.fireEvent('showcoverageinfo', this);
    }
})
;
Ext.define('Siesta.Harness.Browser.UI.ResultPanel', {
    extend      : 'Ext.Panel',
    alias       : 'widget.resultpanel',

//    requires        : [
//        'Siesta.Harness.Browser.UI.AssertionGrid',
//        'Siesta.Harness.Browser.UI.DomContainer'
//    ],

    slots                   : true,

    test                    : null,
    testListeners           : null,

    maintainViewportSize    : true,

    viewDOM                 : false,
    canManageDOM            : true,
    
    harness                 : null,

    isStandalone            : false,
    showToolbar             : true,
    
    title                   : '&nbsp;',
    style                   : 'background:transparent',
    bodyStyle               : 'background:transparent',
    minWidth                : 100,
    layout                  : 'border',

    sourceButton            : null,
    filterButton            : null,
    inspectionButton        : null,
    recorderPanel           : null,
    

    initComponent : function () {
        var me = this;

        this.addEvents('viewdomchange');

        Ext.apply(this, {
            cls : 'tr-container',

            items : [
                // a card container
                {
                    region     : 'center',
                    slot       : 'cardContainer',
                    xtype      : 'container',
                    layout     : {
                        type           : 'card',
                        deferredRender : true
                    },
                    activeItem : 0,
                    minWidth   : 100,

                    items : [
                        // grid with assertion
                        {
                            xtype : 'assertiongrid',
                            slot  : 'grid',

                            isStandalone : this.isStandalone,
                            listeners    : {
                                itemdblclick : this.onAssertionDoubleClick,
                                scope        : this
                            },

                            tbar : {
                                cls      : 'resultpanel-toolbar',
                                padding  : '10 0',
                                defaults : {
                                    cls         : 'light-button',
                                    tooltipType : 'title',
                                    scope       : this,
                                    margin      : '0 5'
                                },
                                items    : !this.showToolbar ? null : [
                                    {
                                        text    : 'Re-run test',
                                        height  : 28,
                                        margin  : '0 5 0 10',
                                        cls     : 'green-button',
                                        handler : this.onRerun,
                                        style   : 'font-size:1.2em'
                                    },
                                    '->',

                                    {
                                        tooltip : 'Toggle DOM visible',
                                        iconCls : 'icon-screen',
                                        handler : function (btn) {
                                            this.setViewDOM(!this.viewDOM);
                                        }
                                    },
                                    this.sourceButton = new Ext.Button({
                                        tooltip      : 'View source',
                                        action       : 'view-source',
                                        iconCls      : 'icon-file',
                                        tooltipType  : 'title',
                                        enableToggle : true,
                                        pressed      : false,
                                        disabled     : true,
                                        handler      : function (btn) {
                                            if (btn.pressed) {
                                                this.showSource();
                                            }
                                        }
                                    }),
                                    this.filterButton = new Ext.Button({
                                        tooltip     : 'Show only failed',
                                        iconCls     : 'icon-bug',
                                        tooltipType : 'title',

                                        enableToggle : true,
                                        handler      : this.onAssertionFilterClick
                                    }),
                                    this.inspectionButton = new Ext.Button({
                                        iconCls      : 'icon-search',
                                        tooltip      : 'Toggle Ext Dom Inspector',
                                        tooltipType  : 'title',
                                        handler      : this.toggleInspectionMode,
                                        enableToggle : true
                                    }),

                                    {
                                        iconCls  : 'icon-camera',
                                        action   : 'show-recorder',
                                        disabled : !Siesta.Recorder || Ext.isIE9m,
                                        tooltip  : 'Event Recorder',
                                        handler  : this.onRecorderClick
                                    }
                                ]
                            }
                        },
                        // eof grid with assertion
                        {
                            xtype      : 'panel',
                            slot       : 'source',
                            autoScroll : true,
                            cls        : 'test-source-ct',
                            __filled__ : false,
                            layout     : 'absolute',
                            listeners  : {
                                render : function() {
                                    var button = new Ext.Button({
                                        renderTo        : this.el,
                                        floating        : true,
                                        width           : 80,
                                        style           : 'z-index:2;left:auto !important;right:20px !important;top:5px !important;',
                                        text            : 'Close',
                                        handler         : function (btn) {
                                            me.hideSource();
                                        }
                                    })
                                    
                                    // w/o this button is centered in FF
                                    if (Ext.isGecko) setTimeout(function () {
                                        if (!button.destroyed) button.el.setStyle({
                                            left        : 'auto',
                                            right       : '20px',
                                            top         : '5px'
                                        })
                                    }, 0)
                                }
                            }
                        }
                    ]
                },
                {
                    xtype  : 'domcontainer',
                    region : 'east',

                    split : true,

                    bodyStyle : 'text-align : center',

                    slot     : 'domContainer',
                    stateful : true,             // Turn off for recursive siesta demo

                    id    : this.id + '-domContainer',
                    width : '50%',
                    cls   : 'siesta-domcontainer',

                    collapsed : !this.viewDOM
                }
            ]
        })

        this.callParent()

        this.slots.domContainer.on({
            expand   : this.onDomContainerExpand,
            collapse : this.onDomContainerCollapse,

            startinspection : function () {
                this.inspectionButton.toggle(true);
            },
            stopinspection  : function () {
                this.inspectionButton.toggle(false);
            },

            scope : this
        });


    },


    // This method makes sure that the min width of the card panel is respected when
    // the width of this class changes (after resizing Test TreePanel).
    ensureLayout  : function () {
        var availableWidth = this.getWidth();
        var cardPanel = this.slots.cardContainer;
        var domContainer = this.slots.domContainer;
        var domContainerWidth = domContainer.getWidth();
        var minimumForCard = cardPanel.minWidth + 20; // Some splitter space

        if (availableWidth - domContainerWidth < minimumForCard) {
            domContainer.setWidth(Math.max(0, availableWidth - minimumForCard));
        }
    },


    showSource : function (lineNbr) {
        var slots = this.slots
        var cardContainer = slots.cardContainer
        var sourceCt = slots.source
        var test = this.test

        // Do this first since rendering is deferred
        cardContainer.layout.setActiveItem(sourceCt);

        var sourceCtEl = sourceCt.el

        this.sourceButton && this.sourceButton.toggle(true);

        if (test && !sourceCt.__filled__) {
            sourceCt.__filled__ = true;

            sourceCt.update(
                Ext.String.format('<pre class="brush: javascript;">{0}</pre>', test.getSource())
            );

            SyntaxHighlighter.highlight(sourceCtEl);
        }

        sourceCtEl.select('.highlighted').removeCls('highlighted');

        if (arguments.length === 0) {
            // Highlight all failed rows
            Ext.each(test.getFailedAssertions(), function (assertion) {
                if (assertion.sourceLine != null) sourceCtEl.select('.line.number' + assertion.sourceLine).addCls('highlighted');
            });
        }
        else {
            // Highlight just a single row (user double clicked a failed row)
            sourceCtEl.select('.line.number' + parseInt(lineNbr, 10)).addCls('highlighted');
        }

        if (arguments.length && lineNbr != null) {
            var el = sourceCtEl.down('.highlighted');
            el && el.scrollIntoView(sourceCtEl);
        }
    },


    hideSource : function (btn) {
        var slots = this.slots

        var cardContainer = slots.cardContainer

        if (cardContainer.layout.getActiveItem() === slots.source) {
            cardContainer.layout.setActiveItem(slots.grid);
            this.sourceButton && this.sourceButton.toggle(false);
        }
    },


    setViewDOM : function (value) {
        var domContainer = this.slots.domContainer

        if (value)
            domContainer.expand(false)
        else
            domContainer.collapse(Ext.Component.DIRECTION_RIGHT, false)
    },


    onDomContainerCollapse : function () {
        this.viewDOM = false;
        this.fireEvent('viewdomchange', this, false);
    },


    onDomContainerExpand : function () {
        this.viewDOM = true;
        this.fireEvent('viewdomchange', this, true);
    },


    onRerun : function () {
        this.fireEvent('rerun', this);
    },


    showTest : function (test, assertionsStore) {

        var recorder = this.slots.recorderPanel;

        this.slots.source.__filled__ = false;

        this.filterButton && this.filterButton.toggle(false)
        this.hideSource();

        this.sourceButton && this.sourceButton.enable()

        var url = test.url

        Ext.suspendLayouts();

        this.slots.grid.showTest(test, assertionsStore)
        this.slots.domContainer.showTest(test, assertionsStore)

        if (recorder) {
            recorder.stop();
            recorder.attachTo(test);

            if (this.test && test.url !== this.test.url) {
                this.slots.cardContainer.layout.setActiveItem(0);
            }
        }

        // This triggers an unnecessary layout recalc
        this.setTitle(url);

        Ext.resumeLayouts();

        this.test = test;
    },


    onAssertionFilterClick : function (btn) {
        var assertionsStore = this.slots.grid.store;

        // need this check for cases when users clicks on the button
        // before running any test - in this case assertion grid will have an empty Ext.data.TreeStore instance
        if (!assertionsStore.filterTreeBy) return

        if (btn.pressed) {
            assertionsStore.filterTreeBy(function (resultRecord) {
                var result = resultRecord.getResult()

                // this covers the cases when "result" is a summary record, diagnostic record, etc
                return result.passed === false && !result.isTodo
            })
        } else {
            assertionsStore.clearTreeFilter()
        }
    },


    alignIFrame : function () {
        this.slots.domContainer.alignIFrame()
    },


    hideIFrame : function () {
        this.slots.domContainer.hideIFrame()
    },


    clear : function () {
        this.slots.grid.clear()
    },


    onAssertionDoubleClick : function (view, record) {
        var result = record.getResult()

        if ((result instanceof Siesta.Result.Assertion) && !result.isPassed(true)) {
            this.showSource(result.sourceLine);
        }
    },

    toggleInspectionMode : function (btn) {
        this.slots.domContainer.toggleInspectionMode(btn.pressed);
    },

    onRecorderClick : function () {

        var cardContainer = this.slots.cardContainer

        if (!this.recorderPanel) {
            this.recorderPanel = new Siesta.Recorder.RecorderPanel({
                slot        : 'recorderPanel',
                harness     : this.harness,
                domContainer: this.slots.domContainer,
                closeButton : {
                    text    : 'Close',
                    handler : function () {
                        cardContainer.layout.setActiveItem(0);
                    }
                },
                listeners   : {
                    startrecord : function (pnl) {
                        this.fireEvent('startrecord', pnl);
                    },
                    scope       : this
                }
            });
            this.slots.cardContainer.add(this.recorderPanel);

            if (this.test) {
                this.slots.recorderPanel.attachTo(this.test);
            }
        }

        cardContainer.layout.setActiveItem(2);
    }
});

// To avoid the DOM container splitter getting stuck
Ext.dd.DragTracker.override({
    tolerance : 0
});;
Ext.define('Siesta.Harness.Browser.UI.AboutWindow', {
    extend      : 'Ext.Window',
    id          : 'aboutwindow',
    title       : 'ABOUT SIESTA (v.' + (Siesta.meta.VERSION || '1.0.0') + ')',
    bodyPadding : 20,
    modal       : true,
    width       : 500,
    height      : 380,
    closeAction : 'destroy',
    bodyStyle   : 'background: #fff',
    autoScroll  : true,

    html : '<img height="35" src="http://www.bryntum.com/bryntum-logo.png"/>\
         <p>Siesta is a JavaScript unit and functional test tool made by <a target="_blank" href="http://www.bryntum.com">Bryntum</a>. You can test any web page or JavaScript code, including Ext JS, jQuery or NodeJS. \
         \Siesta comes in two versions: <strong>Lite</strong> and <strong>Standard</strong>. With Lite, you can launch your tests in the browser UI. \
         \With the Standard version, you can also automate your tests and use the automation scripts together with tools like PhantomJS or Selenium WebDriver. </p>\
         Siesta would not be possible without these awesome products & libraries: <br>\
                 \<ul style="padding:0 0 0 30px">\
                 \  <li><a href="http://sencha.com/extjs">Ext JS</a></li> \
                 \  <li><a href="http://jquery.com">jQuery</a></li> \
                 \  <li><a href="http://http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></li> \
                 \  <li><a href="http://joose.it/">Joose</a></li> \
                 \  <li><a href="https://github.com/gotwarlost/istanbul">Istanbul</a></li> \
                </ul>',

    buttons : {
        padding : '10 13',
        style   : 'background: transparent',

        items : [
            {
                hidden  : !Siesta.Harness.Browser.Automation,
                text    : 'Upgrade to Siesta Standard',
                handler : function () {
                    window.open('http://bryntum.com/store/siesta');
                }
            },
            {
                text    : 'Close',
                handler : function () {
                    this.up('window').close();
                }
            }
        ]
    }
});;
Ext.define('Siesta.Harness.Browser.UI.VersionChecker', {
    extend      : 'Ext.AbstractPlugin',

    renderTo    : null,

    init : function(viewport) {
        if (Siesta.meta.VERSION) {
            viewport.on('render', this.onViewportRender, this, { delay : 3000 });
        }
    },

    onViewportRender : function() {

        Ext.data.JsonP.request({
            url         : 'http://bryntum.com/siesta_version',
            params      : { v : Siesta.meta.VERSION },
            scope       : this,
            callback    : this.onRequestCompleted
        });
    },

    onRequestCompleted : function(success, data) {
        if (success &&
            data &&
            data.name &&
            new Ext.Version(data.name).isGreaterThan(Siesta.meta.VERSION || '1.0.0'))
        {
            var btn = new Ext.Button({
                renderTo    : this.renderTo,
                style       : 'opacity:0;transition:opacity 1s;',
                text        : 'New Update Available...',
                cls         : 'light-button',
                action      : 'upgrade-siesta',
                handler     : function() { this.showWindow(data.name) },
                scope       : this
            });

            Ext.defer(function() {
                btn.el.setStyle('opacity', 1);
            }, 200);
        }
    },

    showWindow : function (latestVersion) {
        var win = new Ext.Window({
            cls         : 'changelog-window',
            title       : 'New version available for download! Current version: ' + (Siesta.meta.VERSION || '1.0.0'),
            bodyPadding : 5,
            modal       : true,
            width       : 500,
            height      : 380,
            closeAction : 'destroy',
            plain       : true,
            autoScroll  : true,
            buttons  : {
                padding : '10 13',
                style : 'background: transparent',

                items :[
                    {
                        cls         : 'light-button',
                        href        : 'http://www.bryntum.com/products/siesta/download-lite',
                        hrefTarget  : '_blank',
                        scale       : 'medium',
                        text        : 'Download v' + latestVersion + ' (Lite)'
                    },
                    {
                        cls         : 'light-button',
                        href        : 'http://bryntum.com/customerzone',
                        hrefTarget  : '_blank',
                        scale       : 'medium',
                        text        : 'Download v' + latestVersion + ' (Standard)'
                    },
                    {
                        text    : 'Cancel',
                        scale       : 'medium',
                        handler : function() { this.up('window').close(); }
                    }
                ]
            }
        })

        win.show();
        win.body.mask('Loading changelog...');
        Ext.data.Connection.prototype.useDefaultXhrHeader = false;

        Ext.Ajax.request({
            url         : 'http://bryntum.com/changelogs/_siesta.php',
            callback    : function(o, success, response) {
                win.body.unmask();

                if (success && response && response.responseText) {
                    win.body.update(response.responseText);
                } else {
                    win.body.update('Bummer! Failed to fetch changelog.');
                }
            }
        })

        Ext.data.Connection.prototype.useDefaultXhrHeader = true;
    }
});;
Ext.define('Siesta.Harness.Browser.UI.Viewport', {

    extend          : 'Ext.container.Viewport',
    
    mixins          : [
        'Siesta.Harness.Browser.UI.CanFillAssertionsStore'
    ],

//    requires        : [
//        'Ext.state.LocalStorageProvider',
//        'Ext.state.CookieProvider',
//
//        'ExtX.Reference.Slot',
//
//        'Siesta.Harness.Browser.Model.TestTreeStore',
//        'Siesta.Harness.Browser.UI.TestGrid',
//        'Siesta.Harness.Browser.UI.ResultPanel',
//        'Siesta.Harness.Browser.UI.MouseVisualizer',
//        'Siesta.Harness.Browser.UI.Header'
//    ],

    title           : null,

    harness         : null,

    // need to set stateful properties before `initComponent`
    stateful        : false,

    // stateful
    selection       : null,
    selectedURL     : null,
    filter          : null,
    filterGroups    : false,
    // eof stateful

    testsStore      : null,

    contextMenu     : null,
    mouseVisualizer : null,

    collapsedNodes  : null,

    initComponent : function () {
        Ext.state.Manager.setProvider(Ext.supports.LocalStorage ? new Ext.state.LocalStorageProvider() : new Ext.state.CookieProvider())

        this.selection      = {}
    
        if (this.harness.stateful) this.applyState(this.loadState())

        var testsStore      = this.testsStore = new Siesta.Harness.Browser.Model.FilterableTreeStore({
            model           : 'Siesta.Harness.Browser.Model.TestFile',
        
            sortOnLoad      : false,
        
            root            : { expanded : true, loaded : true },
        
            proxy           : {
                type        : 'memory',
            
                data        : this.buildTreeData({
                    id          : 'root',
                    group       : 'test suite' + this.title,
                    items       : this.harness.descriptors
                }).children,
            
                reader      : {
                    type    : 'json'
                }
            },
            
            listeners       : {
                collapse    : this.saveState,
                expand      : this.saveState,
                
                scope       : this
            }
        })
    
        testsStore.load()

        Ext.apply(this, {
            mouseVisualizer : Ext.isIE ? undefined : new Siesta.Harness.Browser.UI.MouseVisualizer({ harness : this.harness }),
            slots           : true,
            plugins         : new Siesta.Harness.Browser.UI.VersionChecker({ renderTo : 'update-ct'}),
            layout          : 'border',

            items           : [
                {
                    region      : 'west',

                    xtype       : 'testgrid',
                    slot        : 'filesTree',
                    id          : this.harness.id + '-testTree',

                    iconCls     : 'tr-status-neutral-small',

                    stateConfig : this.getState(),

                    animate     : !Ext.isIE,
                    split       : true,

                    filter          : this.filter,
                    filterGroups    : this.filterGroups,

                    listeners   : {
                        selectionchange     : this.onSelectionChange,
                        checkchange         : this.onCheckChange,

                        itemcontextmenu     : this.onFilesContextMenu,
                        itemdblclick        : this.onTestFileDoubleClick,
                        showcoverageinfo    : this.showCoverageReport,

                        resize              : function () {
                            // preserve min width of the assertion grid
                            this.slots.resultPanel.ensureLayout()
                        },

                        scope               : this
                    },

                    store       : testsStore
                },
                {
                    xtype           : 'container',
                    slot            : 'center',
                    region          : 'center',
                    cls             : 'center-ct',
                    layout          : {
                        type            : 'card',
                        deferredRender  : true
                    },
                    items           : [
                        {
                            xtype       : 'resultpanel',
                            region      : 'center',
                            slot        : 'resultPanel',
                            cls         : 'resultPanel-panel',
                            viewDOM     : this.getOption('viewDOM'),
                            id          : this.harness.id + '-resultpanel',
                            harness     : this.harness,

                            maintainViewportSize    : this.harness.maintainViewportSize,

                            listeners       : {
                                viewdomchange       : function(g, value) {
                                    this.setOption('viewDOM', value);
                                    this.saveState();
                                },

                                startrecord         : function() {
//                                    this.slots.filesTree.collapse();
                                },

                                rerun               : this.rerunTest,

                                scope               : this
                            }
                        },
                        {
                            xtype               : Ext.ClassManager.getByAlias('widget.coveragereport') ? 'coveragereport' : 'container',
                            slot                : 'coverageReport',
                            listeners           : {
                                backtomainui    : this.showMainUI,
                                scope           : this
                            }
                        }
                    ]
                }
            ]
            // eof main content area
        })
    
        this.callParent()
        
        // for some reason doesn't work, when specified as the "listeners" config in the "viewConfig" option above
        this.slots.filesTree.getView().on('viewready', this.onViewReady, this, { single : true })

        this.slots.filesTree.on({
            optionchange            : this.onOptionChange,
            beforesettingsmenushow  : this.onSettingsMenuBeforeShow,
            buttonclick             : this.onMainButtonClick,

            collapse                : function() {
                Ext.getBody().down('.logo-link').hide();
            },

            expand                  : function() {
                Ext.getBody().down('.logo-link').show();
            },

            scope                   : this
        });

        // delay is required to avoid recursive loop
        this.on('afterlayout', this.onAfterLayout, this, { single : true, delay : 1 })
        
        this.slots.filesTree.store.on({
            'filter-set'        : this.saveState,
            'filter-clear'      : this.saveState,
            
            scope               : this
        })
        
        this.harness.on('testendbubbling', this.onEveryTestEnd, this)
        this.harness.on('hassomecoverageinfo', this.onHasSomeCoverageInfo, this)
        this.harness.on('nocoverageinfo', this.onNoCoverageInfo, this)
        this.harness.on('testsuitelaunch', this.onTestSuiteLaunch, this)
    },

    
    buildTreeData : function (descriptor) {
        var data    = {
            id          : descriptor.id,
            title       : descriptor.group || descriptor.title || descriptor.name || descriptor.url.replace(/(?:.*\/)?([^/]+)$/, '$1'),
            descriptor  : descriptor
        }
    
        var me              = this
        var prevId          = data.id
        var collapsedNodes  = this.collapsedNodes || {}
    
        if (descriptor.group) {
        
            var children    = []
        
            Ext.each(descriptor.items, function (desc) {
                children.push(me.buildTreeData(desc))
            })
        
            Ext.apply(data, {
                expanded        : (collapsedNodes[ prevId ] != null || descriptor.expanded === false) ? false : true,
                // || false is required for TreeView - it checks that "checked" field contains Boolean
                checked         : me.selection.hasOwnProperty(prevId) || false,
            
                folderStatus    : 'yellow',
            
                children        : children,
                leaf            : false
            })
        
        } else {
            Ext.apply(data, {
                url             : descriptor.url,
            
                leaf            : true,
                // || false is required for TreeView - it checks that "checked" field contains Boolean
                checked         : me.selection.hasOwnProperty(prevId) || false,
            
                passCount       : 0,
                failCount       : 0,
            
                time            : 0,
            
                assertionsStore : new Siesta.Harness.Browser.Model.AssertionTreeStore({
                    //autoDestroy : true,
                    model       : 'Siesta.Harness.Browser.Model.Assertion',
                    
                    proxy       : {
                        type        : 'memory',
                        reader      : { type : 'json' }
                    },
                    
                    root        : {
                        id              : '__ROOT__',
                        expanded        : true,
                        loaded          : true
                    }
                })
            })
        }
    
        return data
    },


    onAfterLayout : function () {
        if (this.getOption('autoRun')) {
            var checked     = this.getChecked()
        
            // either launch the suite for checked tests or for all
            this.harness.launch(checked.length && checked || this.harness.descriptors)
        }
    },


    onViewReady : function () {
        if (this.selectedURL) {
            var testFile    = this.testsStore.getNodeById(this.selectedURL)
        
            if (testFile) this.slots.filesTree.getSelectionModel().select(testFile)
        }
    },


    onSelectionChange : function (selModel, selectedRecords) {
    
        if (selectedRecords.length) {
            var testFile        = selectedRecords[ 0 ]
            var test            = testFile.get('test')
        
            if (test) this.slots.resultPanel.showTest(test, testFile.get('assertionsStore'))
        
            this.selectedURL = testFile.getId()
        
            this.saveState()
        }
    },


    onCheckChange : function (testFile, checked) {
        this.setNodeChecked(testFile, checked)
    },


    setNodeChecked : function (testFile, checked, doNotCascade, skipSave) {
        var me      = this
        var id      = testFile.getId()
    
        if (checked)
            this.selection[ id ] = 1
        else
            delete this.selection[ id ]

        
        testFile.set('checked', checked)
        
        // when unchecking the node - uncheck the parent node (folder) as well 
        if (!checked && testFile.parentNode) me.setNodeChecked(testFile.parentNode, false, true, true)
    
        // only cascade for folders and when `doNotCascade` is false
        if (!testFile.isLeaf() && !doNotCascade) Ext.each(testFile.childNodes, function (childNode) {
            me.setNodeChecked(childNode, checked, false, true)
        })
    
        if (!skipSave) this.saveState()
    },


    // returns the NodeStore of the TreeStore - flattened presentation of the tree (it's potentially filtered)
    getNodeStore : function () {
        return this.slots.filesTree.getView().store
    },
    
    
    forEachTestFile : function (func, scope) {
        var nodeStore   = this.getNodeStore()
        
        if (this.testsStore.isTreeFiltered())
            nodeStore.each(func, scope)
        else
            Ext.Array.each(this.testsStore.tree.flatten(), func, scope)
    },


    getChecked : function () {
        var descriptors     = []
    
        this.forEachTestFile(function (testFileRecord) {
        
            if (testFileRecord.get('checked') && testFileRecord.isLeaf()) descriptors.push(testFileRecord.get('descriptor'))
        })
    
        return descriptors
    },

    runChecked : function () {
        var checked = this.getChecked();

        if (checked.length > 0) {
            this.harness.launch(this.getChecked())
        }
    },


    runFailed : function () {
        var descriptors     = []

        this.forEachTestFile(function (testFileRecord) {

            var test    = testFileRecord.get('test')

            if (test && test.isFailed()) descriptors.push(testFileRecord.get('descriptor'))
        })

        if (descriptors.length > 0) {
            this.harness.launch(descriptors)
        }
    },


    runAll : function () {
        var allDesc     = []

        this.forEachTestFile(function (testFile) {
            if (testFile.isLeaf()) allDesc.push(testFile.get('descriptor'))
        })

        if (allDesc.length > 0) {
            this.harness.launch(allDesc)
        }
    },


    stopSuite : function (button) {
        this.performStop();
        button.disable()
    
        setTimeout(function () {
        
            button.enable()
        
        }, 1000)
    },

    performStop : function() {
        this.harness.needToStop = true;
    
        Ext.each(this.testsStore.tree.flatten(), function (testFileRecord) {
            if (testFileRecord.get('isStarting') && !testFileRecord.get('isStarted')) {
                testFileRecord.set('isStarting', false);
            }
        });
    },


    // looks less nice than setting it only after preload for some reason
    onBeforeScopePreload : function (scopeProvider, url) {
        var testRecord          = this.testsStore.getNodeById(url)
    
        // to avoid disturbing grid
        testRecord.data.isStarted = true
    },


    isTestRunningVisible : function (test) {
        // return false for test's running in popups (not iframes), since we can't show any visual accompaniment for them
        if (!(test.scopeProvider instanceof Scope.Provider.IFrame)) return false;
    
        // if there is a "forced to be on top" test then we only need to compare the tests instances
        if (this.harness.testOfForcedIFrame) {
            return this.harness.testOfForcedIFrame.isFromTheSameGeneration(test)
        }
    
        // otherwise the only possibly visible test is the one of the current assertion grid
        var resultPanel = this.slots.resultPanel;
    
        // if resultPanel has no testRecord it hasn't yet been assigned a test record
        if (!resultPanel.test || !resultPanel.test.isFromTheSameGeneration(test)) {
            return false;
        }
    
        // now we know that visible assertion grid is from our test and there is no "forced on top" test
        // we only need to check visibility (collapsed / expanded of the right panel 
        return resultPanel.isFrameVisible()
    },
    
    
    resetDescriptors : function(descriptors) {
        var testsStore          = this.testsStore;

        Joose.A.each(this.harness.flattenDescriptors(descriptors), function(descriptor){
            var testRecord = testsStore.getNodeById(descriptor.id);
        
            testRecord.get('assertionsStore').removeAll(true)
            testRecord.reject();
            // || false is required for TreeView - it checks that "checked" field contains Boolean
            testRecord.set('checked', this.selection.hasOwnProperty(descriptor.id) || false)
        }, this);
    },


    // method is called when test suite (any several tests) starts - before caching the script contents
    // at this point we don't know yet about missing test files
    onTestSuiteStart : function (descriptors) {
        Ext.getBody().addCls('testsuite-running');

        var harness             = this.harness
        var filesTree           = this.slots.filesTree
        var selModel            = filesTree.getSelectionModel()
        var prevSelection       = selModel.getLastSelected()
        var testsStore          = this.testsStore
    
        Ext.suspendLayouts();
        
        this.resetDescriptors(descriptors);
    
        // restore the selection after data reload
        if (prevSelection) selModel.select(testsStore.getNodeById(prevSelection.getId()))
    },


    // method is called when test suite (any several tests) launches - after the caching the script contents
    // has completed and 1st test is about to start
    // at this point we know about missing files and `desc.isMissing` property is set
    onTestSuiteLaunch : function (event, descriptors) {
        var testsStore          = this.testsStore
    
        var updated             = {}
    
        Joose.A.each(this.harness.flattenDescriptors(descriptors), function (descriptor) {
            var testRecord  = testsStore.getNodeById(descriptor.id)
        
            testRecord.set({
                isMissing   : descriptor.isMissing,
                isStarting  : true
            })
            
            var groupNode   = testRecord.parentNode
            
            if (groupNode && !updated[ groupNode.getId() ]) {
                // trying hard to prevent extra updates
                for (var node = groupNode; node; node = node.parentNode) updated[ node.getId() ] = true
                
                groupNode.updateFolderStatus()
            }
        })

        Ext.resumeLayouts();
    },
    
    
    onTestSuiteEnd : function (descriptors) {
        Ext.getBody().removeCls('testsuite-running');
        
        this.updateStatusIndicator();

        if (this.slots.center.getLayout().getActiveItem() === this.slots.coverageReport) {
            // Load new data into coverage report
            this.slots.coverageReport.loadHtmlReport(this.harness.generateCoverageHtmlReport(false));
        }
    },
    

    onTestStart : function (test) {
        var testRecord          = this.testsStore.getNodeById(test.url)
        
        testRecord.beginEdit()
    
        // will trigger an update in grid
        testRecord.set({
            test        : test,
            isRunning   : true
        })
        
        testRecord.endEdit()
        
        var currentSelection    = this.slots.filesTree.getSelectionModel().getLastSelected()
    
        // activate the assertions grid for currently selected row, or, if the main area is empty
        if (currentSelection && currentSelection.getId() == test.url) {
            var resultPanel         = this.slots.resultPanel
            
            resultPanel.showTest(test, testRecord.get('assertionsStore'))
        }
    },
    
    
    // this method checks that test update, coming from given `test` is actual
    // update may be not actual, if user has re-launched the test, so new test already presents
    isTestUpdateActual : function (test, testRecord) {
        testRecord          = testRecord || this.testsStore.getNodeById(test.url)
        
        var currentTest     = testRecord.get('test')
        
        return currentTest && currentTest.isFromTheSameGeneration(test)
    },


    onTestUpdate : function (test, result, parentResult) {
        var testRecord      = this.testsStore.getNodeById(test.url)
        
        // need to check that test record contains the same test instance as the test in arguments (or its sub-test)
        // test instance may change if user has restarted a test for example
        if (this.isTestUpdateActual(test, testRecord)) {
            this.processNewResult(testRecord.get('assertionsStore'), test, result, parentResult)
            
            if (this.getOption('breakOnFail') && test.getFailCount() > 0) {
                this.performStop();
                this.slots.filesTree.getSelectionModel().select(testRecord);
            }
        }
    },



    // only triggered for "root" tests
    onTestEnd : function (test) {
        var testRecord          = this.testsStore.getNodeById(test.url)
        
        // need to check that test record contains the same test instance as the test in arguments (or its sub-test)
        // test instance may change if user has restarted a test for example
        if (this.isTestUpdateActual(test, testRecord)) {
            testRecord.beginEdit()
    
            testRecord.set({
                'passCount'         : test.getPassCount(),
                'failCount'         : test.getFailCount(),
                'todoPassCount'     : test.getTodoPassCount(),
                'todoFailCount'     : test.getTodoFailCount(),
                'time'              : test.getDuration() + 'ms'
            });
      
            testRecord.endEdit()
        
            testRecord.parentNode && testRecord.parentNode.updateFolderStatus()
        }
        
        this.updateStatusIndicator()
    },
    
    
    // is bubbling and thus triggered for all tests (including sub-tests) 
    onEveryTestEnd : function (event, test) {
        var testRecord          = this.testsStore.getNodeById(test.url)
        
        // need to check that test record contains the same test instance as the test in arguments (or its sub-test)
        // test instance may change if user has restarted a test for example
        if (this.isTestUpdateActual(test, testRecord)) {
            this.processEveryTestEnd(testRecord.get('assertionsStore'), test)
        }
    },
    
    
    onTestFail : function (test, exception, stack) {
        var testRecord  = this.testsStore.getNodeById(test.url)
        
        // need to check that test record contains the same test instance as the test in arguments
        // test instance may change if user has restarted a test for example
        if (this.isTestUpdateActual(test, testRecord) && !test.isTodo) {
            testRecord.set('isFailed', true)
        
            testRecord.parentNode && testRecord.parentNode.updateFolderStatus()
        }
    },
    
    
    getOption : function (name) {
        switch (name) {
            case 'selection'    : return this.selection
            
            case 'selectedURL'  : return this.selectedURL
            
            default             : return this.harness[ name ]
        }
    },
    
    
    setOption : function (name, value) {
        switch (name) {
            case 'selection'    : return this.selection         = value || {}
            
            case 'selectedURL'  : return this.selectedURL       = value
            
            case 'collapsedNodes': return this.collapsedNodes   = value
            
            case 'filter'       : return this.filter            = value
            case 'filterGroups' : return this.filterGroups      = value
            
            default             : return this.harness[ name ]   = value
        }
    },


    getState : function () {
        return {
            // harness configs
            autoRun         : this.getOption('autoRun'),
            speedRun        : this.getOption('speedRun'),
            viewDOM         : this.getOption('viewDOM'),
            keepResults     : this.getOption('keepResults'),
            cachePreload    : this.getOption('cachePreload'),
            transparentEx   : this.getOption('transparentEx'),
            breakOnFail     : this.getOption('breakOnFail'),
        
            // UI configs
            selectedURL     : this.selectedURL,
            
            selection       : this.getCheckedNodes(),
            collapsedNodes  : this.getCollapsedFolders(),
            
            filter          : this.slots ? this.slots.filesTree.getFilterValue() : this.filter,
            filterGroups    : this.slots ? this.slots.filesTree.getFilterGroups() : this.filterGroups
        }
    },
    
    
    getCheckedNodes : function () {
        var checked        = {}
        
        Joose.A.each(this.testsStore.tree.flatten(), function (treeNode) {
            if (treeNode.get('checked')) checked[ treeNode.getId() ] = 1
        })
        
        return checked
    },
    
    
    getCollapsedFolders : function () {
        var collapsed        = {}
        
        Joose.A.each(this.testsStore.tree.flatten(), function (treeNode) {
            if (!treeNode.isLeaf() && !treeNode.isExpanded()) collapsed[ treeNode.getId() ] = 1
        })
        
        return collapsed
    },
    
    
    applyState : function (state) {
        var me  = this
        
        if (state) Joose.O.each(state, function (value, name) {
            me.setOption(name, value)
        })
    },


    getStateId : function () {
        return 'test-run-' + this.title
    },


    onOptionChange : function (component, optionName, optionValue) {
        this.setOption(optionName, optionValue)
    
        if (optionName == 'viewDOM') {
            var resultPanel = this.slots.resultPanel;
            
            resultPanel.setViewDOM(optionValue);
        }

        this.saveState()
    },
    
    
    loadState : function () {
        var stateId     = this.getStateId()
        var state       = Ext.state.Manager.get(stateId)
        
        if (!state) return
        
        if (!state.collapsedNodes)  state.collapsedNodes    = Ext.state.Manager.get(stateId + '-collapsed')
        if (!state.selection)       state.selection         = Ext.state.Manager.get(stateId + '-selection')
        
        return state
    },


    saveState : function () {
        var stateId     = this.getStateId()
        var state       = this.getState()
        
        Ext.state.Manager.set(stateId + '-collapsed', state.collapsedNodes)
        Ext.state.Manager.set(stateId + '-selection', state.selection)
        
        delete state.collapsedNodes
        delete state.selection
        
        Ext.state.Manager.set(stateId, state)
    },


    uncheckAllExcept : function (testFile) {
        var me      = this
    
        Ext.each(this.testsStore.tree.flatten(), function (node) {
        
            if (node != testFile) me.setNodeChecked(node, false, true)
        })
    },
    
    buildContextMenu : function () {
        return new Ext.menu.Menu({
        
            renderTo    : Ext.getBody(),
        
            defaults    : {
                scope   : this
            },
        
            items       : [
                {
                    text        : 'Uncheck others (and check this)',
                    handler     : this.uncheckOthersHandler
                },
                {
                    text        : 'Uncheck all',
                    handler     : this.uncheckAllHandler
                },
                {
                    text        : 'Check all',
                    handler     : this.checkAllHandler
                },
                {
                    text        : 'Run this',
                    handler     : this.runThisFileHandler
                }
            ]
        })
    },


    uncheckOthersHandler : function () {
        var currentFile     = this.currentFile
    
        this.uncheckAllExcept(currentFile)
    
        this.setNodeChecked(currentFile, true)
    },


    runThisFileHandler : function () {
        this.harness.launch([ this.currentFile.get('descriptor') ])
    },


    uncheckAllHandler : function () {
        this.uncheckAllExcept()
    },


    checkAllHandler : function () {
        var me      = this
    
        Ext.each(this.testsStore.tree.flatten(), function (node) {
        
            me.setNodeChecked(node, true, true)
        })
    },


    onFilesContextMenu : function (view, testFile, el, index, event) {
        this.currentFile    = testFile

        if (!this.contextMenu) {
            this.contextMenu = this.buildContextMenu();
        }

        this.contextMenu.setPagePosition(event.getX(), event.getY())
    
        this.contextMenu.show();
    
        event.preventDefault();
    },


    onTestFileDoubleClick : function (view, testFile) {
        if (this.testsStore.isTreeFiltered() && !testFile.isLeaf()) {
            var childDesc       = []
            var nodeStore       = this.testsStore.nodeStore
            
            for (var i = nodeStore.indexOf(testFile) + 1; i < nodeStore.getCount(); i++) {
                var currentNode     = nodeStore.getAt(i)
                
                if (!currentNode.isAncestor(testFile)) break 
                
                if (currentNode.isLeaf()) childDesc.push(currentNode.get('descriptor'))
            }
            
            this.harness.launch(childDesc);
        } else 
            this.launchTest(testFile);
    },

    
    launchTest : function (testFile) {
        var resultPanel     = this.slots.resultPanel
        
        if (testFile.data.leaf && (testFile.get('test') == resultPanel.test || !resultPanel.test)) {
            // clear the content of the result panel, but only in case we are launching a currently shown test
            // (we could be also launching some other test)
            // assertions of the tests being launched will be cleared in the `onTestSuiteStart` method
            resultPanel.clear();
        }
        
        this.harness.launch([ testFile.get('descriptor') ])
    },

    
    updateStatusIndicator : function () {
        // can remain neutral if all files are missing for example
//        var isNeutral       = true
//        var allGreen        = true
//        var hasFailures     = false
    
        var totalPassed     = 0
        var totalFailed     = 0
    
        Joose.O.each(this.testsStore.tree.nodeHash, function (testFileRecord) {
            var test        = testFileRecord.get('test')
        
            // if there's at least one test - state is not neutral
            if (test && test.isFinished()) {
//                isNeutral       = false
            
//                allGreen        = allGreen      && test.isPassed()
//                hasFailures     = hasFailures   || test.isFailed()
            
                totalPassed     += test.getPassCount()
                totalFailed     += test.getFailCount()
            }
        })

        this.slots.filesTree.updateStatus(totalPassed, totalFailed);
    },

    onSettingsMenuBeforeShow : function(hdr, menu) {
        menu.down('[option=viewDOM]').setChecked(this.getOption('viewDOM'));
    },

    onMainButtonClick : function(hdr, button, action) {
        switch(action) {
            case 'run-checked':
                this.runChecked();
            break;
            case 'run-failed':
                this.runFailed();
            break;
            case 'run-all':
                this.runAll();
            break;
            case 'stop':
                this.stopSuite(button);
            break;
        }
    },
    
    rerunTest : function () {
        var toRun = this.slots.filesTree.getSelectionModel().getSelection()[ 0 ];
        
        if (toRun) {
            this.launchTest(toRun);
        }
    },

    afterRender : function() {
        this.callParent(arguments);

        Ext.getBody().createChild([
            {
                tag     : 'a',
                cls     : "logo-link",
                href    : "#",
                cn      : [{
                    tag     : 'img',
                    src     : Ext.BLANK_IMAGE_URL
                },
                {
                    tag  : 'span',
                    html : 'v.' + (Siesta.meta.VERSION || "1.0.0"),
                    cls  : 'tr-version-indicator'
                },
                {
                    tag  : 'div',
                    cls  : 'tr-progress-indicator'
                }]
            },
            {
                tag     : 'ul',
                cls     : "right-top-area",
                cn      : [
                    {
                        tag     : 'li',
                        html    : '<a id="bryntum-logo" href="http://bryntum.com/" target="_blank" class="bryntum-logo"></a>'
                    },
                    {
                        tag     : 'li',
                        style   : 'margin-top:3px',
                        html    : '<a href="http://bryntum.com/docs/siesta" target="_blank">API Documentation</a>'
                    }
                ]
            },

            {
                tag     : 'div',
                id      : 'update-ct'
            }
        ]);

        Ext.getBody().on({
            keyup : function(e,t) {
                if (e.getKey() === e.ENTER && e.ctrlKey) {
                    // TODO
                }
            }
        });
    },
    
    onHasSomeCoverageInfo : function () {
        this.slots.filesTree.enableCoverageButton();
    },
    
    onNoCoverageInfo : function () {
        this.slots.filesTree.disableCoverageButton()
    },

    showCoverageReport : function () {
        var resultPanel                 = this.slots.resultPanel
        var coverageReport              = this.slots.coverageReport
        
        coverageReport.loadHtmlReport(this.harness.generateCoverageHtmlReport(false));

        if (this.slots.center.getLayout().getActiveItem() === this.slots.resultPanel) {
            this.slots.resultPanel.hideIFrame()

            this.slots.center.getLayout().setActiveItem(1)
        } else {
            this.showMainUI();
        }
    },

    showMainUI: function () {
        this.slots.center.getLayout().setActiveItem(0)
        
        this.slots.resultPanel.alignIFrame()
    }
})
//eof Siesta.Harness.Browser.UI.Viewport
;
Ext.define('Siesta.Harness.Browser.UI.ExtViewport', {

    extend          : 'Siesta.Harness.Browser.UI.Viewport',

//    requires        : [
//        'Siesta.Harness.Browser.UI.ExtHeader'
//    ],

    headerClass     : 'Siesta.Harness.Browser.UI.ExtHeader',
    
    
    setOption : function (name, value) {
        switch (name) {
            case 'extVersion'   : return this.harness.setExtVersion(value)
            
            default             : return this.callParent(arguments)
        }
    }
//    ,
//    
//    
//    getState : function () {
//        var state       = this.callParent()
//        
//        var extVersion  = this.getOption('extVersion')
//        
//        if (extVersion && this.getOption('allowExtVersionChange')) state.extVersion = extVersion
//        
//        return state
//    } 
})
//eof Siesta.Harness.Browser.UI.ExtViewport
;
};
;
